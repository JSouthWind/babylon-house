{"version":3,"sources":["webpack:///./assets/glb/haunted_house.glb","webpack:///./assets/john-o-nolan-o_gJAkcKJmM-unsplash.jpg","webpack:///../../../sourceES6/loaders/src/glTF/glTFValidation.ts","webpack:///../../../sourceES6/loaders/src/glTF/glTFFileLoader.ts","webpack:///../../../../sourceES6/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts","webpack:///../../../../sourceES6/loaders/src/glTF/1.0/glTFLoader.ts","webpack:///../../../../sourceES6/loaders/src/glTF/1.0/glTFLoaderUtils.ts","webpack:///../../../../sourceES6/loaders/src/glTF/1.0/glTFBinaryExtension.ts","webpack:///../../../../sourceES6/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack:///../../../../sourceES6/loaders/src/glTF/2.0/glTFLoader.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts","webpack:///../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts","webpack:///../../../sourceES6/materialsLibrary/src/cell/cell.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/cell/cell.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/cell/cellMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/custom/customMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/custom/pbrCustomMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/fire/fire.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/fire/fire.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/fire/fireMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/fur/fur.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/fur/fur.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/fur/furMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/gradient/gradient.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/gradient/gradient.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/gradient/gradientMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/grid/grid.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/grid/grid.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/grid/gridMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/lava/lava.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/lava/lava.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/lava/lavaMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/mix/mix.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/mix/mix.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/mix/mixMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/normal/normal.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/normal/normal.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/normal/normalMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/shadowOnly/shadowOnly.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/shadowOnly/shadowOnly.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/shadowOnly/shadowOnlyMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/simple/simple.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/simple/simple.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/simple/simpleMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/sky/sky.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/sky/sky.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/sky/skyMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/terrain/terrain.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/terrain/terrain.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/terrain/terrainMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/triPlanar/triplanar.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/triPlanar/triplanar.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/triPlanar/triPlanarMaterial.ts","webpack:///../../../sourceES6/materialsLibrary/src/water/water.fragment.ts","webpack:///../../../sourceES6/materialsLibrary/src/water/water.vertex.ts","webpack:///../../../sourceES6/materialsLibrary/src/water/waterMaterial.ts","webpack:///./src/scenes/defaultWithTexture.ts"],"names":["validateAsync","data","rootUrl","fileName","getExternalResource","options","externalResourceFunction","uri","then","value","Uint8Array","ArrayBuffer","GLTFValidator","validateBytes","validateString","workerFunc","pendingExternalResources","onmessage","message","id","importScripts","url","Promise","resolve","reject","index","length","push","postMessage","reason","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","ValidateAsync","Worker","workerContent","workerBlobUrl","URL","createObjectURL","Blob","type","worker","onError","error","removeEventListener","onMessage","addEventListener","GetAbsoluteUrl","Configuration","this","_LoadScriptPromise","LoadScriptAsync","onParsedObservable","coordinateSystemMode","AUTO","animationStartMode","FIRST","compileMaterials","useClipPlane","compileShadowGenerators","transparencyAsCoverage","useRangeRequests","createInstances","preprocessUrlAsync","onMeshLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","validate","onValidatedObservable","_loader","name","extensions","isBinary","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","callback","_onParsedObserver","remove","add","_onMeshLoadedObserver","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","_onCompleteObserver","_onErrorObserver","_onDisposeObserver","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","dispose","_clear","notifyObservers","undefined","clear","requestFile","scene","onSuccess","onProgress","useArrayBuffer","Warn","Array","abort","forEach","fileRequest","readAsync","byteOffset","byteLength","_requestFile","webRequest","contentRange","getResponseHeader","Number","split","setRequestHeader","_unpackBinaryAsync","loaderData","request","arrayBuffer","response","_validate","GetFolderPath","GetFilename","json","_parseJson","readFile","file","_readFile","importMeshAsync","meshesNames","_getLoader","loadAsync","loadAssetContainerAsync","materials","material","textures","texture","result","container","prototype","apply","meshes","particleSystems","skeletons","animationGroups","lights","transformNodes","canDirectLoad","indexOf","directLoad","createPlugin","GLTFFileLoader","state","whenCompleteAsync","addOnce","_loadFileAsync","asset","version","minVersion","generator","_parseVersion","Error","_compareVersion","major","minor","createLoader","1","_CreateGLTF1Loader","2","_CreateGLTF2Loader","parsed","JSON","parse","dataReader","magic","readUint32","loggingEnabled","unpacked","buffer","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","readString","bin","ChunkFormat","chunkLength","skipBytes","match","parseInt","a","b","_logOpen","_logClose","spaces","_logSpaces","substr","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","IncrementalLoading","HomogeneousCoordinates","RegisterPlugin","EComponentType","EShaderType","EParameterType","ETextureWrapMode","ETextureFilterType","ETextureFormat","ECullingType","EBlendingFunction","ETokenType","SetMatrix","source","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","multiply","invert","getTransformMatrix","FLOAT_MAT2","setMatrix2x2","GetAsMatrix2x2","FLOAT_MAT3","setMatrix3x3","GetAsMatrix3x3","FLOAT_MAT4","setMatrix","SetUniform","uniform","FLOAT","setFloat","FLOAT_VEC2","setVector2","FromArray","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","GetWrapMode","mode","CLAMP_TO_EDGE","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","GetByteStrideFromType","accessor","GetTextureFilterMode","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_SAMPLINGMODE","BILINEAR_SAMPLINGMODE","GetBufferFromBufferView","gltfRuntime","bufferView","componentType","loadedBufferView","loadedBufferViews","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","GetBufferFromAccessor","bufferViews","count","GLTFUtils","DecodeBufferToText","view","i","String","fromCharCode","GetDefaultMaterial","_DefaultMaterial","ShadersStore","join","attributes","uniforms","samplers","needAlphaBlending","vertex","fragment","setColor4","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","read","test","IDENTIFIER","peek","forward","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseObject","parsedObjects","runtimeProperty","object","parsedObject","normalizeUVs","getAttribute","attributeParameter","channel","configureBoneTransformation","node","translation","rotation","scale","position","Compose","matrix","getParentBone","skins","jointName","newSkeleton","bones","nodes","nde","children","child","bone","getNodeToRoot","nodesToRoot","nodeToRoot","j","getJointNode","nodeIsInJoints","jointNames","importSkeleton","mesh","babylonSkeleton","nodesToRootToAdd","k","_parent","getNodesToRoot","jointNode","existingBone","getBoneByID","foundBone","parentBone","joint","prepare","importMesh","newMesh","_blockEntityCollection","forAssetContainer","babylonNode","subMaterials","vertexData","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshID","primitives","tempVertexData","primitive","accessors","normals","set","positions","uvKind","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","getMaterialByID","computeWorldMatrix","subMeshes","AddToMesh","configureNode","newNode","scaling","rotationQuaternion","importNode","parent","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonByID","light","camera","cameras","orthoCamera","Zero","ORTHOGRAPHIC_CAMERA","attachControl","getEngine","getInputElement","perspectiveCamera","persCamera","aspectRatio","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","ambienLight","hemiLight","color","diffuse","directionalLight","dirLight","pointLight","ptLight","spotLight","spLight","fallOfAngle","angle","fallOffExponent","exponent","dummy","decompose","configureNodeFromMatrix","updateCache","traverseNodes","meshIncluded","postLoad","currentScene","thing","scenes","anim","animations","animation","channels","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","bufferOutput","targetID","target","targetNode","getNodeByID","getNodeByName","isBone","targetPath","path","targetPathIndex","animationType","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","ANIMATIONLOOPMODE_CYCLE","getBaseMatrix","frame","setKeys","stopAnimation","beginAnimation","loadAnimations","MAX_VALUE","onShaderCompileSuccess","technique","unTreatedUniforms","_","materialValues","values","techniqueUniforms","unif","onLoadTexture","setTexture","SAMPLER_2D","GLTFLoaderExtension","LoadTextureAsync","prepareShaderMaterialUniforms","onBind","getEffect","babylonTexture","onBindShaderMaterial","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","LoadMaterialAsync","CreateRuntime","parsedData","buffers","images","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","parseBuffers","parsedShaders","sha","parsedShader","parseShaders","LoadBufferAsync","IsBase64","setTimeout","DecodeBase64","LoadFile","status","statusText","LoadTextureBufferAsync","CreateTextureAsync","createMipMaps","minFilter","NEAREST_MIPMAP_LINEAR","samplingMode","blob","blobURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","wrapT","wrapV","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","CounterClockWiseSideOrientation","program","states","vertexShader","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","Tokenizer","pixelTokenizer","attr","attribute","foundAttribute","shaderPath","enable","effect","onShaderCompileError","onCompiled","functions","cullFace","BACK","backFaceCulling","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","RegisterExtension","extension","GLTFLoader","Extensions","_importMeshAsync","useRightHandedSystem","LoadRuntimeAsync","_createNodes","skl","_loadBuffersAsync","_loadShadersAsync","_loadAsync","LoadRuntimeExtensionsAsync","onload","hasShaders","processShader","VERTEX","bind","onLoad","hasBuffers","processBuffer","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","ApplyExtensions","loaderExtension","func","defaultFunc","extensionName","_bin","sourceExt","binaryExtensionShader","shaderBytes","ambientLight","ambient","point","directional","spot","fallOffAngle","Math","PI","standardMaterial","disableLighting","doubleSided","alpha","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","emissiveColor","specular","specularColor","propertyPath","Get","context","array","Assign","_completePromises","_forAssetContainer","_babylonLights","_disposed","_state","_extensions","_defaultBabylonMaterialData","_requests","factory","UnregisterExtension","_RegisteredExtensions","_gltf","_babylonScene","_rootBabylonMesh","_progressCallback","_rootUrl","_fileName","_loadData","map","_getMeshes","_getSkeletons","_getAnimationGroups","_getTransformNodes","resultFunc","_uniqueRootUrl","Date","now","_loadExtensions","_checkExtensions","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_setState","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadSceneAsync","ArrayItem","_compileMaterialsAsync","_compileShadowGeneratorsAsync","resultPromise","all","setEnabled","_extensionsOnReady","_startAnimations","SetImmediate","_setupData","binaryBuffer","nodeParents","rootNode","_createRootNode","parentIndex","sort","order","extensionsRequired","some","enabled","log","_babylonTransformNode","_LoadTransform","FORCE_RIGHT_HANDED","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","_babylonBones","linkTransformNode","_loadAnimationsAsync","logClose","_forEachPrimitive","_primitiveBabylonMeshes","getClassName","_data","_babylonAnimationGroup","NONE","babylonAnimationGroups","start","ALL","assign","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","nodeName","_loadMeshAsync","refreshBoundingInfo","_loadMeshPrimitiveAsync","_loadSkinAsync","_extensionsLoadMeshPrimitiveAsync","babylonAbstractMesh","promise","shouldInstance","targets","_instanceData","babylonSourceMesh","createInstance","overrideMaterialSideOrientation","ClockWiseSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","babylonDrawMode","_GetDrawMode","babylonMaterial","_createDefaultMaterial","_loadMaterialAsync","_extensionsLoadVertexDataAsync","isUnIndexed","_loadIndicesAccessorAsync","setIndices","loadAttribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","setVerticesBuffer","MatricesIndicesExtraKind","numBoneInfluencers","PositionKind","NormalKind","TangentKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesWeightsExtraKind","ColorKind","hasVertexAlpha","_numMorphTargets","targetNames","extras","morphTargetManager","getScene","weight","weights","addTarget","numTargets","babylonMorphTarget","getTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","setPositions","setNormals","tangents","dataIndex","setTangents","Identity","One","_extensionsLoadSkinAsync","assignSkeleton","skeletonId","overrideMesh","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","babylonBones","joints","_loadBone","babylonBone","babylonParentBone","boneIndex","_getNodeMatrix","inverseBindMatrices","baseMatrix","_index","FromArrayToRef","invertToRef","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","_extensionsLoadCameraAsync","perspective","fov","yfov","orthographic","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","loadAnimationAsync","_extensionsLoadAnimationAsync","babylonAnimationGroup","_loadAnimationChannelAsync","normalize","animationContext","animationTargetOverride","_loadAnimationSamplerAsync","ANIMATIONTYPE_FLOAT","getNextOutputValue","getNextKey","outputBufferOffset","interpolation","frameIndex","STEP","inTangent","outTangent","targetIndex","animationName","targetedAnimations","key","morphTarget","babylonAnimationClone","clone","addTargetedAnimation","inputAccessor","outputAccessor","_loadBufferAsync","_extensionsLoadBufferAsync","loadUriAsync","e","loadBufferViewAsync","_extensionsLoadBufferViewAsync","_loadAccessorAsync","constructor","numComponents","_GetNumComponents","byteStride","GetTypeByteLength","normalized","ForEach","_GetTypedArray","sparse","typedArray","indicesBufferView","valuesBufferView","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","_babylonVertexBuffer","babylonBuffer","size","_loadMaterialMetallicRoughnessPropertiesAsync","properties","baseColorFactor","albedoColor","White","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","albedoTexture","metallicRoughnessTexture","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","splice","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","useSpecularOverAlpha","transparencyMode","PBRMATERIAL_OPAQUE","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveFactor","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","forceIrradianceInFragment","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","PBRMATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","PBRMATERIAL_ALPHABLEND","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_loadTextureAsync","coordinatesIndex","_extensionsLoadTextureAsync","DefaultSampler","image","_createTextureAsync","samplerData","_loadSampler","deferred","noMipMaps","exception","mimeType","loadImageAsync","dataUrl","updateURL","_GetTextureSamplingMode","_GetTextureWrapMode","property","_extensionsLoadUriAsync","_ValidateUri","fileData","event","_lengthComputable","lengthComputable","_loaded","loaded","_total","total","_onProgress","offlineProvider","babylonObject","pointer","metadata","gltf","pointers","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","Uint32Array","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleFillMode","TriangleStripDrawMode","TriangleFanDrawMode","forceCompilationAsync","useInstances","clipPlane","getShadowGenerator","_forEachExtensions","action","_applyExtensions","functionName","actionAsync","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","LoadExtraAsync","extra","isExtensionUsed","startPerformanceCounter","endPerformanceCounter","NAME","loader","_lights","extensionContext","_loadLightAsync","babylonScene","environmentTexture","specularImages","mipmap","faces","face","specularImageContext","specularImageSize","_babylonTexture","intensity","Inverse","FromQuaternionToRef","getReflectionTextureMatrix","sphericalHarmonics","irradianceCoefficients","scaleInPlace","convertIrradianceToLambertianRadiance","sphericalPolynomial","FromHarmonics","lodGenerationScale","Log2","updateRGBDAsync","DecoderAvailable","dracoCompression","uniqueId","_dracoBabylonGeometry","Default","decodeMeshAsync","babylonVertexData","applyToGeometry","catch","LightType","babylonLight","DIRECTIONAL","Backward","POINT","SPOT","babylonSpotLight","outerConeAngle","innerAngle","innerConeAngle","falloffType","FALLOFF_GLTF","range","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","specularFactor","microSurface","glossinessFactor","diffuseTexture","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","_loadUnlitPropertiesAsync","unlit","_loadClearCoatPropertiesAsync","clearCoat","isEnabled","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","_loadSheenPropertiesAsync","sheen","intensityFactor","colorFactor","colorIntensityTexture","_loadSpecularPropertiesAsync","metallicF0Factor","specularTexture","useMetallicF0FactorFromMetallicTexture","KHR_mesh_quantization","gammaSpace","offset","uOffset","vOffset","uRotationCenter","vRotationCenter","wAng","uScale","vScale","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","_babylonSounds","sound","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","events","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","_babylonData","clipPromises","loop","autoplay","volume","clipContext","objectURL","_positionInEmitterSpace","weightedSound","directionalConeInnerAngle","directionalConeOuterAngle","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_indexLOD","_bufferLODs","indexLOD","_loadBufferLOD","firstPromise","nodeLODs","_getLODs","ids","nodeLOD","previousNodeLOD","_disposeTransformNode","materialLODs","materialLOD","previousDataLOD","_disposeMaterials","previousIndexLOD","end","min","max","bufferLOD","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","filter","every","babylonTextures","getActiveTextures","hasTexture","extraContext","forceDepthWrite","separateCullingPass","toLinearSpaceToRef","_assignExtras","gltfProp","Object","ExtrasAsMetadata","DIFFUSE","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","ALPHATEST","POINTSIZE","FOG","NORMAL","UV1","UV2","VERTEXCOLOR","VERTEXALPHA","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","NDOTL","CUSTOMUSERLIGHTING","CELLBASIC","DEPTHPREPASS","rebuild","_computeHighLevel","_disableLighting","_maxSimultaneousLights","needAlphaTesting","getAlphaTestTexture","isReadyForSubMesh","subMesh","isFrozen","_wasPreviouslyReady","_materialDefines","defines","checkReadyOnEveryCall","_renderId","getRenderId","engine","_areTexturesDirty","_needUVs","texturesEnabled","_diffuseTexture","DiffuseTextureEnabled","isReady","computeHighLevel","PrepareDefinesForMisc","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","_needNormals","PrepareDefinesForLights","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","isDirty","markAsProcessed","resetCachedMaterial","fallbacks","addFallback","HandleFallbacksForShadows","maxSimultaneousLights","addCPUSkinningFallback","attribs","PrepareAttributesForBones","PrepareAttributesForInstances","toString","uniformBuffers","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","setEffect","createEffect","indexParameters","bindForSubMesh","world","_activeEffect","bindOnlyWorldMatrix","BindBonesParameters","_mustRebind","setFloat2","getTextureMatrix","BindClipPlane","pointSize","BindEyePosition","visibility","lightsEnabled","BindLights","applyFog","fogMode","FOGMODE_NONE","BindFogParameters","_afterBind","getAnimatables","results","activeTextures","forceDisposeEffect","Clone","CellMaterial","serialize","serializationObject","Serialize","customType","Parse","RegisteredTypes","CustomParts","ShaderSpecialParts","customShaderNameResolve","Builder","FragmentShader","VertexShader","AttachAfterBind","el","_newUniformInstances","ea","_newSamplerInstances","ReviewUniform","arr","ind","_newUniforms","_customUniform","shaderName","_isCreatedShader","_createdShaderName","CustomMaterial","ShaderIndexer","fn_afterBind","m","replace","Vertex_Begin","Vertex_Definitions","Vertex_MainBegin","Vertex_Before_PositionUpdated","Vertex_Before_NormalUpdated","Vertex_MainEnd","Fragment_Begin","Fragment_MainBegin","Fragment_Definitions","Fragment_Custom_Diffuse","Fragment_Custom_Alpha","Fragment_Before_Lights","Fragment_Before_Fog","Fragment_Before_FragColor","AddUniform","param","shaderPart","ShaderAlebdoParts","PBRCustomMaterial","Fragment_Custom_Albedo","Fragment_Custom_MetallicRoughness","Fragment_Custom_MicroSurface","speed","_scaledDiffuse","_lastTime","_opacityTexture","_areMiscDirty","forcePointsCloud","transformFeedbackVaryings","_distortionTexture","getDeltaTime","FireMaterial","asArray","AddTagsTo","tags","wireframe","HEIGHTMAP","HIGHLEVEL","furLength","furAngle","furColor","furOffset","furSpacing","furGravity","furSpeed","furDensity","furOcclusion","highLevelFur","_furTime","furTime","updateFur","_meshes","offsetFur","furTexture","heightTexture","getCaps","maxVertexTextureImageUnits","markAsUnprocessed","getCachedMaterial","_heightTexture","FurMaterial","sourceMeshName","quality","executeWhenReady","sourceMesh","getMeshByName","GenerateTexture","FurifyMesh","getContext","fillStyle","floor","random","fillRect","getSize","width","height","update","pop","EnableFor","offsetMesh","EMISSIVE","topColor","topColorAlpha","bottomColor","bottomColorAlpha","smoothness","GradientMaterial","OPACITY","TRANSPARENT","PREMULTIPLYALPHA","mainColor","Black","lineColor","Teal","gridRatio","gridOffset","majorUnitFrequency","minorUnitVisibility","opacity","preMultiplyAlpha","_gridControl","needAlphaBlendingForMesh","OpacityTextureEnabled","setColor3","x","y","round","z","w","GridMaterial","LIGHT0","LIGHT1","LIGHT2","LIGHT3","SPOTLIGHT0","SPOTLIGHT1","SPOTLIGHT2","SPOTLIGHT3","HEMILIGHT0","HEMILIGHT1","HEMILIGHT2","HEMILIGHT3","DIRLIGHT0","DIRLIGHT1","DIRLIGHT2","DIRLIGHT3","POINTLIGHT0","POINTLIGHT1","POINTLIGHT2","POINTLIGHT3","SHADOW0","SHADOW1","SHADOW2","SHADOW3","SHADOWS","SHADOWESM0","SHADOWESM1","SHADOWESM2","SHADOWESM3","SHADOWPOISSON0","SHADOWPOISSON1","SHADOWPOISSON2","SHADOWPOISSON3","SHADOWPCF0","SHADOWPCF1","SHADOWPCF2","SHADOWPCF3","SHADOWPCSS0","SHADOWPCSS1","SHADOWPCSS2","SHADOWPCSS3","UNLIT","movingSpeed","lowFrequencySpeed","fogDensity","_unlit","noiseTexture","fogColor","LavaMaterial","SPECULARTERM","MIXMAP2","_mixTexture1","_diffuseTexture1","_diffuseTexture2","_diffuseTexture3","_diffuseTexture4","_mixTexture2","_diffuseTexture5","_diffuseTexture6","_diffuseTexture7","_diffuseTexture8","MixMaterial","LIGHTING","NormalMaterial","shadowColor","_activeLight","lightSources","shadowEnabled","lightPosition","ShadowOnlyMaterial","SimpleMaterial","luminance","turbidity","rayleigh","mieCoefficient","mieDirectionalG","distance","inclination","azimuth","sunPosition","useSunPosition","cameraOffset","_cameraPosition","activeCamera","cameraWorldMatrix","theta","phi","cos","sin","SkyMaterial","BUMP","mixTexture","diffuseTexture1","diffuseTexture2","diffuseTexture3","bumpTexture1","bumpTexture2","bumpTexture3","BumpTextureEnabled","_mixTexture","standardDerivatives","_bumpTexture1","_bumpTexture2","_bumpTexture3","TerrainMaterial","DIFFUSEX","DIFFUSEY","DIFFUSEZ","BUMPX","BUMPY","BUMPZ","tileSize","diffuseTextureX","diffuseTextureY","diffuseTextureZ","textureDefines","normalTextureX","normalTextureY","normalTextureZ","_diffuseTextureX","_diffuseTextureY","_diffuseTextureZ","_normalTextureX","_normalTextureY","_normalTextureZ","TriPlanarMaterial","REFLECTION","LOGARITHMICDEPTH","FRESNELSEPARATE","BUMPSUPERIMPOSE","BUMPAFFECTSREFLECTION","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","EXPOSURE","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","IMAGEPROCESSINGPOSTPROCESS","renderTargetSize","windForce","windDirection","waveHeight","bumpHeight","_bumpSuperimpose","_fresnelSeparate","_bumpAffectsReflection","waterColor","colorBlendFactor","waterColor2","colorBlendFactor2","waveLength","waveSpeed","disableClipPlane","_renderTargets","_mesh","_reflectionTransform","_lastDeltaTime","_createRenderTargets","getRenderTargetTextures","reset","_reflectionRTT","_refractionRTT","_imageProcessingConfiguration","imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","_markAllSubMeshesAsImageProcessingDirty","_useLogarithmicDepth","fragmentDepthSupported","_markAllSubMeshesAsMiscDirty","addToRenderList","renderList","enableRenderTargets","refreshRate","getRenderList","ReflectionTextureEnabled","_areImageProcessingDirty","prepareDefines","IS_REFLECTION_LINEAR","reflectionTexture","IS_REFRACTION_LINEAR","refractionTexture","_waitingRenderList","PrepareUniforms","PrepareSamplers","BindLogDepth","wrvp","deltaTime","applyByPostProcess","isVisible","TEXTURE_MIRROR_ADDRESSMODE","ignoreCameraViewport","savedViewMatrix","mirrorMatrix","onBeforeRender","positiony","FromPositionAndNormal","onAfterRender","ReflectionToRef","setTransformMatrix","cullBackFaces","_mirroredCameraPosition","TransformCoordinates","_bumpTexture","customRenderTargets","WaterMaterial","CreateDefaultMesh","CreateGround","createScene","canvas","temp","CreateBox","setTarget","useFramingBehavior","upperBetaLimit","ImportMeshAsync","groundMaterial","CreateGroundFromHeightMap"],"mappings":"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","file":"js/5.babylonBundle.js","sourcesContent":["export default __webpack_public_path__ + \"09099a357bd30f8395900a6a912b39dd.glb\";","export default __webpack_public_path__ + \"a31875b76d39f6458a6e5bc68acee61a.jpg\";","import * as GLTF2 from 'babylonjs-gltf2interface';\r\nimport { Tools } from '@babylonjs/core/Misc/tools';\r\n\r\ndeclare var GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction validateAsync(data: string | ArrayBuffer, rootUrl: string, fileName: string, getExternalResource: (uri: string) => Promise<ArrayBuffer>): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: (uri) => getExternalResource(uri).then((value) => new Uint8Array(value))\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = (rootUrl === \"file:\" ? fileName : rootUrl + fileName);\r\n    }\r\n\r\n    return (data instanceof ArrayBuffer)\r\n        ? GLTFValidator.validateBytes(new Uint8Array(data), options)\r\n        : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction workerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void, reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                validateAsync(data.data, data.rootUrl, data.fileName, (uri) => new Promise((resolve, reject) => {\r\n                    const index = pendingExternalResources.length;\r\n                    pendingExternalResources.push({ resolve, reject });\r\n                    postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                })).then((value) => {\r\n                    postMessage({ id: \"validate.resolve\", value: value });\r\n                }, (reason) => {\r\n                    postMessage({ id: \"validate.reject\", reason: reason });\r\n                });\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://preview.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: \"https://preview.babylonjs.com/gltf_validator.js\"\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(data: string | ArrayBuffer, rootUrl: string, fileName: string, getExternalResource: (uri: string) => Promise<ArrayBuffer>): Promise<GLTF2.IGLTFValidationResults>\r\n    {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${validateAsync}(${workerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then((value) => {\r\n                                worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value]);\r\n                            }, (reason) => {\r\n                                worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                            });\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(data.reason);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: Tools.GetAbsoluteUrl(this.Configuration.url) });\r\n                worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n            });\r\n        }\r\n        else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return validateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n","import * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { Observable, Observer } from \"@babylonjs/core/Misc/observable\";\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\r\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\r\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\r\nimport { IParticleSystem } from \"@babylonjs/core/Particles/IParticleSystem\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SceneLoader, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderPluginAsync, SceneLoaderProgressEvent, ISceneLoaderPluginExtensions } from \"@babylonjs/core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\r\nimport { Scene, IDisposable } from \"@babylonjs/core/scene\";\r\nimport { WebRequest } from \"@babylonjs/core/Misc/webRequest\";\r\nimport { IFileRequest } from \"@babylonjs/core/Misc/fileRequest\";\r\nimport { Logger } from '@babylonjs/core/Misc/logger';\r\nimport { DataReader, IDataBuffer } from '@babylonjs/core/Misc/dataReader';\r\nimport { GLTFValidation } from './glTFValidation';\r\nimport { Light } from '@babylonjs/core/Lights/light';\r\nimport { TransformNode } from '@babylonjs/core/Meshes/transformNode';\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: Object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE\r\n}\r\n\r\n/** @hidden */\r\nexport interface IImportMeshAsyncOutput {\r\n    meshes: AbstractMesh[];\r\n    particleSystems: IParticleSystem[];\r\n    skeletons: Skeleton[];\r\n    animationGroups: AnimationGroup[];\r\n    lights: Light[];\r\n    transformNodes: TransformNode[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    readonly state: Nullable<GLTFLoaderState>;\r\n    importMeshAsync: (meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<IImportMeshAsyncOutput>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @hidden */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @hidden */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: (loaderData: IGLTFLoaderData) => void) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        this._onParsedObserver = this.onParsedObservable.add(callback);\r\n    }\r\n\r\n    // ----------\r\n    // V1 options\r\n    // ----------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @hidden\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @hidden\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n    * The animation start mode. Defaults to FIRST.\r\n    */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public set onMeshLoaded(callback: (mesh: AbstractMesh) => void) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: (texture: BaseTexture) => void) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: (material: Material) => void) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: (camera: Camera) => void) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        }\r\n        else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        }\r\n        else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public name = \"gltf\";\r\n\r\n    /** @hidden */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".gltf\": { isBinary: false },\r\n        \".glb\": { isBinary: true }\r\n    };\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        this._clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _clear(): void {\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public requestFile(scene: Scene, url: string, onSuccess: (data: any, request?: WebRequest) => void, onProgress?: (ev: ProgressEvent) => void, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest {\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequests = new Array<IFileRequest>();\r\n                const aggregatedFileRequest: IFileRequest = {\r\n                    abort: () => fileRequests.forEach((fileRequest) => fileRequest.abort()),\r\n                    onCompleteObservable: new Observable<IFileRequest>()\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            fileRequests.push(scene._requestFile(url, (data, webRequest) => {\r\n                                const contentRange = webRequest!.getResponseHeader(\"Content-Range\");\r\n                                if (contentRange) {\r\n                                    dataBuffer.byteLength = Number(contentRange.split(\"/\")[1]);\r\n                                }\r\n                                resolve(new Uint8Array(data as ArrayBuffer));\r\n                            }, onProgress, true, true, (error) => {\r\n                                reject(error);\r\n                            }, (webRequest) => {\r\n                                webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                            }));\r\n                        });\r\n                    },\r\n                    byteLength: 0\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then((loaderData) => {\r\n                    aggregatedFileRequest.onCompleteObservable.notifyObservers(aggregatedFileRequest);\r\n                    onSuccess(loaderData);\r\n                }, onError);\r\n\r\n                return aggregatedFileRequest;\r\n            }\r\n\r\n            return scene._requestFile(url, (data, request) => {\r\n                const arrayBuffer = data as ArrayBuffer;\r\n                this._unpackBinaryAsync(new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength)),\r\n                    byteLength: arrayBuffer.byteLength\r\n                })).then((loaderData) => {\r\n                     onSuccess(loaderData, request);\r\n                }, onError);\r\n            }, onProgress, true, true, onError);\r\n        }\r\n\r\n        return scene._requestFile(url, (data, response) => {\r\n            this._validate(scene, data, Tools.GetFolderPath(url), Tools.GetFilename(url));\r\n            onSuccess({ json: this._parseJson(data as string) }, response);\r\n        }, onProgress, true, false, onError);\r\n    }\r\n\r\n    /** @hidden */\r\n    public readFile(scene: Scene, file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest {\r\n        return scene._readFile(file, (data) => {\r\n            this._validate(scene, data, \"file:\", file.name);\r\n            if (useArrayBuffer) {\r\n                const arrayBuffer = data as ArrayBuffer;\r\n                this._unpackBinaryAsync(new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength)),\r\n                    byteLength: arrayBuffer.byteLength\r\n                })).then(onSuccess, onError);\r\n            }\r\n            else {\r\n                onSuccess({ json: this._parseJson(data as string) });\r\n            }\r\n        }, onProgress, useArrayBuffer, onError);\r\n    }\r\n\r\n    /** @hidden */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, false, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, true, data, rootUrl, onProgress, fileName).then((result) => {\r\n                const container = new AssetContainer(scene);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public canDirectLoad(data: string): boolean {\r\n        return data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1;\r\n    }\r\n\r\n    /** @hidden */\r\n    public directLoad(scene: Scene, data: string): any {\r\n        this._validate(scene, data);\r\n        return { json: this._parseJson(data) };\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @hidden */\r\n    public createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader();\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._loader ? this._loader.state : null;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | ArrayBuffer, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => (scene._loadFileAsync(url, undefined, true, true) as Promise<ArrayBuffer>));\r\n        }).then((result) => {\r\n            this._endPerformanceCounter(\"Validate JSON\");\r\n            this.onValidatedObservable.notifyObservers(result);\r\n            this.onValidatedObservable.clear();\r\n        }, (reason) => {\r\n            this._endPerformanceCounter(\"Validate JSON\");\r\n            Tools.Warn(`Failed to validate: ${reason.message}`);\r\n            this.onValidatedObservable.clear();\r\n        });\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): Object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546C67\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new Error(\"Unexpected magic: \" + magic);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (dataReader.buffer.byteLength != 0 && length !== dataReader.buffer.byteLength) {\r\n                throw new Error(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4E4F534A,\r\n            BIN: 0x004E4942\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number, minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2])\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number, minor: number }, b: { major: number, minor: number }): number {\r\n        if (a.major > b.major) { return 1; }\r\n        if (a.major < b.major) { return -1; }\r\n        if (a.minor > b.minor) { return 1; }\r\n        if (a.minor < b.minor) { return -1; }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @hidden */\r\n    public _log = this._logDisabled;\r\n\r\n    /** @hidden */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {\r\n    }\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @hidden */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @hidden */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\r\n}\r\n","import { Bone } from \"@babylonjs/core/Bones/bone\";\r\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\n/**\r\n* Enums\r\n* @hidden\r\n*/\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126\r\n}\r\n\r\n/** @hidden */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633\r\n}\r\n\r\n/** @hidden */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678\r\n}\r\n\r\n/** @hidden */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497\r\n}\r\n\r\n/** @hidden */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987\r\n}\r\n\r\n/** @hidden */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410\r\n}\r\n\r\n/** @hidden */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032\r\n}\r\n\r\n/** @hidden */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: Object;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: Object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: Object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    forAssetContainer: boolean;\r\n}\r\n\r\n/** @hidden */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import { IGLTFRuntime, IGLTFTechniqueParameter, IGLTFAnimation, IGLTFAnimationSampler, IGLTFNode, IGLTFSkins, INodeToRoot, IJointNode, IGLTFMesh, IGLTFAccessor, IGLTFLight, IGLTFAmbienLight, IGLTFDirectionalLight, IGLTFPointLight, IGLTFSpotLight, IGLTFCamera, IGLTFCameraPerspective, IGLTFScene, IGLTFTechnique, IGLTFMaterial, EParameterType, IGLTFProgram, IGLTFBuffer, IGLTFTexture, IGLTFImage, IGLTFSampler, ETextureFilterType, IGLTFShader, IGLTFTechniqueStates, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { FloatArray, Nullable } from \"@babylonjs/core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\r\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\r\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\r\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\r\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\r\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\r\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\r\nimport { SceneLoaderProgressEvent } from \"@babylonjs/core/Loading/sceneLoader\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { GLTFFileLoader, IGLTFLoader, GLTFLoaderState, IGLTFLoaderData, IImportMeshAsyncOutput } from \"../glTFFileLoader\";\r\nimport { Constants } from '@babylonjs/core/Engines/constants';\r\n\r\n/**\r\n* Tokenizer. Used for shaders compatibility\r\n* Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n*/\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) { return ETokenType.END_OF_INPUT; }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n* Values\r\n*/\r\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n* Parse\r\n*/\r\nvar parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var buf in parsedBuffers) {\r\n        var parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nvar parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var sha in parsedShaders) {\r\n        var parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nvar parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (var object in parsedObjects) {\r\n        var parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n* Utils\r\n*/\r\nvar normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (var i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nvar getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Loads and creates animations\r\n*/\r\nvar loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (var anim in gltfRuntime.animations) {\r\n        var animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        var lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (var i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            var channel = animation.channels[i];\r\n            var sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            var inputData: Nullable<string> = null;\r\n            var outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            }\r\n            else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            var targetID = channel.target.id;\r\n            var targetNode: any = gltfRuntime.scene.getNodeByID(targetID);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetID);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetID + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            var isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            var targetPath = channel.target.path;\r\n            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            var animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                }\r\n                else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            var babylonAnimation: Nullable<Animation> = null;\r\n            var keys = [];\r\n            var arrayOffset = 0;\r\n            var modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (var j = 0; j < bufferInput.length; j++) {\r\n                var value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") { // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                }\r\n                else { // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    var bone = <Bone>targetNode;\r\n                    var translation = Vector3.Zero();\r\n                    var rotationQuaternion = new Quaternion();\r\n                    var scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    var mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    }\r\n                    else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    }\r\n                    else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value\r\n                    });\r\n                }\r\n                else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Returns the bones transformation matrix\r\n*/\r\nvar configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    var mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        var position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    }\r\n    else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n* Returns the parent bone\r\n*/\r\nvar getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (var i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    var nodes = gltfRuntime.nodes;\r\n    for (var nde in nodes) {\r\n        var node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        var children = node.children;\r\n        for (var i = 0; i < children.length; i++) {\r\n            var child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                var mat = configureBoneTransformation(node);\r\n                var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the appropriate root node\r\n*/\r\nvar getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n\r\n        for (var j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            var child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the node with the joint name\r\n*/\r\nvar getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    var nodes = gltfRuntime.nodes;\r\n    var node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName\r\n        };\r\n    }\r\n\r\n    for (var nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Checks if a nodes is in joints\r\n*/\r\nvar nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n* Fills the nodes to root for bones and builds hierarchy\r\n*/\r\nvar getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (var nde in gltfRuntime.nodes) {\r\n        var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        var id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        var mat = configureBoneTransformation(node);\r\n        var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n        var children = nodeToRoot.node.children;\r\n\r\n        for (var j = 0; j < children.length; j++) {\r\n            var child: Nullable<INodeToRoot> = null;\r\n\r\n            for (var k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Imports a skeleton\r\n*/\r\nvar importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined, id: string): Skeleton => {\r\n\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    var nodesToRoot: INodeToRoot[] = [];\r\n    var nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        var node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        var id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        var existingBone = gltfRuntime.scene.getBoneByID(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        var foundBone = false;\r\n        var parentBone: Nullable<Bone> = null;\r\n\r\n        for (var j = 0; j < i; j++) {\r\n            let jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            var joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            var children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (var k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        var mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    var bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (var j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (var i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n* Imports a mesh and its geometries\r\n*/\r\nvar importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    var vertexData: Nullable<VertexData> = null;\r\n    var verticesStarts = new Array<number>();\r\n    var verticesCounts = new Array<number>();\r\n    var indexStarts = new Array<number>();\r\n    var indexCounts = new Array<number>();\r\n\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            var tempVertexData = new VertexData();\r\n\r\n            var primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            var attributes = primitive.attributes;\r\n            var accessor: Nullable<IGLTFAccessor> = null;\r\n            var buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (var semantic in attributes) {\r\n\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                }\r\n                else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (var j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                }\r\n                else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    var channel = Number(semantic.split(\"_\")[1]);\r\n                    var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : (channel + 1));\r\n                    var uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                }\r\n                else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                }\r\n                else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                }\r\n                else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n            else {\r\n                // Set indices on the fly\r\n                var indices: number[] = [];\r\n                for (var j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            }\r\n            else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            let material = gltfRuntime.scene.getMaterialByID(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    }\r\n    else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = (subMaterials[0] as StandardMaterial);\r\n    }\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    var index = 0;\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n* Configure node transformation from position, rotation and scaling\r\n*/\r\nvar configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n* Configures node from transformation matrix\r\n*/\r\nvar configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode, parent: Nullable<Node>) => {\r\n    if (node.matrix) {\r\n        var position = new Vector3(0, 0, 0);\r\n        var rotation = new Quaternion();\r\n        var scaling = new Vector3(0, 0, 0);\r\n        var mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    }\r\n    else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n* Imports a node\r\n*/\r\nvar importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string, parent: Nullable<Node>): Nullable<Node> => {\r\n    var lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            var skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            var newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    }\r\n    else if (node.meshes) {\r\n        /**\r\n        * Improve meshes property\r\n        */\r\n        var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                var ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            }\r\n            else if (light.type === \"directional\") {\r\n                var directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            }\r\n            else if (light.type === \"point\") {\r\n                var pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            }\r\n            else if (light.type === \"spot\") {\r\n                var spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getInputElement());\r\n\r\n                lastNode = orthoCamera;\r\n            }\r\n            else if (camera.type === \"perspective\") {\r\n                var perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getInputElement());\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        }\r\n        else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node, parent);\r\n        }\r\n        else {\r\n            var translation = node.translation || [0, 0, 0];\r\n            var rotation = node.rotation || [0, 0, 0, 1];\r\n            var scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n* Traverses nodes and creates them\r\n*/\r\nvar traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    var node: IGLTFNode = gltfRuntime.nodes[id];\r\n    var newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        }\r\n        else {\r\n            meshIncluded = false;\r\n        }\r\n    }\r\n    else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id, parent);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n*/\r\nvar postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    var currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (var i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    }\r\n    else {\r\n        for (var thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        var skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n* onBind shaderrs callback to set uniforms and matrices\r\n*/\r\nvar onBindShaderMaterial = (mesh: AbstractMesh, gltfRuntime: IGLTFRuntime, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    var materialValues = material.values || technique.parameters;\r\n\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n            else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        }\r\n        else {\r\n            var value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            }\r\n            else {\r\n                GLTFUtils.SetUniform(<Effect>(shaderMaterial.getEffect()), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n* Prepare uniforms to send the only one time\r\n* Loads the appropriate textures\r\n*/\r\nvar prepareShaderMaterialUniforms = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }) => {\r\n    var materialValues = material.values || technique.parameters;\r\n    var techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n    * Prepare values here (not matrices)\r\n    */\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n        var value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        var onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Shader compilation failed\r\n*/\r\nvar onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n* Shader compilation success\r\n*/\r\nvar onShaderCompileSuccess = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n* Returns the appropriate uniform if already handled by babylon\r\n*/\r\nvar parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (var unif in technique.uniforms) {\r\n        var uniform = technique.uniforms[unif];\r\n        var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n* All shaders loaded. Create materials one by one\r\n*/\r\nvar importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (var mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, (material: Material) => { }, () => { });\r\n    }\r\n};\r\n\r\n/**\r\n* Implementation of the base glTF spec\r\n* @hidden\r\n*/\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        var gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            forAssetContainer: false\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        var buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), onProgress, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        var sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        var createMipMaps =\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR);\r\n\r\n        var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        var blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        var blobURL = URL.createObjectURL(blob);\r\n        var revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            var shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        var technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        var program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        var states: IGLTFTechniqueStates = technique.states;\r\n\r\n        var vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        var pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        var newVertexShader = \"\";\r\n        var newPixelShader = \"\";\r\n\r\n        var vertexTokenizer = new Tokenizer(vertexShader);\r\n        var pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        var unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        var uniforms: string[] = [];\r\n        var attributes: string[] = [];\r\n        var samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (var unif in technique.uniforms) {\r\n            var uniform = technique.uniforms[unif];\r\n            var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                }\r\n                else {\r\n                    uniforms.push(unif);\r\n                }\r\n            }\r\n            else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            }\r\n            else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (var attr in technique.attributes) {\r\n            var attribute = technique.attributes[attr];\r\n            var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                let name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            var tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            var foundAttribute = false;\r\n\r\n            for (var attr in technique.attributes) {\r\n                var attribute = technique.attributes[attr];\r\n                var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            var tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        var shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id\r\n        };\r\n\r\n        var options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            var functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            var blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* glTF V1 Loader\r\n* @hidden\r\n*/\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error(\"Tool with the same name \\\"\" + extension.name + \"\\\" already exists\");\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public state: Nullable<GLTFLoaderState> = null;\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, forAssetContainer: boolean, onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            gltfRuntime.forAssetContainer = forAssetContainer;\r\n            gltfRuntime.importOnlyMeshes = true;\r\n\r\n            if (meshesNames === \"\") {\r\n                gltfRuntime.importMeshesNames = [];\r\n            }\r\n            else if (typeof meshesNames === \"string\") {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else {\r\n                gltfRuntime.importMeshesNames = [];\r\n                Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n            }\r\n\r\n            // Create nodes\r\n            this._createNodes(gltfRuntime);\r\n\r\n            var meshes = new Array<AbstractMesh>();\r\n            var skeletons = new Array<Skeleton>();\r\n\r\n            // Fill arrays of meshes and skeletons\r\n            for (var nde in gltfRuntime.nodes) {\r\n                var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                if (node.babylonNode instanceof AbstractMesh) {\r\n                    meshes.push(<AbstractMesh>node.babylonNode);\r\n                }\r\n            }\r\n\r\n            for (var skl in gltfRuntime.skins) {\r\n                var skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                if (skin.babylonSkeleton instanceof Skeleton) {\r\n                    skeletons.push(skin.babylonSkeleton);\r\n                }\r\n            }\r\n\r\n            // Load buffers, shaders, materials, etc.\r\n            this._loadBuffersAsync(gltfRuntime, () => {\r\n                this._loadShadersAsync(gltfRuntime, () => {\r\n                    importMaterials(gltfRuntime);\r\n                    postLoad(gltfRuntime);\r\n\r\n                    if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                        onSuccess(meshes, skeletons);\r\n                    }\r\n                });\r\n            }, onProgress);\r\n\r\n            if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                onSuccess(meshes, skeletons);\r\n            }\r\n        }, onError);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n    * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n    * @param scene the scene the meshes should be added to\r\n    * @param forAssetContainer defines if the entities must be stored in the scene\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n    */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<IImportMeshAsyncOutput> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(meshesNames, scene, data, rootUrl, forAssetContainer, (meshes, skeletons) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: [],\r\n                    skeletons: skeletons,\r\n                    animationGroups: [],\r\n                    lights: [],\r\n                    transformNodes: []\r\n                });\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, forAssetContainer: boolean, onSuccess: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            // Load runtime extensios\r\n            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading) {\r\n                    onSuccess();\r\n                }\r\n            }, onError);\r\n        }, onError);\r\n    }\r\n\r\n    /**\r\n    * Imports all objects from a loaded gltf file and adds them to the scene\r\n    * @param scene the scene the objects should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise which completes when objects have been loaded to the scene\r\n    */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(scene, data, rootUrl, false, () => {\r\n                resolve();\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        var hasShaders = false;\r\n\r\n        var processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {\r\n                if (shaderString instanceof ArrayBuffer) {\r\n                    return;\r\n                }\r\n\r\n                gltfRuntime.loadedShaderCount++;\r\n\r\n                if (shaderString) {\r\n                    Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                }\r\n\r\n                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                    onload();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n            });\r\n        };\r\n\r\n        for (var sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            var shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void): void {\r\n        var hasBuffers = false;\r\n\r\n        var processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {\r\n                gltfRuntime.loadedBufferCount++;\r\n\r\n                if (bufferView) {\r\n                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                        Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                    }\r\n\r\n                    gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                }\r\n\r\n                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                    onLoad();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n            });\r\n        };\r\n\r\n        for (var buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            var buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        var currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n        else {\r\n            // Load all scenes\r\n            for (var thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @hidden */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading the runtime\r\n    * Return true to stop further extensions from loading the runtime\r\n    */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading buffers\r\n    * Return true to stop further extensions from loading this buffer\r\n    */\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading texture buffers\r\n    * Return true to stop further extensions from loading this texture data\r\n    */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for creating textures\r\n    * Return true to stop further extensions from loading this texture\r\n    */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading shader strings\r\n    * Return true to stop further extensions from loading this shader data\r\n    */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading materials\r\n    * Return true to stop further extensions from loading this material\r\n    */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                if (!onSuccess) {\r\n                    return;\r\n                }\r\n                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                onSuccess();\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (bufferView: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        });\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            }, onError);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (var extensionName in GLTFLoader.Extensions) {\r\n            var loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n","import { IGLTFTechniqueParameter, EParameterType, ETextureWrapMode, IGLTFAccessor, ETextureFilterType, IGLTFRuntime, IGLTFBufferView, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color4 } from '@babylonjs/core/Maths/math.color';\r\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\r\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\n/**\r\n* Utils functions for GLTF\r\n* @hidden\r\n*/\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene: the Scene object\r\n     * @param source: the source node where to pick the matrix\r\n     * @param parameter: the GLTF technique parameter\r\n     * @param uniformName: the name of the shader's uniform\r\n     * @param shaderMaterial: the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        var mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        }\r\n        else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n        else {\r\n            debugger;\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2: shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat)); break;\r\n                case EParameterType.FLOAT_MAT3: shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat)); break;\r\n                case EParameterType.FLOAT_MAT4: shaderMaterial.setMatrix(uniformName, mat); break;\r\n                default: break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial: the shader material\r\n     * @param uniform: the name of the shader's uniform\r\n     * @param value: the value of the uniform\r\n     * @param type: the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT: shaderMaterial.setFloat(uniform, value); return true;\r\n            case EParameterType.FLOAT_VEC2: shaderMaterial.setVector2(uniform, Vector2.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC3: shaderMaterial.setVector3(uniform, Vector3.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC4: shaderMaterial.setVector4(uniform, Vector4.FromArray(value)); return true;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Returns the wrap mode of the texture\r\n    * @param mode: the mode value\r\n    */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\r\n            default: return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor: the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        var type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode: the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR: return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_SAMPLINGMODE;\r\n            default: return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(gltfRuntime: IGLTFRuntime, bufferView: IGLTFBufferView, byteOffset: number, byteLength: number, componentType: EComponentType): ArrayBufferView {\r\n        var byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        var buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE: return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT: return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default: return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime: the GLTF runtime\r\n     * @param accessor: the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view: the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        var result = \"\";\r\n        var length = view.byteLength;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene: the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            var shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\"\r\n            };\r\n\r\n            var options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}","import { GLTFLoaderExtension } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, EComponentType, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { IDataBuffer } from '@babylonjs/core/Misc/dataReader';\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/** @hidden */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void, onError: (message: string) => void): boolean {\r\n        var extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        var buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        var shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            var shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());","import { GLTFLoaderExtension } from \"./glTFLoader\";\nimport { GLTFLoaderBase } from \"./glTFLoader\";\n\nimport { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\n\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\n\nimport { GLTFLoader } from \"./glTFLoader\";\n\ninterface IGLTFMaterialsCommonExtensionValues {\n    ambient?: number[] | string;\n    diffuse?: number[] | string;\n    emission?: number[] | string;\n    specular?: number[] | string;\n    shininess?: number;\n    transparency?: number;\n}\n\ninterface IGLTFMaterialsCommonExtension {\n    technique: string;\n    transparent?: number;\n    doubleSided?: boolean;\n    values: IGLTFMaterialsCommonExtensionValues;\n}\n\ninterface IGLTFRuntimeCommonExtension {\n    lights: { [key: string]: IGLTFLightCommonExtension };\n}\n\ninterface IGLTFLightCommonExtension {\n    name: string;\n    type: string;\n\n    ambient?: IGLTFAmbientLightCommonExtension;\n    point?: IGLTFPointLightCommonExtension;\n    directional?: IGLTFDirectionalLightCommonExtension;\n    spot?: IGLTFSpotLightCommonExtension;\n}\n\ninterface IGLTFPointLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\ninterface IGLTFAmbientLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFDirectionalLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFSpotLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    fallOffAngle: number;\n    fallOffExponent: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\n/** @hidden */\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\n\n    constructor() {\n        super(\"KHR_materials_common\");\n    }\n\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError: (message: string) => void): boolean {\n        if (!gltfRuntime.extensions) { return false; }\n\n        var extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\n        if (!extension) { return false; }\n\n        // Create lights\n        var lights = extension.lights;\n        if (lights) {\n            for (var thing in lights) {\n                var light: IGLTFLightCommonExtension = lights[thing];\n\n                switch (light.type) {\n                    case \"ambient\":\n                        var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n                        var ambient = light.ambient;\n                        if (ambient) {\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"point\":\n                        var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n                        var point = light.point;\n                        if (point) {\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"directional\":\n                        var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n                        var directional = light.directional;\n                        if (directional) {\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"spot\":\n                        var spot = light.spot;\n                        if (spot) {\n                            var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0),\n                                spot.fallOffAngle || Math.PI,\n                                spot.fallOffExponent || 0.0,\n                                gltfRuntime.scene);\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n                        }\n                        break;\n                    default: Tools.Warn(\"GLTF Material Common extension: light type \\\"\" + light.type + \"\\” not supported\"); break;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\n        if (!material || !material.extensions) { return false; }\n\n        var extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\n        if (!extension) { return false; }\n\n        var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n        if (extension.technique === \"CONSTANT\") {\n            standardMaterial.disableLighting = true;\n        }\n\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\n\n        // Ambient\n        if (typeof extension.values.ambient === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n        }\n        else {\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n        }\n\n        // Diffuse\n        if (typeof extension.values.diffuse === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n        }\n        else {\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n        }\n\n        // Emission\n        if (typeof extension.values.emission === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n        }\n        else {\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n        }\n\n        // Specular\n        if (typeof extension.values.specular === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n        }\n        else {\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n        }\n\n        return true;\n    }\n\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\n        // Create buffer from texture url\n        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {\n            // Create texture from buffer\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => (<any>material)[propertyPath] = texture, onError);\n        }, onError);\n    }\n}\n\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\n","import { IndicesArray, Nullable } from \"@babylonjs/core/types\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { IFileRequest } from \"@babylonjs/core/Misc/fileRequest\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager\";\nimport { SceneLoaderProgressEvent } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { IProperty, AccessorType, CameraType, AnimationChannelTargetPath, AnimationSamplerInterpolation, AccessorComponentType, MaterialAlphaMode, TextureMinFilter, TextureWrapMode, TextureMagFilter, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\nimport { _IAnimationSamplerData, IGLTF, ISampler, INode, IScene, IMesh, IAccessor, ISkin, ICamera, IAnimation, IAnimationChannel, IAnimationSampler, IBuffer, IBufferView, IMaterialPbrMetallicRoughness, IMaterial, ITextureInfo, ITexture, IImage, IMeshPrimitive, IArrayItem as IArrItem, _ISamplerData } from \"./glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\nimport { IGLTFLoader, GLTFFileLoader, GLTFLoaderState, IGLTFLoaderData, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode, IImportMeshAsyncOutput } from \"../glTFFileLoader\";\nimport { IAnimationKey, AnimationKeyInterpolation } from '@babylonjs/core/Animations/animationKey';\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\nimport { IDataBuffer } from '@babylonjs/core/Misc/dataReader';\nimport { LoadFileError } from '@babylonjs/core/Misc/fileTools';\nimport { Logger } from '@babylonjs/core/Misc/logger';\nimport { Light } from '@babylonjs/core/Lights/light';\n\ninterface TypedArrayLike extends ArrayBufferView {\n    readonly length: number;\n    [n: number]: number;\n}\n\ninterface TypedArrayConstructor {\n    new(length: number): TypedArrayLike;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayLike;\n}\n\ninterface IFileRequestInfo extends IFileRequest {\n    _lengthComputable?: boolean;\n    _loaded?: number;\n    _total?: number;\n}\n\ninterface ILoaderProperty extends IProperty {\n    _activeLoaderExtensionFunctions: {\n        [id: string]: boolean\n    };\n}\n\ninterface IRegisteredExtension {\n    factory: (loader: GLTFLoader) => IGLTFLoaderExtension;\n}\n\n/**\n * Helper class for working with arrays when loading the glTF asset\n */\nexport class ArrayItem {\n    /**\n     * Gets an item from the given array.\n     * @param context The context when loading the asset\n     * @param array The array to get the item from\n     * @param index The index to the array\n     * @returns The array item\n     */\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\n        if (!array || index == undefined || !array[index]) {\n            throw new Error(`${context}: Failed to find index (${index})`);\n        }\n\n        return array[index];\n    }\n\n    /**\n     * Assign an `index` field to each item of the given array.\n     * @param array The array of items\n     */\n    public static Assign(array?: IArrItem[]): void {\n        if (array) {\n            for (let index = 0; index < array.length; index++) {\n                array[index].index = index;\n            }\n        }\n    }\n}\n\n/**\n * The glTF 2.0 loader\n */\nexport class GLTFLoader implements IGLTFLoader {\n    /** @hidden */\n    public _completePromises = new Array<Promise<any>>();\n\n    /** @hidden */\n    public _forAssetContainer = false;\n\n    /** Storage */\n    public _babylonLights: Light[] = [];\n\n    private _disposed = false;\n    private _parent: GLTFFileLoader;\n    private _state: Nullable<GLTFLoaderState> = null;\n    private _extensions = new Array<IGLTFLoaderExtension>();\n    private _rootUrl: string;\n    private _fileName: string;\n    private _uniqueRootUrl: string;\n    private _gltf: IGLTF;\n    private _bin: Nullable<IDataBuffer>;\n    private _babylonScene: Scene;\n    private _rootBabylonMesh: Mesh;\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\n    private _progressCallback?: (event: SceneLoaderProgressEvent) => void;\n    private _requests = new Array<IFileRequestInfo>();\n\n    private static _RegisteredExtensions: { [name: string]: IRegisteredExtension } = {};\n\n    /**\n     * The default glTF sampler.\n     */\n    public static readonly DefaultSampler: ISampler = { index: -1 };\n\n    /**\n     * Registers a loader extension.\n     * @param name The name of the loader extension.\n     * @param factory The factory function that creates the loader extension.\n     */\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void {\n        if (GLTFLoader.UnregisterExtension(name)) {\n            Logger.Warn(`Extension with the name '${name}' already exists`);\n        }\n\n        GLTFLoader._RegisteredExtensions[name] = {\n            factory: factory\n        };\n    }\n\n    /**\n     * Unregisters a loader extension.\n     * @param name The name of the loader extension.\n     * @returns A boolean indicating whether the extension has been unregistered\n     */\n    public static UnregisterExtension(name: string): boolean {\n        if (!GLTFLoader._RegisteredExtensions[name]) {\n            return false;\n        }\n\n        delete GLTFLoader._RegisteredExtensions[name];\n        return true;\n    }\n\n    /**\n     * The loader state.\n     */\n    public get state(): Nullable<GLTFLoaderState> {\n        return this._state;\n    }\n\n    /**\n     * The object that represents the glTF JSON.\n     */\n    public get gltf(): IGLTF {\n        return this._gltf;\n    }\n\n    /**\n     * The BIN chunk of a binary glTF.\n     */\n    public get bin(): Nullable<IDataBuffer> {\n        return this._bin;\n    }\n\n    /**\n     * The parent file loader.\n     */\n    public get parent(): GLTFFileLoader {\n        return this._parent;\n    }\n\n    /**\n     * The Babylon scene when loading the asset.\n     */\n    public get babylonScene(): Scene {\n        return this._babylonScene;\n    }\n\n    /**\n     * The root Babylon mesh when loading the asset.\n     */\n    public get rootBabylonMesh(): Mesh {\n        return this._rootBabylonMesh;\n    }\n\n    /** @hidden */\n    constructor(parent: GLTFFileLoader) {\n        this._parent = parent;\n    }\n\n    /** @hidden */\n    public dispose(): void {\n        if (this._disposed) {\n            return;\n        }\n\n        this._disposed = true;\n\n        for (const request of this._requests) {\n            request.abort();\n        }\n\n        this._requests.length = 0;\n\n        this._completePromises.length = 0;\n\n        for (const name in this._extensions) {\n            const extension = this._extensions[name];\n            extension.dispose && extension.dispose();\n            delete this._extensions[name];\n        }\n\n        delete this._gltf;\n        delete this._babylonScene;\n        delete this._rootBabylonMesh;\n        delete this._progressCallback;\n\n        this._parent._clear();\n    }\n\n    /** @hidden */\n    public importMeshAsync(meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<IImportMeshAsyncOutput> {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._rootUrl = rootUrl;\n            this._fileName = fileName || \"scene\";\n            this._progressCallback = onProgress;\n            this._forAssetContainer = forAssetContainer;\n            this._loadData(data);\n\n            let nodes: Nullable<Array<number>> = null;\n\n            if (meshesNames) {\n                const nodeMap: { [name: string]: number } = {};\n                if (this._gltf.nodes) {\n                    for (const node of this._gltf.nodes) {\n                        if (node.name) {\n                            nodeMap[node.name] = node.index;\n                        }\n                    }\n                }\n\n                const names = (meshesNames instanceof Array) ? meshesNames : [meshesNames];\n                nodes = names.map((name) => {\n                    const node = nodeMap[name];\n                    if (node === undefined) {\n                        throw new Error(`Failed to find node '${name}'`);\n                    }\n\n                    return node;\n                });\n            }\n\n            return this._loadAsync(nodes, () => {\n                return {\n                    meshes: this._getMeshes(),\n                    particleSystems: [],\n                    skeletons: this._getSkeletons(),\n                    animationGroups: this._getAnimationGroups(),\n                    lights: this._babylonLights,\n                    transformNodes: this._getTransformNodes()\n                };\n            });\n        });\n    }\n\n    /** @hidden */\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        return Promise.resolve().then(() => {\n            this._babylonScene = scene;\n            this._rootUrl = rootUrl;\n            this._fileName = fileName || \"scene\";\n            this._progressCallback = onProgress;\n            this._loadData(data);\n            return this._loadAsync(null, () => undefined);\n        });\n    }\n\n    private _loadAsync<T>(nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\n        return Promise.resolve().then(() => {\n            this._uniqueRootUrl = (this._rootUrl.indexOf(\"file:\") === -1 && this._fileName) ? this._rootUrl : `${this._rootUrl}${Date.now()}/`;\n\n            this._loadExtensions();\n            this._checkExtensions();\n\n            const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\n            const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\n\n            this._parent._startPerformanceCounter(loadingToReadyCounterName);\n            this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n\n            this._setState(GLTFLoaderState.LOADING);\n            this._extensionsOnLoading();\n\n            const promises = new Array<Promise<any>>();\n\n            // Block the marking of materials dirty until the scene is loaded.\n            const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\n            this._babylonScene.blockMaterialDirtyMechanism = true;\n\n            if (nodes) {\n                promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\n            }\n            else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\n                const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\n                promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\n            }\n\n            // Restore the blocking of material dirty.\n            this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n\n            if (this._parent.compileMaterials) {\n                promises.push(this._compileMaterialsAsync());\n            }\n\n            if (this._parent.compileShadowGenerators) {\n                promises.push(this._compileShadowGeneratorsAsync());\n            }\n\n            const resultPromise = Promise.all(promises).then(() => {\n                if (this._rootBabylonMesh) {\n                    this._rootBabylonMesh.setEnabled(true);\n                }\n\n                this._setState(GLTFLoaderState.READY);\n                this._extensionsOnReady();\n\n                this._startAnimations();\n\n                return resultFunc();\n            });\n\n            resultPromise.then(() => {\n                this._parent._endPerformanceCounter(loadingToReadyCounterName);\n\n                Tools.SetImmediate(() => {\n                    if (!this._disposed) {\n                        Promise.all(this._completePromises).then(() => {\n                            this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n\n                            this._setState(GLTFLoaderState.COMPLETE);\n\n                            this._parent.onCompleteObservable.notifyObservers(undefined);\n                            this._parent.onCompleteObservable.clear();\n\n                            this.dispose();\n                        }, (error) => {\n                            this._parent.onErrorObservable.notifyObservers(error);\n                            this._parent.onErrorObservable.clear();\n\n                            this.dispose();\n                        });\n                    }\n                });\n            });\n\n            return resultPromise;\n        }, (error) => {\n            if (!this._disposed) {\n                this._parent.onErrorObservable.notifyObservers(error);\n                this._parent.onErrorObservable.clear();\n\n                this.dispose();\n            }\n\n            throw error;\n        });\n    }\n\n    private _loadData(data: IGLTFLoaderData): void {\n        this._gltf = data.json as IGLTF;\n        this._setupData();\n\n        if (data.bin) {\n            const buffers = this._gltf.buffers;\n            if (buffers && buffers[0] && !buffers[0].uri) {\n                const binaryBuffer = buffers[0];\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\n                }\n\n                this._bin = data.bin;\n            }\n            else {\n                Logger.Warn(\"Unexpected BIN chunk\");\n            }\n        }\n    }\n\n    private _setupData(): void {\n        ArrayItem.Assign(this._gltf.accessors);\n        ArrayItem.Assign(this._gltf.animations);\n        ArrayItem.Assign(this._gltf.buffers);\n        ArrayItem.Assign(this._gltf.bufferViews);\n        ArrayItem.Assign(this._gltf.cameras);\n        ArrayItem.Assign(this._gltf.images);\n        ArrayItem.Assign(this._gltf.materials);\n        ArrayItem.Assign(this._gltf.meshes);\n        ArrayItem.Assign(this._gltf.nodes);\n        ArrayItem.Assign(this._gltf.samplers);\n        ArrayItem.Assign(this._gltf.scenes);\n        ArrayItem.Assign(this._gltf.skins);\n        ArrayItem.Assign(this._gltf.textures);\n\n        if (this._gltf.nodes) {\n            const nodeParents: { [index: number]: number } = {};\n            for (const node of this._gltf.nodes) {\n                if (node.children) {\n                    for (const index of node.children) {\n                        nodeParents[index] = node.index;\n                    }\n                }\n            }\n\n            const rootNode = this._createRootNode();\n            for (const node of this._gltf.nodes) {\n                const parentIndex = nodeParents[node.index];\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n            }\n        }\n    }\n\n    private _loadExtensions(): void {\n        for (const name in GLTFLoader._RegisteredExtensions) {\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\n            if (extension.name !== name) {\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\n            }\n\n            this._extensions.push(extension);\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n        }\n\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\n        this._parent.onExtensionLoadedObservable.clear();\n    }\n\n    private _checkExtensions(): void {\n        if (this._gltf.extensionsRequired) {\n            for (const name of this._gltf.extensionsRequired) {\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\n                if (!available) {\n                    throw new Error(`Require extension ${name} is not available`);\n                }\n            }\n        }\n    }\n\n    private _setState(state: GLTFLoaderState): void {\n        this._state = state;\n        this.log(GLTFLoaderState[this._state]);\n    }\n\n    private _createRootNode(): INode {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        this._rootBabylonMesh.setEnabled(false);\n\n        const rootNode: INode = {\n            _babylonTransformNode: this._rootBabylonMesh,\n            index: -1\n        };\n\n        switch (this._parent.coordinateSystemMode) {\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\n                if (!this._babylonScene.useRightHandedSystem) {\n                    rootNode.rotation = [0, 1, 0, 0];\n                    rootNode.scale = [1, 1, -1];\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n                }\n                break;\n            }\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\n                this._babylonScene.useRightHandedSystem = true;\n                break;\n            }\n            default: {\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\n            }\n        }\n\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n        return rootNode;\n    }\n\n    /**\n     * Loads a glTF scene.\n     * @param context The context when loading the asset\n     * @param scene The glTF scene property\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${scene.name || \"\"}`);\n\n        if (scene.nodes) {\n            for (let index of scene.nodes) {\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\n                promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\n                    babylonMesh.parent = this._rootBabylonMesh;\n                }));\n            }\n        }\n\n        // Link all Babylon bones for each glTF node with the corresponding Babylon transform node.\n        // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n        if (this._gltf.nodes) {\n            for (const node of this._gltf.nodes) {\n                if (node._babylonTransformNode && node._babylonBones) {\n                    for (const babylonBone of node._babylonBones) {\n                        babylonBone.linkTransformNode(node._babylonTransformNode);\n                    }\n                }\n            }\n        }\n\n        promises.push(this._loadAnimationsAsync());\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\n        if (node._primitiveBabylonMeshes) {\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\n                callback(babylonMesh);\n            }\n        }\n    }\n\n    private _getMeshes(): AbstractMesh[] {\n        const meshes = new Array<AbstractMesh>();\n\n        // Root mesh is always first.\n        meshes.push(this._rootBabylonMesh);\n\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                this._forEachPrimitive(node, (babylonMesh) => {\n                    meshes.push(babylonMesh);\n                });\n            }\n        }\n\n        return meshes;\n    }\n\n    private _getTransformNodes(): TransformNode[] {\n        const transformNodes = new Array<TransformNode>();\n\n        const nodes = this._gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n                    transformNodes.push(node._babylonTransformNode);\n                }\n            }\n        }\n\n        return transformNodes;\n    }\n\n    private _getSkeletons(): Skeleton[] {\n        const skeletons = new Array<Skeleton>();\n\n        const skins = this._gltf.skins;\n        if (skins) {\n            for (const skin of skins) {\n                if (skin._data) {\n                    skeletons.push(skin._data.babylonSkeleton);\n                }\n            }\n        }\n\n        return skeletons;\n    }\n\n    private _getAnimationGroups(): AnimationGroup[] {\n        const animationGroups = new Array<AnimationGroup>();\n\n        const animations = this._gltf.animations;\n        if (animations) {\n            for (const animation of animations) {\n                if (animation._babylonAnimationGroup) {\n                    animationGroups.push(animation._babylonAnimationGroup);\n                }\n            }\n        }\n\n        return animationGroups;\n    }\n\n    private _startAnimations(): void {\n        switch (this._parent.animationStartMode) {\n            case GLTFLoaderAnimationStartMode.NONE: {\n                // do nothing\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.FIRST: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                if (babylonAnimationGroups.length !== 0) {\n                    babylonAnimationGroups[0].start(true);\n                }\n                break;\n            }\n            case GLTFLoaderAnimationStartMode.ALL: {\n                const babylonAnimationGroups = this._getAnimationGroups();\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\n                    babylonAnimationGroup.start(true);\n                }\n                break;\n            }\n            default: {\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Loads a glTF node.\n     * @param context The context when loading the asset\n     * @param node The glTF node property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\n     */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => { }): Promise<TransformNode> {\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (node._babylonTransformNode) {\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${node.name || \"\"}`);\n\n        const loadNode = (babylonTransformNode: TransformNode) => {\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\n\n            if (node.camera != undefined) {\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\n                promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\n                    babylonCamera.parent = babylonTransformNode;\n                }));\n            }\n\n            if (node.children) {\n                for (const index of node.children) {\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\n                    promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\n                        childBabylonMesh.parent = babylonTransformNode;\n                    }));\n                }\n            }\n\n            assign(babylonTransformNode);\n        };\n\n        if (node.mesh == undefined) {\n            const nodeName = node.name || `node${node.index}`;\n            this._babylonScene._blockEntityCollection = this._forAssetContainer;\n            node._babylonTransformNode = new TransformNode(nodeName, this._babylonScene);\n            this._babylonScene._blockEntityCollection = false;\n            loadNode(node._babylonTransformNode);\n        }\n        else {\n            const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n            promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\n        }\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => {\n            this._forEachPrimitive(node, (babylonMesh) => {\n                babylonMesh.refreshBoundingInfo(true);\n            });\n\n            return node._babylonTransformNode!;\n        });\n    }\n\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\n        const primitives = mesh.primitives;\n        if (!primitives || !primitives.length) {\n            throw new Error(`${context}: Primitives are missing`);\n        }\n\n        if (primitives[0].index == undefined) {\n            ArrayItem.Assign(primitives);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\n\n        const name = node.name || `node${node.index}`;\n\n        if (primitives.length === 1) {\n            const primitive = mesh.primitives[0];\n            promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\n                node._babylonTransformNode = babylonMesh;\n                node._primitiveBabylonMeshes = [babylonMesh];\n            }));\n        }\n        else {\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n            node._primitiveBabylonMeshes = [];\n            for (const primitive of primitives) {\n                promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\n                    babylonMesh.parent = node._babylonTransformNode!;\n                    node._primitiveBabylonMeshes!.push(babylonMesh);\n                }));\n            }\n        }\n\n        if (node.skin != undefined) {\n            const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\n            promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin));\n        }\n\n        assign(node._babylonTransformNode!);\n\n        this.logClose();\n\n        return Promise.all(promises).then(() => {\n            return node._babylonTransformNode!;\n        });\n    }\n\n    /**\n     * @hidden Define this method to modify the default behavior when loading data for mesh primitives.\n     * @param context The context when loading the asset\n     * @param name The mesh name when loading the asset\n     * @param node The glTF node when loading the asset\n     * @param mesh The glTF mesh when loading the asset\n     * @param primitive The glTF mesh primitive property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\n     */\n    public _loadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: AbstractMesh) => void): Promise<AbstractMesh> {\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context}`);\n\n        const shouldInstance = this._parent.createInstances && (node.skin == undefined && !mesh.primitives[0].targets);\n\n        let babylonAbstractMesh: AbstractMesh;\n        let promise: Promise<any>;\n\n        if (shouldInstance && primitive._instanceData) {\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name) as InstancedMesh;\n            promise = primitive._instanceData.promise;\n        }\n        else {\n            const promises = new Array<Promise<any>>();\n\n            this._babylonScene._blockEntityCollection = this._forAssetContainer;\n            const babylonMesh = new Mesh(name, this._babylonScene);\n            this._babylonScene._blockEntityCollection = false;\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\n            promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\n                return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\n                    babylonGeometry.applyToMesh(babylonMesh);\n                });\n            }));\n\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n            if (primitive.material == undefined) {\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n                if (!babylonMaterial) {\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n                }\n                babylonMesh.material = babylonMaterial;\n            }\n            else {\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\n                promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    babylonMesh.material = babylonMaterial;\n                }));\n            }\n\n            promise = Promise.all(promises);\n\n            if (shouldInstance) {\n                primitive._instanceData = {\n                    babylonSourceMesh: babylonMesh,\n                    promise: promise\n                };\n            }\n\n            babylonAbstractMesh = babylonMesh;\n        }\n\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n        assign(babylonAbstractMesh);\n\n        this.logClose();\n\n        return promise.then(() => {\n            return babylonAbstractMesh;\n        });\n    }\n\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const attributes = primitive.attributes;\n        if (!attributes) {\n            throw new Error(`${context}: Attributes are missing`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n\n        if (primitive.indices == undefined) {\n            babylonMesh.isUnIndexed = true;\n        }\n        else {\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\n            promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                babylonGeometry.setIndices(data);\n            }));\n        }\n\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessor) => void) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                babylonMesh._delayInfo.push(kind);\n            }\n\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\n                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n            }));\n\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n                babylonMesh.numBoneInfluencers = 8;\n            }\n\n            if (callback) {\n                callback(accessor);\n            }\n        };\n\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\n            if (accessor.type === AccessorType.VEC4) {\n                babylonMesh.hasVertexAlpha = true;\n            }\n        });\n\n        return Promise.all(promises).then(() => {\n            return babylonGeometry;\n        });\n    }\n\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\n        if (!primitive.targets) {\n            return;\n        }\n\n        if (node._numMorphTargets == undefined) {\n            node._numMorphTargets = primitive.targets.length;\n        }\n        else if (primitive.targets.length !== node._numMorphTargets) {\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\n        }\n\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\n\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n        for (let index = 0; index < primitive.targets.length; index++) {\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\n            // TODO: tell the target whether it has positions, normals, tangents\n        }\n    }\n\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\n        if (!primitive.targets) {\n            return Promise.resolve();\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        const morphTargetManager = babylonMesh.morphTargetManager!;\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\n        const promises = new Array<Promise<any>>();\n\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\n            if (attributes[attribute] == undefined) {\n                return;\n            }\n\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n            if (!babylonVertexBuffer) {\n                return;\n            }\n\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\n            promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                setData(babylonVertexBuffer, data);\n            }));\n        };\n\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\n            const positions = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\n                positions[index] = data[index] + value;\n            });\n\n            babylonMorphTarget.setPositions(positions);\n        });\n\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\n            const normals = new Float32Array(data.length);\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\n                normals[index] = data[index] + value;\n            });\n\n            babylonMorphTarget.setNormals(normals);\n        });\n\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\n            const tangents = new Float32Array(data.length / 3 * 4);\n            let dataIndex = 0;\n            babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {\n                // Tangent data for morph targets is stored as xyz delta.\n                // The vertexData.tangent is stored as xyzw.\n                // So we need to skip every fourth vertexData.tangent.\n                if (((index + 1) % 4) !== 0) {\n                    tangents[dataIndex] = data[dataIndex] + value;\n                    dataIndex++;\n                }\n            });\n            babylonMorphTarget.setTangents(tangents);\n        });\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\n        // Ignore the TRS of skinned nodes.\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        if (node.skin != undefined) {\n            return;\n        }\n\n        let position = Vector3.Zero();\n        let rotation = Quaternion.Identity();\n        let scaling = Vector3.One();\n\n        if (node.matrix) {\n            const matrix = Matrix.FromArray(node.matrix);\n            matrix.decompose(scaling, rotation, position);\n        }\n        else {\n            if (node.translation) { position = Vector3.FromArray(node.translation); }\n            if (node.rotation) { rotation = Quaternion.FromArray(node.rotation); }\n            if (node.scale) { scaling = Vector3.FromArray(node.scale); }\n        }\n\n        babylonNode.position = position;\n        babylonNode.rotationQuaternion = rotation;\n        babylonNode.scaling = scaling;\n    }\n\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin): Promise<void> {\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const assignSkeleton = (skeleton: Skeleton) => {\n            this._forEachPrimitive(node, (babylonMesh) => {\n                babylonMesh.skeleton = skeleton;\n            });\n        };\n\n        if (skin._data) {\n            assignSkeleton(skin._data.babylonSkeleton);\n            return skin._data.promise;\n        }\n\n        const skeletonId = `skeleton${skin.index}`;\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        babylonSkeleton.overrideMesh = this._rootBabylonMesh;\n\n        this._loadBones(context, skin, babylonSkeleton);\n        assignSkeleton(babylonSkeleton);\n\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n        });\n\n        skin._data = {\n            babylonSkeleton: babylonSkeleton,\n            promise: promise\n        };\n\n        return promise;\n    }\n\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\n        const babylonBones: { [index: number]: Bone } = {};\n        for (const index of skin.joints) {\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\n        }\n    }\n\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\n        let babylonBone = babylonBones[node.index];\n        if (babylonBone) {\n            return babylonBone;\n        }\n\n        let babylonParentBone: Nullable<Bone> = null;\n        if (node.parent && node.parent._babylonTransformNode !== this._rootBabylonMesh) {\n            babylonParentBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n        }\n\n        const boneIndex = skin.joints.indexOf(node.index);\n\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);\n        babylonBones[node.index] = babylonBone;\n\n        node._babylonBones = node._babylonBones || [];\n        node._babylonBones.push(babylonBone);\n\n        return babylonBone;\n    }\n\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\n        if (skin.inverseBindMatrices == undefined) {\n            return Promise.resolve(null);\n        }\n\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\n    }\n\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\n        for (const babylonBone of babylonSkeleton.bones) {\n            let baseMatrix = Matrix.Identity();\n            const boneIndex = babylonBone._index!;\n            if (inverseBindMatricesData && boneIndex !== -1) {\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n                baseMatrix.invertToRef(baseMatrix);\n            }\n\n            const babylonParentBone = babylonBone.getParent();\n            if (babylonParentBone) {\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n            }\n\n            babylonBone.updateMatrix(baseMatrix, false, false);\n            babylonBone._updateDifferenceMatrix(undefined, false);\n        }\n    }\n\n    private _getNodeMatrix(node: INode): Matrix {\n        return node.matrix ?\n            Matrix.FromArray(node.matrix) :\n            Matrix.Compose(\n                node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\n                node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\n                node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n    }\n\n    /**\n     * Loads a glTF camera.\n     * @param context The context when loading the asset\n     * @param camera The glTF camera property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\n     */\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => { }): Promise<Camera> {\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        this.logOpen(`${context} ${camera.name || \"\"}`);\n\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\n        this._babylonScene._blockEntityCollection = false;\n\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n\n        switch (camera.type) {\n            case CameraType.PERSPECTIVE: {\n                const perspective = camera.perspective;\n                if (!perspective) {\n                    throw new Error(`${context}: Camera perspective properties are missing`);\n                }\n\n                babylonCamera.fov = perspective.yfov;\n                babylonCamera.minZ = perspective.znear;\n                babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;\n                break;\n            }\n            case CameraType.ORTHOGRAPHIC: {\n                if (!camera.orthographic) {\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\n                }\n\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\n                babylonCamera.orthoRight = camera.orthographic.xmag;\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\n                babylonCamera.orthoTop = camera.orthographic.ymag;\n                babylonCamera.minZ = camera.orthographic.znear;\n                babylonCamera.maxZ = camera.orthographic.zfar;\n                break;\n            }\n            default: {\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\n            }\n        }\n\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n        assign(babylonCamera);\n\n        return Promise.all(promises).then(() => {\n            return babylonCamera;\n        });\n    }\n\n    private _loadAnimationsAsync(): Promise<void> {\n        const animations = this._gltf.animations;\n        if (!animations) {\n            return Promise.resolve();\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads a glTF animation.\n     * @param context The context when loading the asset\n     * @param animation The glTF animation property\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\n     */\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\n        if (promise) {\n            return promise;\n        }\n\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        animation._babylonAnimationGroup = babylonAnimationGroup;\n\n        const promises = new Array<Promise<any>>();\n\n        ArrayItem.Assign(animation.channels);\n        ArrayItem.Assign(animation.samplers);\n\n        for (const channel of animation.channels) {\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, babylonAnimationGroup));\n        }\n\n        return Promise.all(promises).then(() => {\n            babylonAnimationGroup.normalize(0);\n            return babylonAnimationGroup;\n        });\n    }\n\n    /**\n     * @hidden Loads a glTF animation channel.\n     * @param context The context when loading the asset\n     * @param animationContext The context of the animation when loading the asset\n     * @param animation The glTF animation property\n     * @param channel The glTF animation channel property\n     * @param babylonAnimationGroup The babylon animation group property\n     * @param animationTargetOverride The babylon animation channel target override property. My be null.\n     * @returns A void promise when the channel load is complete\n     */\n    public _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, babylonAnimationGroup: AnimationGroup, animationTargetOverride: Nullable<IAnimatable> = null): Promise<void> {\n        if (channel.target.node == undefined) {\n            return Promise.resolve();\n        }\n\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\n\n        // Ignore animations that have no animation targets.\n        if ((channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonTransformNode)) {\n            return Promise.resolve();\n        }\n\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\n            let targetPath: string;\n            let animationType: number;\n            switch (channel.target.path) {\n                case AnimationChannelTargetPath.TRANSLATION: {\n                    targetPath = \"position\";\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\n                    break;\n                }\n                case AnimationChannelTargetPath.ROTATION: {\n                    targetPath = \"rotationQuaternion\";\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\n                    break;\n                }\n                case AnimationChannelTargetPath.SCALE: {\n                    targetPath = \"scaling\";\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\n                    break;\n                }\n                case AnimationChannelTargetPath.WEIGHTS: {\n                    targetPath = \"influence\";\n                    animationType = Animation.ANIMATIONTYPE_FLOAT;\n                    break;\n                }\n                default: {\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\n                }\n            }\n\n            let outputBufferOffset = 0;\n            let getNextOutputValue: () => Vector3 | Quaternion | Array<number>;\n            switch (targetPath) {\n                case \"position\": {\n                    getNextOutputValue = () => {\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 3;\n                        return value;\n                    };\n                    break;\n                }\n                case \"rotationQuaternion\": {\n                    getNextOutputValue = () => {\n                        const value = Quaternion.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 4;\n                        return value;\n                    };\n                    break;\n                }\n                case \"scaling\": {\n                    getNextOutputValue = () => {\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\n                        outputBufferOffset += 3;\n                        return value;\n                    };\n                    break;\n                }\n                case \"influence\": {\n                    getNextOutputValue = () => {\n                        const value = new Array<number>(targetNode._numMorphTargets!);\n                        for (let i = 0; i < targetNode._numMorphTargets!; i++) {\n                            value[i] = data.output[outputBufferOffset++];\n                        }\n                        return value;\n                    };\n                    break;\n                }\n            }\n\n            let getNextKey: (frameIndex: number) => IAnimationKey;\n            switch (data.interpolation) {\n                case AnimationSamplerInterpolation.STEP: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        value: getNextOutputValue(),\n                        interpolation: AnimationKeyInterpolation.STEP\n                    });\n                    break;\n                }\n                case AnimationSamplerInterpolation.LINEAR: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        value: getNextOutputValue()\n                    });\n                    break;\n                }\n                case AnimationSamplerInterpolation.CUBICSPLINE: {\n                    getNextKey = (frameIndex) => ({\n                        frame: data.input[frameIndex],\n                        inTangent: getNextOutputValue(),\n                        value: getNextOutputValue(),\n                        outTangent: getNextOutputValue()\n                    });\n                    break;\n                }\n            }\n\n            const keys = new Array(data.input.length);\n            for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\n                keys[frameIndex] = getNextKey!(frameIndex);\n            }\n\n            if (targetPath === \"influence\") {\n                for (let targetIndex = 0; targetIndex < targetNode._numMorphTargets!; targetIndex++) {\n                    const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\n                    const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n                    babylonAnimation.setKeys(keys.map((key) => ({\n                        frame: key.frame,\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n                        value: key.value[targetIndex],\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\n                    })));\n\n                    this._forEachPrimitive(targetNode, (babylonAbstractMesh: AbstractMesh) => {\n                        const babylonMesh = babylonAbstractMesh as Mesh;\n                        const morphTarget = babylonMesh.morphTargetManager!.getTarget(targetIndex);\n                        const babylonAnimationClone = babylonAnimation.clone();\n                        morphTarget.animations.push(babylonAnimationClone);\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\n                    });\n                }\n            }\n            else {\n                const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\n                const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\n                babylonAnimation.setKeys(keys);\n\n                if (animationTargetOverride != null && animationTargetOverride.animations != null) {\n                    animationTargetOverride.animations.push(babylonAnimation);\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);\n                } else {\n                    targetNode._babylonTransformNode!.animations.push(babylonAnimation);\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonTransformNode!);\n                }\n            }\n        });\n    }\n\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\n        if (sampler._data) {\n            return sampler._data;\n        }\n\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\n        switch (interpolation) {\n            case AnimationSamplerInterpolation.STEP:\n            case AnimationSamplerInterpolation.LINEAR:\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\n                break;\n            }\n            default: {\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\n            }\n        }\n\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\n        sampler._data = Promise.all([\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor)\n        ]).then(([inputData, outputData]) => {\n            return {\n                input: inputData,\n                interpolation: interpolation,\n                output: outputData,\n            };\n        });\n\n        return sampler._data;\n    }\n\n    private _loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (!buffer._data) {\n            if (buffer.uri) {\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\n            }\n            else {\n                if (!this._bin) {\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n                }\n\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\n            }\n        }\n\n        return buffer._data.then((data) => {\n            try {\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n            }\n            catch (e) {\n                throw new Error(`${context}: ${e.message}`);\n            }\n        });\n    }\n\n    /**\n     * Loads a glTF buffer view.\n     * @param context The context when loading the asset\n     * @param bufferView The glTF buffer view property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (bufferView._data) {\n            return bufferView._data;\n        }\n\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\n        bufferView._data = this._loadBufferAsync(`/buffers/${buffer.index}`, buffer, (bufferView.byteOffset || 0), bufferView.byteLength);\n\n        return bufferView._data;\n    }\n\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\n        if (accessor._data) {\n            return accessor._data;\n        }\n\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n        const length = numComponents * accessor.count;\n\n        if (accessor.bufferView == undefined) {\n            accessor._data = Promise.resolve(new constructor(length));\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n                }\n                else {\n                    const typedArray = new constructor(length);\n                    VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {\n                        typedArray[index] = value;\n                    });\n                    return typedArray;\n                }\n            });\n        }\n\n        if (accessor.sparse) {\n            const sparse = accessor.sparse;\n            accessor._data = accessor._data.then((data) => {\n                const typedArray = data as TypedArrayLike;\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\n                return Promise.all([\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView)\n                ]).then(([indicesData, valuesData]) => {\n                    const indices = GLTFLoader._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count) as IndicesArray;\n\n                    const sparseLength = numComponents * sparse.count;\n                    let values: TypedArrayLike;\n\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                    }\n                    else {\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n                        values = new constructor(sparseLength);\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\n                            values[index] = value;\n                        });\n                    }\n\n                    let valuesIndex = 0;\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n                        let dataIndex = indices[indicesIndex] * numComponents;\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n                            typedArray[dataIndex++] = values[valuesIndex++];\n                        }\n                    }\n\n                    return typedArray;\n                });\n            });\n        }\n\n        return accessor._data;\n    }\n\n    private _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\n    }\n\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\n        if (accessor.type !== AccessorType.SCALAR) {\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\n        }\n\n        if (accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT) {\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\n        }\n\n        if (accessor._data) {\n            return accessor._data as Promise<IndicesArray>;\n        }\n\n        if (accessor.sparse) {\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n            });\n        }\n\n        return accessor._data as Promise<IndicesArray>;\n    }\n\n    private _loadVertexBufferViewAsync(bufferView: IBufferView, kind: string): Promise<Buffer> {\n        if (bufferView._babylonBuffer) {\n            return bufferView._babylonBuffer;\n        }\n\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\n            return new Buffer(this._babylonScene.getEngine(), data, false);\n        });\n\n        return bufferView._babylonBuffer;\n    }\n\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\n        if (accessor._babylonVertexBuffer) {\n            return accessor._babylonVertexBuffer;\n        }\n\n        if (accessor.sparse) {\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        // HACK: If byte offset is not a multiple of component type byte length then load as a float array instead of using Babylon buffers.\n        else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {\n            Logger.Warn(\"Accessor byte offset is not a multiple of component type byte length\");\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\n                return new VertexBuffer(this._babylonScene.getEngine(), data, kind, false);\n            });\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n            accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView, kind).then((babylonBuffer) => {\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\n                return new VertexBuffer(this._babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView.byteStride,\n                    false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true);\n            });\n        }\n\n        return accessor._babylonVertexBuffer;\n    }\n\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        if (properties) {\n            if (properties.baseColorFactor) {\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n                babylonMaterial.alpha = properties.baseColorFactor[3];\n            }\n            else {\n                babylonMaterial.albedoColor = Color3.White();\n            }\n\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n\n            if (properties.baseColorTexture) {\n                promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Base Color)`;\n                    babylonMaterial.albedoTexture = texture;\n                }));\n            }\n\n            if (properties.metallicRoughnessTexture) {\n                promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\n                    texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\n                    babylonMaterial.metallicTexture = texture;\n                }));\n\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n            }\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /** @hidden */\n    public _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void = () => { }): Promise<Material> {\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        material._data = material._data || {};\n        let babylonData = material._data[babylonDrawMode];\n        if (!babylonData) {\n            this.logOpen(`${context} ${material.name || \"\"}`);\n\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n\n            babylonData = {\n                babylonMaterial: babylonMaterial,\n                babylonMeshes: [],\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\n            };\n\n            material._data[babylonDrawMode] = babylonData;\n\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n\n            this.logClose();\n        }\n\n        babylonData.babylonMeshes.push(babylonMesh);\n\n        babylonMesh.onDisposeObservable.addOnce(() => {\n            const index = babylonData.babylonMeshes.indexOf(babylonMesh);\n            if (index !== -1) {\n                babylonData.babylonMeshes.splice(index, 1);\n            }\n        });\n\n        assign(babylonData.babylonMaterial);\n\n        return babylonData.promise.then(() => {\n            return babylonData.babylonMaterial;\n        });\n    }\n\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\n        this._babylonScene._blockEntityCollection = false;\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        babylonMaterial.fillMode = babylonDrawMode;\n        babylonMaterial.enableSpecularAntiAliasing = true;\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n        babylonMaterial.metallic = 1;\n        babylonMaterial.roughness = 1;\n        return babylonMaterial;\n    }\n\n    /**\n     * Creates a Babylon material from a glTF material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonDrawMode The draw mode for the Babylon material\n     * @returns The Babylon material\n     */\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const name = material.name || `material${material.index}`;\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n\n        return babylonMaterial;\n    }\n\n    /**\n     * Loads properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n\n        if (material.pbrMetallicRoughness) {\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\n        }\n\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     * @returns A promise that resolves when the load is complete\n     */\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n        if (material.doubleSided) {\n            babylonMaterial.backFaceCulling = false;\n            babylonMaterial.twoSidedLighting = true;\n        }\n\n        if (material.normalTexture) {\n            promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Normal)`;\n                babylonMaterial.bumpTexture = texture;\n            }));\n\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n            if (material.normalTexture.scale != undefined) {\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n            }\n\n            babylonMaterial.forceIrradianceInFragment = true;\n        }\n\n        if (material.occlusionTexture) {\n            promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Occlusion)`;\n                babylonMaterial.ambientTexture = texture;\n            }));\n\n            babylonMaterial.useAmbientInGrayScale = true;\n            if (material.occlusionTexture.strength != undefined) {\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n            }\n        }\n\n        if (material.emissiveTexture) {\n            promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Emissive)`;\n                babylonMaterial.emissiveTexture = texture;\n            }));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n\n    /**\n     * Loads the alpha properties from a glTF material into a Babylon material.\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\n     * @param context The context when loading the asset\n     * @param material The glTF material property\n     * @param babylonMaterial The Babylon material\n     */\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\n        switch (alphaMode) {\n            case MaterialAlphaMode.OPAQUE: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n                break;\n            }\n            case MaterialAlphaMode.MASK: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n                babylonMaterial.alphaCutOff = (material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff);\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                }\n                break;\n            }\n            case MaterialAlphaMode.BLEND: {\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n                if (babylonMaterial.albedoTexture) {\n                    babylonMaterial.albedoTexture.hasAlpha = true;\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\n                }\n                break;\n            }\n            default: {\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\n            }\n        }\n    }\n\n    /**\n     * Loads a glTF texture info.\n     * @param context The context when loading the asset\n     * @param textureInfo The glTF texture info property\n     * @param assign A function called synchronously after parsing the glTF properties\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\n     */\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context}`);\n\n        if (textureInfo.texCoord! >= 2) {\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\n        }\n\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n            assign(babylonTexture);\n        });\n\n        this.logClose();\n\n        return promise;\n    }\n\n    /** @hidden */\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        this.logOpen(`${context} ${texture.name || \"\"}`);\n\n        const sampler = (texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler));\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\n        const promise = this._createTextureAsync(context, sampler, image, assign);\n\n        this.logClose();\n\n        return promise;\n    }\n\n    /** @hidden */\n    public _createTextureAsync(context: string, sampler: ISampler, image: IImage, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\n\n        const promises = new Array<Promise<any>>();\n\n        const deferred = new Deferred<void>();\n        this._babylonScene._blockEntityCollection = this._forAssetContainer;\n        const babylonTexture = new Texture(null, this._babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, () => {\n            if (!this._disposed) {\n                deferred.resolve();\n            }\n        }, (message, exception) => {\n            if (!this._disposed) {\n                deferred.reject(new Error(`${context}: ${(exception && exception.message) ? exception.message : message || \"Failed to load texture\"}`));\n            }\n        }, undefined, undefined, undefined, image.mimeType);\n        this._babylonScene._blockEntityCollection = false;\n        promises.push(deferred.promise);\n\n        promises.push(this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\n            const name = image.uri || `${this._fileName}#image${image.index}`;\n            const dataUrl = `data:${this._uniqueRootUrl}${name}`;\n            babylonTexture.updateURL(dataUrl, data);\n        }));\n\n        babylonTexture.wrapU = samplerData.wrapU;\n        babylonTexture.wrapV = samplerData.wrapV;\n        assign(babylonTexture);\n\n        return Promise.all(promises).then(() => {\n            return babylonTexture;\n        });\n    }\n\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\n        if (!sampler._data) {\n            sampler._data = {\n                noMipMaps: (sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR),\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)\n            };\n        }\n\n        return sampler._data;\n    }\n\n    /**\n     * Loads a glTF image.\n     * @param context The context when loading the asset\n     * @param image The glTF image property\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\n        if (!image._data) {\n            this.logOpen(`${context} ${image.name || \"\"}`);\n\n            if (image.uri) {\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\n            }\n            else {\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n            }\n\n            this.logClose();\n        }\n\n        return image._data;\n    }\n\n    /**\n     * Loads a glTF uri.\n     * @param context The context when loading the asset\n     * @param property The glTF property associated with the uri\n     * @param uri The base64 or relative uri\n     * @returns A promise that resolves with the loaded data when the load is complete\n     */\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n        if (extensionPromise) {\n            return extensionPromise;\n        }\n\n        if (!GLTFLoader._ValidateUri(uri)) {\n            throw new Error(`${context}: '${uri}' is invalid`);\n        }\n\n        if (Tools.IsBase64(uri)) {\n            const data = new Uint8Array(Tools.DecodeBase64(uri));\n            this.log(`Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\n            return Promise.resolve(data);\n        }\n\n        this.log(`Loading ${uri}`);\n\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\n            return new Promise<ArrayBufferView>((resolve, reject) => {\n                if (!this._disposed) {\n                    const request = Tools.LoadFile(url, (fileData) => {\n                        if (!this._disposed) {\n                            const data = new Uint8Array(fileData as ArrayBuffer);\n                            this.log(`Loaded ${uri} (${data.length} bytes)`);\n                            resolve(data);\n                        }\n                    }, (event) => {\n                        if (!this._disposed) {\n                            if (request) {\n                                request._lengthComputable = event.lengthComputable;\n                                request._loaded = event.loaded;\n                                request._total = event.total;\n                            }\n\n                            if (this._state === GLTFLoaderState.LOADING) {\n                                try {\n                                    this._onProgress();\n                                }\n                                catch (e) {\n                                    reject(e);\n                                }\n                            }\n                        }\n                    }, this._babylonScene.offlineProvider, true, (request, exception) => {\n                        if (!this._disposed) {\n                            reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\n                        }\n                    }) as IFileRequestInfo;\n\n                    this._requests.push(request);\n                }\n            });\n        });\n    }\n\n    private _onProgress(): void {\n        if (!this._progressCallback) {\n            return;\n        }\n\n        let lengthComputable = true;\n        let loaded = 0;\n        let total = 0;\n        for (let request of this._requests) {\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\n                return;\n            }\n\n            lengthComputable = lengthComputable && request._lengthComputable;\n            loaded += request._loaded;\n            total += request._total;\n        }\n\n        this._progressCallback(new SceneLoaderProgressEvent(lengthComputable, loaded, lengthComputable ? total : 0));\n    }\n\n    /**\n     * Adds a JSON pointer to the metadata of the Babylon object at `<object>.metadata.gltf.pointers`.\n     * @param babylonObject the Babylon object with metadata\n     * @param pointer the JSON pointer\n     */\n    public static AddPointerMetadata(babylonObject: { metadata: any }, pointer: string): void {\n        const metadata = (babylonObject.metadata = babylonObject.metadata || {});\n        const gltf = (metadata.gltf = metadata.gltf || {});\n        const pointers = (gltf.pointers = gltf.pointers || []);\n        pointers.push(pointer);\n    }\n\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\n        // Set defaults if undefined\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\n\n        switch (mode) {\n            case TextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\n            case TextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\n            case TextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\n            default:\n                Logger.Warn(`${context}: Invalid value (${mode})`);\n                return Texture.WRAP_ADDRESSMODE;\n        }\n    }\n\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\n        // Set defaults if undefined\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\n\n        if (magFilter === TextureMagFilter.LINEAR) {\n            switch (minFilter) {\n                case TextureMinFilter.NEAREST: return Texture.LINEAR_NEAREST;\n                case TextureMinFilter.LINEAR: return Texture.LINEAR_LINEAR;\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.LINEAR_NEAREST_MIPNEAREST;\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.LINEAR_LINEAR_MIPNEAREST;\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.LINEAR_NEAREST_MIPLINEAR;\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.LINEAR_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\n            }\n        }\n        else {\n            if (magFilter !== TextureMagFilter.NEAREST) {\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\n            }\n\n            switch (minFilter) {\n                case TextureMinFilter.NEAREST: return Texture.NEAREST_NEAREST;\n                case TextureMinFilter.LINEAR: return Texture.NEAREST_LINEAR;\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_NEAREST_MIPNEAREST;\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.NEAREST_LINEAR_MIPNEAREST;\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.NEAREST_NEAREST_MIPLINEAR;\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.NEAREST_LINEAR_MIPLINEAR;\n                default:\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\n            }\n        }\n    }\n\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\n        switch (componentType) {\n            case AccessorComponentType.BYTE: return Int8Array;\n            case AccessorComponentType.UNSIGNED_BYTE: return Uint8Array;\n            case AccessorComponentType.SHORT: return Int16Array;\n            case AccessorComponentType.UNSIGNED_SHORT: return Uint16Array;\n            case AccessorComponentType.UNSIGNED_INT: return Uint32Array;\n            case AccessorComponentType.FLOAT: return Float32Array;\n            default: throw new Error(`${context}: Invalid component type ${componentType}`);\n        }\n}\n\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): TypedArrayLike {\n        const buffer = bufferView.buffer;\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\n\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\n\n        try {\n            return new constructor(buffer, byteOffset, length);\n        }\n        catch (e) {\n            throw new Error(`${context}: ${e}`);\n        }\n    }\n\n    private static _GetNumComponents(context: string, type: string): number {\n        switch (type) {\n            case \"SCALAR\": return 1;\n            case \"VEC2\": return 2;\n            case \"VEC3\": return 3;\n            case \"VEC4\": return 4;\n            case \"MAT2\": return 4;\n            case \"MAT3\": return 9;\n            case \"MAT4\": return 16;\n        }\n\n        throw new Error(`${context}: Invalid type (${type})`);\n    }\n\n    private static _ValidateUri(uri: string): boolean {\n        return (Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1);\n    }\n\n    private static _GetDrawMode(context: string, mode: number | undefined): number {\n        if (mode == undefined) {\n            mode = MeshPrimitiveMode.TRIANGLES;\n        }\n\n        switch (mode) {\n            case MeshPrimitiveMode.POINTS: return Material.PointListDrawMode;\n            case MeshPrimitiveMode.LINES: return Material.LineListDrawMode;\n            case MeshPrimitiveMode.LINE_LOOP: return Material.LineLoopDrawMode;\n            case MeshPrimitiveMode.LINE_STRIP: return Material.LineStripDrawMode;\n            case MeshPrimitiveMode.TRIANGLES: return Material.TriangleFillMode;\n            case MeshPrimitiveMode.TRIANGLE_STRIP: return Material.TriangleStripDrawMode;\n            case MeshPrimitiveMode.TRIANGLE_FAN: return Material.TriangleFanDrawMode;\n        }\n\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\n    }\n\n    private _compileMaterialsAsync(): Promise<void> {\n        this._parent._startPerformanceCounter(\"Compile materials\");\n\n        const promises = new Array<Promise<any>>();\n\n        if (this._gltf.materials) {\n            for (const material of this._gltf.materials) {\n                if (material._data) {\n                    for (const babylonDrawMode in material._data) {\n                        const babylonData = material._data[babylonDrawMode];\n                        for (const babylonMesh of babylonData.babylonMeshes) {\n                            // Ensure nonUniformScaling is set if necessary.\n                            babylonMesh.computeWorldMatrix(true);\n\n                            const babylonMaterial = babylonData.babylonMaterial;\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\n                            if (this._parent.useClipPlane) {\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile materials\");\n        });\n    }\n\n    private _compileShadowGeneratorsAsync(): Promise<void> {\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n        const promises = new Array<Promise<any>>();\n\n        const lights = this._babylonScene.lights;\n        for (let light of lights) {\n            let generator = light.getShadowGenerator();\n            if (generator) {\n                promises.push(generator.forceCompilationAsync());\n            }\n        }\n\n        return Promise.all(promises).then(() => {\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\n        });\n    }\n\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                action(extension);\n            }\n        }\n    }\n\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\n        for (const extension of this._extensions) {\n            if (extension.enabled) {\n                const id = `${extension.name}.${functionName}`;\n                const loaderProperty = property as ILoaderProperty;\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n                if (!activeLoaderExtensionFunctions[id]) {\n                    activeLoaderExtensionFunctions[id] = true;\n\n                    try {\n                        const result = actionAsync(extension);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    finally {\n                        delete activeLoaderExtensionFunctions[id];\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _extensionsOnLoading(): void {\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\n    }\n\n    private _extensionsOnReady(): void {\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\n    }\n\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\n    }\n\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\n    }\n\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\n    }\n\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\n    }\n\n    private _extensionsLoadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: AbstractMesh) => void): Nullable<Promise<AbstractMesh>> {\n        return this._applyExtensions(primitive, \"loadMeshPrimitive\", (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign));\n    }\n\n    private _extensionsLoadMaterialAsync(context: string, material: IMaterial, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\n        return this._applyExtensions(material, \"loadMaterial\", (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\n    }\n\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\n    }\n\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return this._applyExtensions(material, \"loadMaterialProperties\", (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n    }\n\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\n    }\n\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\n    }\n\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\n    }\n\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\n    }\n\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\n    }\n\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\n    }\n\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\n    }\n\n    /**\n     * Helper method called by a loader extension to load an glTF extension.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extension from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extension does not exist\n     */\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\n        if (!property.extensions) {\n            return null;\n        }\n\n        const extensions = property.extensions;\n\n        const extension = extensions[extensionName] as TExtension;\n        if (!extension) {\n            return null;\n        }\n\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\n    }\n\n    /**\n     * Helper method called by a loader extension to load a glTF extra.\n     * @param context The context when loading the asset\n     * @param property The glTF property to load the extra from\n     * @param extensionName The name of the extension to load\n     * @param actionAsync The action to run\n     * @returns The promise returned by actionAsync or null if the extra does not exist\n     */\n    public static LoadExtraAsync<TExtra = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\n        if (!property.extras) {\n            return null;\n        }\n\n        const extras = property.extras;\n\n        const extra = extras[extensionName] as TExtra;\n        if (!extra) {\n            return null;\n        }\n\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\n    }\n\n    /**\n     * Checks for presence of an extension.\n     * @param name The name of the extension to check\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\n     */\n    public isExtensionUsed(name: string): boolean {\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n    }\n\n    /**\n     * Increments the indentation level and logs a message.\n     * @param message The message to log\n     */\n    public logOpen(message: string): void {\n        this._parent._logOpen(message);\n    }\n\n    /**\n     * Decrements the indentation level.\n     */\n    public logClose(): void {\n        this._parent._logClose();\n    }\n\n    /**\n     * Logs a message\n     * @param message The message to log\n     */\n    public log(message: string): void {\n        this._parent._log(message);\n    }\n\n    /**\n     * Starts a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    public startPerformanceCounter(counterName: string): void {\n        this._parent._startPerformanceCounter(counterName);\n    }\n\n    /**\n     * Ends a performance counter.\n     * @param counterName The name of the performance counter\n     */\n    public endPerformanceCounter(counterName: string): void {\n        this._parent._endPerformanceCounter(counterName);\n    }\n}\n\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { Scalar } from \"@babylonjs/core/Maths/math.scalar\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"@babylonjs/core/Maths/sphericalPolynomial\";\r\nimport { Quaternion, Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { RawCubeTexture } from \"@babylonjs/core/Materials/Textures/rawCubeTexture\";\r\n\r\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\r\nimport { IScene } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ninterface ILightReference {\r\n    light: number;\r\n}\r\n\r\ninterface ILight extends IChildRootProperty {\r\n    intensity: number;\r\n    rotation: number[];\r\n    specularImageSize: number;\r\n    specularImages: number[][];\r\n    irradianceCoefficients: number[][];\r\n\r\n    _babylonTexture?: BaseTexture;\r\n    _loaded?: Promise<void>;\r\n}\r\n\r\ninterface ILights {\r\n    lights: ILight[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: ILight[];\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @hidden */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as ILights;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILightReference>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(this._loadLightAsync(`#/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                this._loader.babylonScene.environmentTexture = texture;\r\n            }));\r\n\r\n            this._loader.logClose();\r\n\r\n            return Promise.all(promises).then(() => { });\r\n        });\r\n    }\r\n\r\n    private _loadLightAsync(context: string, light: ILight): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(this._loader.loadImageAsync(`#/images/${index}`, image).then((data) => {\r\n                        imageData[mipmap][face] = data;\r\n                    }));\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            light._loaded = Promise.all(promises).then(() => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scaleInPlace(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);\r\n                return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));","import { DracoCompression } from \"@babylonjs/core/Meshes/Compression/dracoCompression\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\n\r\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport { IBufferView, IMeshPrimitive } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ninterface IKHRDracoMeshCompression {\r\n    bufferView: number;\r\n    attributes: { [name: string]: number };\r\n}\r\n\r\ninterface IBufferViewDraco extends IBufferView {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression)\r\n */\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * The draco compression used to decode vertex data or DracoCompression.Default if not defined\r\n     */\r\n    public dracoCompression?: DracoCompression;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        delete this.dracoCompression;\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP &&\r\n                    primitive.mode !== MeshPrimitiveMode.TRIANGLES) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n\r\n                // TODO: handle triangle strips\r\n                if (primitive.mode === MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\r\n                }\r\n            }\r\n\r\n            const attributes: { [kind: string]: number } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId == undefined) {\r\n                    return;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            var bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                    const dracoCompression = this.dracoCompression || DracoCompression.Default;\r\n                    return dracoCompression.decodeMeshAsync(data, attributes).then((babylonVertexData) => {\r\n                        const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\r\n                        babylonVertexData.applyToGeometry(babylonGeometry);\r\n                        return babylonGeometry;\r\n                    }).catch((error) => {\r\n                        throw new Error(`${context}: ${error.message}`);\r\n                    });\r\n                });\r\n            }\r\n\r\n            return bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_draco_mesh_compression(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\nimport { Light } from \"@babylonjs/core/Lights/light\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\n\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\nimport { INode } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\n\nconst NAME = \"KHR_lights_punctual\";\n\nenum LightType {\n    DIRECTIONAL = \"directional\",\n    POINT = \"point\",\n    SPOT = \"spot\"\n}\n\ninterface ILightReference {\n    light: number;\n}\n\ninterface ILight extends IChildRootProperty {\n    type: LightType;\n    color?: number[];\n    intensity?: number;\n    range?: number;\n    spot?: {\n        innerConeAngle?: number;\n        outerConeAngle?: number;\n    };\n}\n\ninterface ILights {\n    lights: ILight[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual)\n */\nexport class KHR_lights implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n    private _lights?: ILight[];\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n        delete this._lights;\n    }\n\n    /** @hidden */\n    public onLoading(): void {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name] as ILights;\n            this._lights = extension.lights;\n        }\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return GLTFLoader.LoadExtensionAsync<ILightReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight: Light;\n\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n\n                this._loader.babylonScene._blockEntityCollection = this._loader._forAssetContainer;\n\n                switch (light.type) {\n                    case LightType.DIRECTIONAL: {\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        break;\n                    }\n                    case LightType.POINT: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case LightType.SPOT: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n\n                this._loader.babylonScene._blockEntityCollection = false;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n\n                this._loader._babylonLights.push(babylonLight);\n\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n\n                assign(babylonMesh);\n            });\n        });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_lights(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\n\nimport { ITextureInfo, IMaterial } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader } from \"../glTFLoader\";\n\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\n\ninterface IKHRMaterialsPbrSpecularGlossiness {\n    diffuseFactor: number[];\n    diffuseTexture: ITextureInfo;\n    specularFactor: number[];\n    glossinessFactor: number;\n    specularGlossinessTexture: ITextureInfo;\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness)\n */\nexport class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 200;\n\n    private _loader: GLTFLoader;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsPbrSpecularGlossiness>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    private _loadSpecularGlossinessPropertiesAsync(context: string, material: IMaterial, properties: IKHRMaterialsPbrSpecularGlossiness, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.metallic = null;\n        babylonMaterial.roughness = null;\n\n        if (properties.diffuseFactor) {\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\n            babylonMaterial.alpha = properties.diffuseFactor[3];\n        }\n        else {\n            babylonMaterial.albedoColor = Color3.White();\n        }\n\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\n\n        if (properties.diffuseTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Diffuse)`;\n                babylonMaterial.albedoTexture = texture;\n            }));\n        }\n\n        if (properties.specularGlossinessTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Specular Glossiness)`;\n                babylonMaterial.reflectivityTexture = texture;\n            }));\n\n            babylonMaterial.reflectivityTexture.hasAlpha = true;\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\n\r\nimport { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit)\r\n */\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 210;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, () => {\r\n            return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n        babylonMaterial.unlit = true;\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            }\r\n            else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                    babylonMaterial.albedoTexture = texture;\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_unlit(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\n\nimport { ITextureInfo, IMaterial } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader } from \"../glTFLoader\";\nimport { IMaterialNormalTextureInfo } from 'babylonjs-gltf2interface';\n\nconst NAME = \"KHR_materials_clearcoat\";\n\ninterface IKHR_materials_clearcoat {\n    clearcoatFactor: number;\n    clearcoatTexture: ITextureInfo;\n    clearcoatRoughnessFactor: number;\n    clearcoatRoughnessTexture: ITextureInfo;\n    clearcoatNormalTexture: IMaterialNormalTextureInfo;\n}\n\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1677)\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)\n * !!! Experimental Extension Subject to Changes !!!\n */\nexport class KHR_materials_clearcoat implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 190;\n\n    private _loader: GLTFLoader;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IKHR_materials_clearcoat>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    private _loadClearCoatPropertiesAsync(context: string, properties: IKHR_materials_clearcoat, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.clearCoat.isEnabled = true;\n\n        if (properties.clearcoatFactor != undefined) {\n            babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;\n        }\n        else {\n            babylonMaterial.clearCoat.intensity = 0;\n        }\n\n        if (properties.clearcoatTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Intensity)`;\n                babylonMaterial.clearCoat.texture = texture;\n            }));\n        }\n\n        if (properties.clearcoatRoughnessFactor != undefined) {\n            babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;\n        }\n        else {\n            babylonMaterial.clearCoat.roughness = 0;\n        }\n\n        if (properties.clearcoatRoughnessTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;\n                babylonMaterial.clearCoat.texture = texture;\n            }));\n        }\n\n        if (properties.clearcoatNormalTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;\n                babylonMaterial.clearCoat.bumpTexture = texture;\n            }));\n\n            babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;\n            babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;\n            if (properties.clearcoatNormalTexture.scale != undefined) {\n                babylonMaterial.clearCoat.bumpTexture!.level = properties.clearcoatNormalTexture.scale;\n            }\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_clearcoat(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\n\nimport { ITextureInfo, IMaterial } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader } from \"../glTFLoader\";\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\n\nconst NAME = \"KHR_materials_sheen\";\n\ninterface IKHR_materials_sheen {\n    intensityFactor: number;\n    colorFactor: number[];\n    colorIntensityTexture: ITextureInfo;\n}\n\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1688)\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\n * !!! Experimental Extension Subject to Changes !!!\n */\nexport class KHR_materials_sheen implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 190;\n\n    private _loader: GLTFLoader;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IKHR_materials_sheen>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    private _loadSheenPropertiesAsync(context: string, properties: IKHR_materials_sheen, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.sheen.isEnabled = true;\n\n        if (properties.intensityFactor != undefined) {\n            babylonMaterial.sheen.intensity = properties.intensityFactor;\n        }\n        else {\n            babylonMaterial.sheen.intensity = 0;\n        }\n\n        if (properties.colorFactor != undefined) {\n            babylonMaterial.sheen.color = Color3.FromArray(properties.colorFactor);\n        }\n\n        if (properties.colorIntensityTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenTexture`, properties.colorIntensityTexture, (texture) => {\n                texture.name = `${babylonMaterial.name} (Sheen Intensity)`;\n                babylonMaterial.sheen.texture = texture;\n            }));\n        }\n\n        return Promise.all(promises).then(() => { });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_sheen(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\n\nimport { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader } from \"../glTFLoader\";\n\nconst NAME = \"KHR_materials_specular\";\n\ninterface IKHR_materials_specular {\n    specularFactor: number;\n    specularTexture: ITextureInfo;\n}\n\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1677)\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\n * !!! Experimental Extension Subject to Changes !!!\n */\nexport class KHR_materials_specular implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 190;\n\n    private _loader: GLTFLoader;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IKHR_materials_specular>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    private _loadSpecularPropertiesAsync(context: string, properties: IKHR_materials_specular, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        if (properties.specularFactor !== undefined) {\n            babylonMaterial.metallicF0Factor = properties.specularFactor;\n        }\n\n        if (properties.specularTexture) {\n            // This does not allow a separate sampler for it at the moment but is currently under discussion.\n            babylonMaterial.useMetallicF0FactorFromMetallicTexture = true;\n        }\n\n        return Promise.resolve();\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_specular(loader));","import { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_mesh_quantization\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization)\r\n */\r\nexport class KHR_mesh_quantization implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_mesh_quantization(loader));\r\n","import { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\n\r\nconst NAME = \"KHR_texture_basisu\";\r\n\r\ninterface IKHRTextureBasisU {\r\n    source: number;\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1751)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\nexport class KHR_texture_basisu implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureBasisU, BaseTexture>(context, texture, this.name, (extensionContext, extension) => {\r\n            const sampler = (texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler));\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {\r\n                babylonTexture.gammaSpace = false;\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_basisu(loader));","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport { ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform)\r\n */\r\nexport class KHR_texture_transform implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureTransform, BaseTexture>(context, textureInfo, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\r\n                if (!(babylonTexture instanceof Texture)) {\r\n                    throw new Error(`${extensionContext}: Texture type not supported`);\r\n                }\r\n\r\n                if (extension.offset) {\r\n                    babylonTexture.uOffset = extension.offset[0];\r\n                    babylonTexture.vOffset = extension.offset[1];\r\n                }\r\n\r\n                // Always rotate around the origin.\r\n                babylonTexture.uRotationCenter = 0;\r\n                babylonTexture.vRotationCenter = 0;\r\n\r\n                if (extension.rotation) {\r\n                    babylonTexture.wAng = -extension.rotation;\r\n                }\r\n\r\n                if (extension.scale) {\r\n                    babylonTexture.uScale = extension.scale[0];\r\n                    babylonTexture.vScale = extension.scale[1];\r\n                }\r\n\r\n                if (extension.texCoord != undefined) {\r\n                    babylonTexture.coordinatesIndex = extension.texCoord;\r\n                }\r\n\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_texture_transform(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Sound } from \"@babylonjs/core/Audio/sound\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound\";\n\nimport { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { IProperty } from 'babylonjs-gltf2interface';\n\nconst NAME = \"MSFT_audio_emitter\";\n\ninterface IClipReference {\n    clip: number;\n    weight?: number;\n}\n\ninterface IEmittersReference {\n    emitters: number[];\n}\n\nconst enum DistanceModel {\n    linear = \"linear\",\n    inverse = \"inverse\",\n    exponential = \"exponential\",\n}\n\ninterface IEmitter {\n    name?: string;\n    distanceModel?: DistanceModel;\n    refDistance?: number;\n    maxDistance?: number;\n    rolloffFactor?: number;\n    innerAngle?: number;\n    outerAngle?: number;\n    loop?: boolean;\n    volume?: number;\n    clips: IClipReference[];\n}\n\nconst enum AudioMimeType {\n    WAV = \"audio/wav\",\n}\n\ninterface IClip extends IProperty {\n    uri?: string;\n    bufferView?: number;\n    mimeType?: AudioMimeType;\n}\n\ninterface ILoaderClip extends IClip, IArrayItem {\n    _objectURL?: Promise<string>;\n}\n\ninterface ILoaderEmitter extends IEmitter, IArrayItem {\n    _babylonData?: {\n        sound?: WeightedSound;\n        loaded: Promise<void>;\n    };\n    _babylonSounds: Sound[];\n}\n\ninterface IMSFTAudioEmitter {\n    clips: ILoaderClip[];\n    emitters: ILoaderEmitter[];\n}\n\nconst enum AnimationEventAction {\n    play = \"play\",\n    pause = \"pause\",\n    stop = \"stop\",\n}\n\ninterface IAnimationEvent {\n    action: AnimationEventAction;\n    emitter: number;\n    time: number;\n    startOffset?: number;\n}\n\ninterface ILoaderAnimationEvent extends IAnimationEvent, IArrayItem {\n}\n\ninterface ILoaderAnimationEvents {\n    events: ILoaderAnimationEvent[];\n}\n\n/**\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\n */\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n    private _clips: Array<ILoaderClip>;\n    private _emitters: Array<ILoaderEmitter>;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n        delete this._clips;\n        delete this._emitters;\n    }\n\n    /** @hidden */\n    public onLoading(): void {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\n\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n\n    /** @hidden */\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IEmittersReference>(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            promises.push(this._loader.loadSceneAsync(context, scene));\n\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return GLTFLoader.LoadExtensionAsync<IEmittersReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            return this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(\n                                    2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\n                                    2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\n                                    0);\n                            }\n                        }\n                    }));\n                }\n\n                assign(babylonMesh);\n            }).then((babylonMesh) => {\n                return Promise.all(promises).then(() => {\n                    return babylonMesh;\n                });\n            });\n        });\n    }\n\n    /** @hidden */\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\n                const promises = new Array<Promise<any>>();\n\n                ArrayItem.Assign(extension.events);\n                for (const event of extension.events) {\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n                }\n\n                return Promise.all(promises).then(() => {\n                    return babylonAnimationGroup;\n                });\n            });\n        });\n    }\n\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n\n        let promise: Promise<ArrayBufferView>;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView);\n        }\n\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n\n        return clip._objectURL;\n    }\n\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array<Promise<any>>();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `#/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\n                    const sound = emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options);\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || 'exponential';\n                    sound._positionInEmitterSpace = true;\n                }));\n            }\n\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => { return clip.weight || 1; });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) { weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle); }\n                if (emitter.outerAngle) { weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle); }\n                if (emitter.volume) { weightedSound.volume = emitter.volume; }\n                emitter._babylonData!.sound = weightedSound;\n            });\n\n            emitter._babylonData = {\n                loaded: promise\n            };\n        }\n\n        return emitter._babylonData.loaded;\n    }\n\n    private _getEventAction(context: string, sound: WeightedSound, action: AnimationEventAction, time: number, startOffset?: number): (currentFrame: number) => void {\n        switch (action) {\n            case AnimationEventAction.play: {\n                return (currentFrame: number) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case AnimationEventAction.stop: {\n                return (currentFrame: number) => {\n                    sound.stop();\n                };\n            }\n            case AnimationEventAction.pause: {\n                return (currentFrame: number) => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n\n    private _loadAnimationEventAsync(context: string, animationContext: string, animation: IAnimation, event: ILoaderAnimationEvent, babylonAnimationGroup: AnimationGroup): Promise<void> {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`#/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData!.sound;\n            if (sound) {\n                var babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));","import { Nullable } from \"@babylonjs/core/types\";\nimport { Observable } from \"@babylonjs/core/Misc/observable\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred\";\nimport { Material } from \"@babylonjs/core/Materials/material\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { BaseTexture } from '@babylonjs/core/Materials/Textures/baseTexture';\nimport { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { IProperty } from 'babylonjs-gltf2interface';\n\nconst NAME = \"MSFT_lod\";\n\ninterface IMSFTLOD {\n    ids: number[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\n */\nexport class MSFT_lod implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    public order = 100;\n\n    /**\n     * Maximum number of LODs to load, starting from the lowest LOD.\n     */\n    public maxLODsToLoad = 10;\n\n    /**\n     * Observable raised when all node LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onNodeLODsLoadedObservable = new Observable<number>();\n\n    /**\n     * Observable raised when all material LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onMaterialLODsLoadedObservable = new Observable<number>();\n\n    private _loader: GLTFLoader;\n\n    private _nodeIndexLOD: Nullable<number> = null;\n    private _nodeSignalLODs = new Array<Deferred<void>>();\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\n\n    private _materialIndexLOD: Nullable<number> = null;\n    private _materialSignalLODs = new Array<Deferred<void>>();\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\n\n    private _indexLOD: Nullable<number> = null;\n    private _bufferLODs = new Array<{ start: number, end: number, loaded: Deferred<ArrayBufferView> }>();\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n\n        this._indexLOD = null;\n        this._bufferLODs.length = 0;\n\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n\n    /** @hidden */\n    public onReady(): void {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                }\n\n                this._loader.log(`Loaded node LOD ${indexLOD}`);\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                }\n\n                this._loader.log(`Loaded material LOD ${indexLOD}`);\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n\n        for (let indexLOD = 1; indexLOD < this._bufferLODs.length; indexLOD++) {\n            this._loadBufferLOD(indexLOD);\n        }\n    }\n\n    /** @hidden */\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        const promise = this._loader.loadSceneAsync(context, scene);\n        if (this._bufferLODs.length !== 0) {\n            this._loadBufferLOD(0);\n        }\n        return promise;\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<TransformNode>;\n\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n\n                this._indexLOD = indexLOD;\n\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n\n                const assign = (babylonTransformNode: TransformNode) => { babylonTransformNode.setEnabled(false); };\n                const promise = this._loader.loadNodeAsync(`#/nodes/${nodeLOD.index}`, nodeLOD, assign).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonTransformNode\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonTransformNode) {\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n                            delete previousNodeLOD._babylonTransformNode;\n                        }\n                    }\n\n                    babylonMesh.setEnabled(true);\n                    return babylonMesh;\n                });\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                }\n\n                this._indexLOD = null;\n\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n                this._nodePromiseLODs[indexLOD].push(promise);\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._indexLOD) {\n            return null;\n        }\n\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<Material>;\n\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n\n                this._indexLOD = indexLOD;\n\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n\n                const promise = this._loader._loadMaterialAsync(`#/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                }).then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n\n                        // TODO: should not rely on _data\n                        const previousDataLOD = materialLODs[indexLOD - 1]._data!;\n                        if (previousDataLOD[babylonDrawMode]) {\n                            this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n                            delete previousDataLOD[babylonDrawMode];\n                        }\n                    }\n\n                    return babylonMaterial;\n                });\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                }\n\n                this._indexLOD = null;\n\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n                this._materialPromiseLODs[indexLOD].push(promise);\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\n        // Defer the loading of uris if loading a material or node LOD.\n        if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        else if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\n                return this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n\n        return null;\n    }\n\n    /** @hidden */\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\n            if (!this._loader.bin) {\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n            }\n\n            // Non-LOD buffers will be bucketed into the first LOD.\n            const indexLOD = this._indexLOD || 0;\n\n            const start = byteOffset;\n            const end = start + byteLength - 1;\n            let bufferLOD = this._bufferLODs[indexLOD];\n            if (bufferLOD) {\n                bufferLOD.start = Math.min(bufferLOD.start, start);\n                bufferLOD.end = Math.max(bufferLOD.end, end);\n            }\n            else {\n                bufferLOD = { start: start, end: end, loaded: new Deferred() };\n                this._bufferLODs[indexLOD] = bufferLOD;\n            }\n\n            return bufferLOD.loaded.promise.then((data) => {\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n            });\n        }\n\n        return null;\n    }\n\n    private _loadBufferLOD(indexLOD: number): void {\n        const bufferLOD = this._bufferLODs[indexLOD];\n        this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {\n            bufferLOD.loaded.resolve(data);\n        }, (error) => {\n            bufferLOD.loaded.reject(error);\n        });\n    }\n\n    /**\n     * Gets an array of LOD properties from lowest to highest.\n     */\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n\n        const properties = new Array<T>();\n\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n\n        properties.push(property);\n        return properties;\n    }\n\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\n        const babylonMaterials = new Array<Material>();\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\n        if (babylonMaterial) {\n            babylonMaterials.push(babylonMaterial);\n        }\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n            if (babylonMesh.material) {\n                babylonMaterials.push(babylonMesh.material);\n            }\n        }\n\n        babylonTransformNode.dispose();\n\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\n        this._disposeMaterials(babylonMaterialsToDispose);\n    }\n\n    private _disposeMaterials(babylonMaterials: Material[]): void {\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\n\n        for (const babylonMaterial of babylonMaterials) {\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n            }\n\n            babylonMaterial.dispose();\n        }\n\n        for (const uniqueId in babylonTextures) {\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n                    delete babylonTextures[uniqueId];\n                }\n            }\n        }\n\n        for (const uniqueId in babylonTextures) {\n            babylonTextures[uniqueId].dispose();\n        }\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\r\n\r\nimport { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_minecraftMesh\";\r\n\r\n/** @hidden */\r\nexport class MSFT_minecraftMesh implements IGLTFLoaderExtension {\r\n    public readonly name = NAME;\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (babylonMaterial.needAlphaBlending()) {\r\n                    babylonMaterial.forceDepthWrite = true;\r\n                    babylonMaterial.separateCullingPass = true;\r\n                }\r\n\r\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\r\n                babylonMaterial.twoSidedLighting = true;\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_minecraftMesh(loader));","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\r\n\r\nimport { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_sRGBFactors\";\r\n\r\n/** @hidden */\r\nexport class MSFT_sRGBFactors implements IGLTFLoaderExtension {\r\n    public readonly name = NAME;\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (!babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);\r\n                }\r\n\r\n                if (!babylonMaterial.reflectivityTexture) {\r\n                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);\r\n                }\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_sRGBFactors(loader));","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\r\n\r\nimport { IProperty } from \"babylonjs-gltf2interface\";\r\nimport { INode, ICamera, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\n\r\nconst NAME = \"ExtrasAsMetadata\";\r\n\r\ninterface ObjectWithMetadata {\r\n    metadata: any;\r\n}\r\n\r\n/**\r\n * Store glTF extras (if present) in BJS objects' metadata\r\n */\r\nexport class ExtrasAsMetadata implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _assignExtras(\r\n        babylonObject: ObjectWithMetadata,\r\n        gltfProp: IProperty\r\n    ): void {\r\n        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {\r\n            const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n            const gltf = (metadata.gltf = metadata.gltf || {});\r\n            gltf.extras = gltfProp.extras;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadNodeAsync(\r\n        context: string,\r\n        node: INode,\r\n        assign: (babylonTransformNode: TransformNode) => void\r\n    ): Nullable<Promise<TransformNode>> {\r\n        return this._loader.loadNodeAsync(\r\n            context,\r\n            node,\r\n            (babylonTransformNode): void => {\r\n                this._assignExtras(babylonTransformNode, node);\r\n                assign(babylonTransformNode);\r\n            }\r\n        );\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadCameraAsync(\r\n        context: string,\r\n        camera: ICamera,\r\n        assign: (babylonCamera: Camera) => void\r\n    ): Nullable<Promise<Camera>> {\r\n        return this._loader.loadCameraAsync(\r\n            context,\r\n            camera,\r\n            (babylonCamera): void => {\r\n                this._assignExtras(babylonCamera, camera);\r\n                assign(babylonCamera);\r\n            }\r\n        );\r\n    }\r\n\r\n    /** @hidden */\r\n    public createMaterial(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonDrawMode: number\r\n    ): Nullable<Material> {\r\n        const babylonMaterial = this._loader.createMaterial(\r\n            context,\r\n            material,\r\n            babylonDrawMode\r\n        );\r\n        this._assignExtras(babylonMaterial, material);\r\n        return babylonMaterial;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(\r\n    NAME,\r\n    (loader): IGLTFLoaderExtension => new ExtrasAsMetadata(loader)\r\n);\r\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'cellPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\n\nvec3 computeCustomDiffuseLighting(lightingInfo info,vec3 diffuseBase,float shadow)\n{\ndiffuseBase=info.diffuse*shadow;\n#ifdef CELLBASIC\nfloat level=1.0;\nif (info.ndl<0.5)\nlevel=0.5;\ndiffuseBase.rgb*vec3(level,level,level);\n#else\nfloat ToonThresholds[4];\nToonThresholds[0]=0.95;\nToonThresholds[1]=0.5;\nToonThresholds[2]=0.2;\nToonThresholds[3]=0.03;\nfloat ToonBrightnessLevels[5];\nToonBrightnessLevels[0]=1.0;\nToonBrightnessLevels[1]=0.8;\nToonBrightnessLevels[2]=0.6;\nToonBrightnessLevels[3]=0.35;\nToonBrightnessLevels[4]=0.2;\nif (info.ndl>ToonThresholds[0])\n{\ndiffuseBase.rgb*=ToonBrightnessLevels[0];\n}\nelse if (info.ndl>ToonThresholds[1])\n{\ndiffuseBase.rgb*=ToonBrightnessLevels[1];\n}\nelse if (info.ndl>ToonThresholds[2])\n{\ndiffuseBase.rgb*=ToonBrightnessLevels[2];\n}\nelse if (info.ndl>ToonThresholds[3])\n{\ndiffuseBase.rgb*=ToonBrightnessLevels[3];\n}\nelse\n{\ndiffuseBase.rgb*=ToonBrightnessLevels[4];\n}\n#endif\nreturn max(diffuseBase,vec3(0.2));\n}\nvoid main(void)\n{\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\nlightingInfo info;\nvec3 diffuseBase=vec3(0.,0.,0.);\nfloat shadow=1.;\nfloat glossiness=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n\nvec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var cellPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'cellVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var cellVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\n\r\nimport \"./cell.fragment\";\r\nimport \"./cell.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass CellMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public NDOTL = true;\r\n    public CUSTOMUSERLIGHTING = true;\r\n    public CELLBASIC = true;\r\n    public DEPTHPREPASS = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class CellMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"computeHighLevel\")\r\n    public _computeHighLevel: boolean = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public computeHighLevel: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new CellMaterialDefines();\r\n        }\r\n\r\n        var defines = <CellMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        defines.CELLBASIC = !this.computeHighLevel;\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            var shaderName = \"cell\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\"];\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights - 1 }\r\n                }, engine), defines);\r\n\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <CellMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        return this._diffuseTexture === texture;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"CellMaterial\";\r\n    }\r\n\r\n    public clone(name: string): CellMaterial {\r\n        return SerializationHelper.Clone<CellMaterial>(() => new CellMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.CellMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): CellMaterial {\r\n        return SerializationHelper.Parse(() => new CellMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.CellMaterial\"] = CellMaterial;\r\n","import { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\nimport { StandardMaterialDefines } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\n\nexport class CustomShaderStructure {\n\n    public FragmentStore: string;\n    public VertexStore: string;\n\n    constructor() { }\n}\n\nexport class ShaderSpecialParts {\n\n    constructor() { }\n\n    public Fragment_Begin: string;\n    public Fragment_Definitions: string;\n    public Fragment_MainBegin: string;\n\n    // diffuseColor\n    public Fragment_Custom_Diffuse: string;\n    // lights\n    public Fragment_Before_Lights: string;\n    // fog\n    public Fragment_Before_Fog: string;\n    // alpha\n    public Fragment_Custom_Alpha: string;\n\n    public Fragment_Before_FragColor: string;\n\n    public Vertex_Begin: string;\n    public Vertex_Definitions: string;\n    public Vertex_MainBegin: string;\n\n    // positionUpdated\n    public Vertex_Before_PositionUpdated: string;\n\n    // normalUpdated\n    public Vertex_Before_NormalUpdated: string;\n\n    // mainEnd\n    public Vertex_MainEnd: string;\n}\n\nexport class CustomMaterial extends StandardMaterial {\n    public static ShaderIndexer = 1;\n    public CustomParts: ShaderSpecialParts;\n    _isCreatedShader: boolean;\n    _createdShaderName: string;\n    _customUniform: string[];\n    _newUniforms: string[];\n    _newUniformInstances: any[];\n    _newSamplerInstances: Texture[];\n\n    public FragmentShader: string;\n    public VertexShader: string;\n\n    public AttachAfterBind(mesh: Mesh, effect: Effect) {\n        for (var el in this._newUniformInstances) {\n            var ea = el.toString().split('-');\n            if (ea[0] == 'vec2') {\n                effect.setVector2(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'vec3') {\n                effect.setVector3(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'vec4') {\n                effect.setVector4(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'mat4') {\n                effect.setMatrix(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'float') {\n                effect.setFloat(ea[1], this._newUniformInstances[el]);\n            }\n        }\n        for (var el in this._newSamplerInstances) {\n            var ea = el.toString().split('-');\n            if (ea[0] == 'sampler2D' && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\n                effect.setTexture(ea[1], this._newSamplerInstances[el]);\n            }\n        }\n    }\n\n    public ReviewUniform(name: string, arr: string[]): string[] {\n        if (name == \"uniform\") {\n            for (var ind in this._newUniforms) {\n                if (this._customUniform[ind].indexOf('sampler') == -1) {\n                    arr.push(this._newUniforms[ind]);\n                }\n            }\n        }\n        if (name == \"sampler\") {\n            for (var ind in this._newUniforms) {\n                if (this._customUniform[ind].indexOf('sampler') != -1) {\n                    arr.push(this._newUniforms[ind]);\n                }\n            }\n        }\n        return arr;\n    }\n\n    public Builder(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines): string {\n\n        if (this._isCreatedShader) {\n            return this._createdShaderName;\n        }\n        this._isCreatedShader = false;\n\n        CustomMaterial.ShaderIndexer++;\n        var name: string = \"custom_\" + CustomMaterial.ShaderIndexer;\n\n        this.ReviewUniform(\"uniform\", uniforms);\n        this.ReviewUniform(\"sampler\", samplers);\n\n        var fn_afterBind = this._afterBind.bind(this);\n        this._afterBind = (m, e) => {\n            if (!e) {\n                return;\n            }\n            this.AttachAfterBind(m, e);\n            try { fn_afterBind(m, e); }\n            catch (e) { }\n        };\n\n        Effect.ShadersStore[name + \"VertexShader\"] = this.VertexShader\n            .replace('#define CUSTOM_VERTEX_BEGIN', (this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : \"\"))\n            .replace('#define CUSTOM_VERTEX_DEFINITIONS', (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : \"\"))\n            .replace('#define CUSTOM_VERTEX_MAIN_BEGIN', (this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : \"\"))\n            .replace('#define CUSTOM_VERTEX_UPDATE_POSITION', (this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : \"\"))\n            .replace('#define CUSTOM_VERTEX_UPDATE_NORMAL', (this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : \"\"))\n            .replace('#define CUSTOM_VERTEX_MAIN_END', (this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : \"\"));\n\n        Effect.ShadersStore[name + \"PixelShader\"] = this.FragmentShader\n            .replace('#define CUSTOM_FRAGMENT_BEGIN', (this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_MAIN_BEGIN', (this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_DEFINITIONS', (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE', (this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_ALPHA', (this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_LIGHTS', (this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_FOG', (this.CustomParts.Fragment_Before_Fog ? this.CustomParts.Fragment_Before_Fog : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR', (this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : \"\"));\n\n        this._isCreatedShader = true;\n        this._createdShaderName = name;\n\n        return name;\n    }\n\n    constructor(name: string, scene: Scene) {\n        super(name, scene);\n        this.CustomParts = new ShaderSpecialParts();\n        this.customShaderNameResolve = this.Builder;\n\n        this.FragmentShader = Effect.ShadersStore[\"defaultPixelShader\"];\n        this.VertexShader = Effect.ShadersStore[\"defaultVertexShader\"];\n    }\n\n    public AddUniform(name: string, kind: string, param: any): CustomMaterial {\n        if (!this._customUniform) {\n            this._customUniform = new Array();\n            this._newUniforms = new Array();\n            this._newSamplerInstances = new Array();\n            this._newUniformInstances = new Array();\n        }\n        if (param) {\n            if (kind.indexOf(\"sampler\") == -1) {\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\n            }\n            else {\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\n            }\n        }\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\n        this._newUniforms.push(name);\n\n        return this;\n    }\n\n    public Fragment_Begin(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Begin = shaderPart;\n        return this;\n    }\n\n    public Fragment_Definitions(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Definitions = shaderPart;\n        return this;\n    }\n\n    public Fragment_MainBegin(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_MainBegin = shaderPart;\n        return this;\n    }\n\n    public Fragment_Custom_Diffuse(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace(\"result\", \"diffuseColor\");\n        return this;\n    }\n\n    public Fragment_Custom_Alpha(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\n        return this;\n    }\n\n    public Fragment_Before_Lights(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\n        return this;\n    }\n\n    public Fragment_Before_Fog(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\n        return this;\n    }\n\n    public Fragment_Before_FragColor(shaderPart: string): CustomMaterial {\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\n        return this;\n    }\n\n    public Vertex_Begin(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_Begin = shaderPart;\n        return this;\n    }\n\n    public Vertex_Definitions(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_Definitions = shaderPart;\n        return this;\n    }\n\n    public Vertex_MainBegin(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_MainBegin = shaderPart;\n        return this;\n    }\n\n    public Vertex_Before_PositionUpdated(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\n        return this;\n    }\n\n    public Vertex_Before_NormalUpdated(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\n        return this;\n    }\n\n    public Vertex_MainEnd(shaderPart: string): CustomMaterial {\n        this.CustomParts.Vertex_MainEnd = shaderPart;\n        return this;\n    }\n}\n\n_TypeStore.RegisteredTypes[\"BABYLON.CustomMaterial\"] = CustomMaterial;","import { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\nimport { PBRMaterialDefines } from \"@babylonjs/core/Materials/PBR/pbrBaseMaterial\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\n\nexport class ShaderAlebdoParts {\n\n    constructor() { }\n\n    public Fragment_Begin: string;\n    public Fragment_Definitions: string;\n    public Fragment_MainBegin: string;\n\n    // albedoColor\n    public Fragment_Custom_Albedo: string;\n    // lights\n    public Fragment_Before_Lights: string;\n    // roughness\n    public Fragment_Custom_MetallicRoughness: string;\n    // microsurface\n    public Fragment_Custom_MicroSurface: string;\n    // fog\n    public Fragment_Before_Fog: string;\n    // alpha\n    public Fragment_Custom_Alpha: string;\n\n    public Fragment_Before_FragColor: string;\n\n    public Vertex_Begin: string;\n    public Vertex_Definitions: string;\n    public Vertex_MainBegin: string;\n\n    // positionUpdated\n    public Vertex_Before_PositionUpdated: string;\n\n    // normalUpdated\n    public Vertex_Before_NormalUpdated: string;\n\n    // mainEnd\n    public Vertex_MainEnd: string;\n}\n\nexport class PBRCustomMaterial extends PBRMaterial {\n    public static ShaderIndexer = 1;\n    public CustomParts: ShaderAlebdoParts;\n    _isCreatedShader: boolean;\n    _createdShaderName: string;\n    _customUniform: string[];\n    _newUniforms: string[];\n    _newUniformInstances: any[];\n    _newSamplerInstances: Texture[];\n\n    public FragmentShader: string;\n    public VertexShader: string;\n\n    public AttachAfterBind(mesh: Mesh, effect: Effect) {\n        for (var el in this._newUniformInstances) {\n            var ea = el.toString().split('-');\n            if (ea[0] == 'vec2') {\n                effect.setVector2(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'vec3') {\n                effect.setVector3(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'vec4') {\n                effect.setVector4(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'mat4') {\n                effect.setMatrix(ea[1], this._newUniformInstances[el]);\n            }\n            else if (ea[0] == 'float') {\n                effect.setFloat(ea[1], this._newUniformInstances[el]);\n            }\n        }\n        for (var el in this._newSamplerInstances) {\n            var ea = el.toString().split('-');\n            if (ea[0] == 'sampler2D' && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\n                effect.setTexture(ea[1], this._newSamplerInstances[el]);\n            }\n        }\n    }\n\n    public ReviewUniform(name: string, arr: string[]): string[] {\n        if (name == \"uniform\") {\n            for (var ind in this._newUniforms) {\n                if (this._customUniform[ind].indexOf('sampler') == -1) {\n                    arr.push(this._newUniforms[ind]);\n                }\n            }\n        }\n        if (name == \"sampler\") {\n            for (var ind in this._newUniforms) {\n                if (this._customUniform[ind].indexOf('sampler') != -1) {\n                    arr.push(this._newUniforms[ind]);\n                }\n            }\n        }\n        return arr;\n    }\n\n    public Builder(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: PBRMaterialDefines): string {\n\n        if (this._isCreatedShader) {\n            return this._createdShaderName;\n        }\n        this._isCreatedShader = false;\n\n        PBRCustomMaterial.ShaderIndexer++;\n        var name: string = \"custom_\" + PBRCustomMaterial.ShaderIndexer;\n\n        this.ReviewUniform(\"uniform\", uniforms);\n        this.ReviewUniform(\"sampler\", samplers);\n\n        var fn_afterBind = this._afterBind.bind(this);\n        this._afterBind = (m, e) => {\n            if (!e) {\n                return;\n            }\n            this.AttachAfterBind(m, e);\n            try { fn_afterBind(m, e); }\n            catch (e) { }\n        };\n\n        Effect.ShadersStore[name + \"VertexShader\"] = this.VertexShader\n            .replace('#define CUSTOM_VERTEX_BEGIN', (this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : \"\"))\n            .replace('#define CUSTOM_VERTEX_DEFINITIONS', (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : \"\"))\n            .replace('#define CUSTOM_VERTEX_MAIN_BEGIN', (this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : \"\"))\n            .replace('#define CUSTOM_VERTEX_UPDATE_POSITION', (this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : \"\"))\n            .replace('#define CUSTOM_VERTEX_UPDATE_NORMAL', (this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : \"\"))\n            .replace('#define CUSTOM_VERTEX_MAIN_END', (this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : \"\"));\n\n        Effect.ShadersStore[name + \"PixelShader\"] = this.FragmentShader\n            .replace('#define CUSTOM_FRAGMENT_BEGIN', (this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_MAIN_BEGIN', (this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_DEFINITIONS', (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_ALBEDO', (this.CustomParts.Fragment_Custom_Albedo ? this.CustomParts.Fragment_Custom_Albedo : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_ALPHA', (this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_LIGHTS', (this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS', (this.CustomParts.Fragment_Custom_MetallicRoughness ? this.CustomParts.Fragment_Custom_MetallicRoughness : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE', (this.CustomParts.Fragment_Custom_MicroSurface ? this.CustomParts.Fragment_Custom_MicroSurface : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_FOG', (this.CustomParts.Fragment_Before_Fog ? this.CustomParts.Fragment_Before_Fog : \"\"))\n            .replace('#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR', (this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : \"\"));\n\n        this._isCreatedShader = true;\n        this._createdShaderName = name;\n\n        return name;\n    }\n\n    constructor(name: string, scene: Scene) {\n        super(name, scene);\n        this.CustomParts = new ShaderAlebdoParts();\n        this.customShaderNameResolve = this.Builder;\n\n        this.FragmentShader = Effect.ShadersStore[\"pbrPixelShader\"];\n        this.VertexShader = Effect.ShadersStore[\"pbrVertexShader\"];\n    }\n\n    public AddUniform(name: string, kind: string, param: any): PBRCustomMaterial {\n        if (!this._customUniform) {\n            this._customUniform = new Array();\n            this._newUniforms = new Array();\n            this._newSamplerInstances = new Array();\n            this._newUniformInstances = new Array();\n        }\n        if (param) {\n            if (kind.indexOf(\"sampler\") == -1) {\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\n            }\n            else {\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\n            }\n        }\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\n        this._newUniforms.push(name);\n\n        return this;\n    }\n\n    public Fragment_Begin(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Begin = shaderPart;\n        return this;\n    }\n\n    public Fragment_Definitions(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Definitions = shaderPart;\n        return this;\n    }\n\n    public Fragment_MainBegin(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_MainBegin = shaderPart;\n        return this;\n    }\n\n    public Fragment_Custom_Albedo(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Custom_Albedo = shaderPart.replace(\"result\", \"surfaceAlbedo\");\n        return this;\n    }\n\n    public Fragment_Custom_Alpha(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\n        return this;\n    }\n\n    public Fragment_Before_Lights(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\n        return this;\n    }\n\n    public Fragment_Custom_MetallicRoughness(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Custom_MetallicRoughness = shaderPart;\n        return this;\n    }\n\n    public Fragment_Custom_MicroSurface(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Custom_MicroSurface = shaderPart;\n        return this;\n    }\n\n    public Fragment_Before_Fog(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\n        return this;\n    }\n\n    public Fragment_Before_FragColor(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\n        return this;\n    }\n\n    public Vertex_Begin(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_Begin = shaderPart;\n        return this;\n    }\n\n    public Vertex_Definitions(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_Definitions = shaderPart;\n        return this;\n    }\n\n    public Vertex_MainBegin(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_MainBegin = shaderPart;\n        return this;\n    }\n\n    public Vertex_Before_PositionUpdated(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\n        return this;\n    }\n\n    public Vertex_Before_NormalUpdated(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\n        return this;\n    }\n\n    public Vertex_MainEnd(shaderPart: string): PBRCustomMaterial {\n        this.CustomParts.Vertex_MainEnd = shaderPart;\n        return this;\n    }\n}\n\n_TypeStore.RegisteredTypes[\"BABYLON.PBRCustomMaterial\"] = PBRCustomMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'firePixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\n\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\nuniform sampler2D distortionSampler;\nuniform sampler2D opacitySampler;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;\nvarying vec2 vDistortionCoords2;\nvarying vec2 vDistortionCoords3;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvec4 bx2(vec4 x)\n{\nreturn vec4(2.0)*x-vec4(1.0);\n}\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\n\nfloat alpha=1.0;\n#ifdef DIFFUSE\n\nconst float distortionAmount0=0.092;\nconst float distortionAmount1=0.092;\nconst float distortionAmount2=0.092;\nvec2 heightAttenuation=vec2(0.3,0.39);\nvec4 noise0=texture2D(distortionSampler,vDistortionCoords1);\nvec4 noise1=texture2D(distortionSampler,vDistortionCoords2);\nvec4 noise2=texture2D(distortionSampler,vDistortionCoords3);\nvec4 noiseSum=bx2(noise0)*distortionAmount0+bx2(noise1)*distortionAmount1+bx2(noise2)*distortionAmount2;\nvec4 perturbedBaseCoords=vec4(vDiffuseUV,0.0,1.0)+noiseSum*(vDiffuseUV.y*heightAttenuation.x+heightAttenuation.y);\nvec4 opacityColor=texture2D(opacitySampler,perturbedBaseCoords.xy);\n#ifdef ALPHATEST\nif (opacityColor.r<0.1)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor=texture2D(diffuseSampler,perturbedBaseCoords.xy)*2.0;\nbaseColor*=opacityColor;\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\nvec3 diffuseBase=vec3(1.0,1.0,1.0);\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n\nvec4 color=vec4(baseColor.rgb,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var firePixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\n\nlet name = 'fireVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n\nuniform float time;\nuniform float speed;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;\nvarying vec2 vDistortionCoords2;\nvarying vec2 vDistortionCoords3;\n#endif\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n\n#ifdef DIFFUSE\nvDiffuseUV=uv;\nvDiffuseUV.y-=0.2;\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n#ifdef DIFFUSE\n\nvec3 layerSpeed=vec3(-0.2,-0.52,-0.1)*speed;\nvDistortionCoords1.x=uv.x;\nvDistortionCoords1.y=uv.y+layerSpeed.x*time/1000.0;\nvDistortionCoords2.x=uv.x;\nvDistortionCoords2.y=uv.y+layerSpeed.y*time/1000.0;\nvDistortionCoords3.x=uv.x;\nvDistortionCoords3.y=uv.y+layerSpeed.z*time/1000.0;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var fireVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\n\r\nimport \"./fire.fragment\";\r\nimport \"./fire.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass FireMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public UV1 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public BonesPerMesh = 0;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FireMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"distortionTexture\")\r\n    private _distortionTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public distortionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public speed = 1.0;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n    private _renderId: number;\r\n    private _lastTime: number = 0;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new FireMaterialDefines();\r\n        }\r\n\r\n        var defines = <FireMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture.isReady()) {\r\n                    return false;\r\n                } else {\r\n                    defines._needUVs = true;\r\n                    defines.DIFFUSE = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines.ALPHATEST = this._opacityTexture ? true : false;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            defines.POINTSIZE = (this.pointsCloud || scene.forcePointsCloud);\r\n            defines.FOG = (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled);\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"fire\";\r\n\r\n            var join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                {\r\n                    attributes: attribs,\r\n                    uniformsNames: [\"world\", \"view\", \"viewProjection\", \"vEyePosition\",\r\n                        \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                        \"vDiffuseInfos\",\r\n                        \"mBones\",\r\n                        \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\",\r\n                        // Fire\r\n                        \"time\", \"speed\"\r\n                    ],\r\n                    uniformBuffersNames: [],\r\n                    samplers: [\"diffuseSampler\",\r\n                        // Fire\r\n                        \"distortionSampler\", \"opacitySampler\"\r\n                    ],\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: null,\r\n                    maxSimultaneousLights: 4,\r\n                    transformFeedbackVaryings: null\r\n                }, engine), defines);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <FireMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n\r\n                this._activeEffect.setTexture(\"distortionSampler\", this._distortionTexture);\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Time\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", this._lastTime);\r\n\r\n        // Speed\r\n        this._activeEffect.setFloat(\"speed\", this.speed);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._distortionTexture && this._distortionTexture.animations && this._distortionTexture.animations.length > 0) {\r\n            results.push(this._distortionTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            activeTextures.push(this._distortionTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._distortionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FireMaterial\";\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n        if (this._distortionTexture) {\r\n            this._distortionTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FireMaterial {\r\n        return SerializationHelper.Clone<FireMaterial>(() => new FireMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n\r\n        var serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FireMaterial\";\r\n        serializationObject.diffuseColor = this.diffuseColor.asArray();\r\n        serializationObject.speed = this.speed;\r\n\r\n        if (this._diffuseTexture) {\r\n            serializationObject._diffuseTexture = this._diffuseTexture.serialize();\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            serializationObject._distortionTexture = this._distortionTexture.serialize();\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            serializationObject._opacityTexture = this._opacityTexture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FireMaterial {\r\n        var material = new FireMaterial(source.name, scene);\r\n\r\n        material.diffuseColor = Color3.FromArray(source.diffuseColor);\r\n        material.speed = source.speed;\r\n\r\n        material.alpha = source.alpha;\r\n\r\n        material.id = source.id;\r\n\r\n        Tags.AddTagsTo(material, source.tags);\r\n        material.backFaceCulling = source.backFaceCulling;\r\n        material.wireframe = source.wireframe;\r\n\r\n        if (source._diffuseTexture) {\r\n            material._diffuseTexture = Texture.Parse(source._diffuseTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._distortionTexture) {\r\n            material._distortionTexture = Texture.Parse(source._distortionTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._opacityTexture) {\r\n            material._opacityTexture = Texture.Parse(source._opacityTexture, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.FireMaterial\"] = FireMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'furPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n\nuniform vec4 furColor;\nuniform float furLength;\nvarying vec3 vPositionW;\nvarying float vfur_length;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef HIGHLEVEL\nuniform float furOffset;\nuniform float furOcclusion;\nuniform sampler2D furTexture;\nvarying vec2 vFurUV;\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<fogFragmentDeclaration>\n#include<clipPlaneFragmentDeclaration>\nfloat Rand(vec3 rv) {\nfloat x=dot(rv,vec3(12.9898,78.233,24.65487));\nreturn fract(sin(x)*43758.5453);\n}\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=furColor;\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor*=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef HIGHLEVEL\n\nvec4 furTextureColor=texture2D(furTexture,vec2(vFurUV.x,vFurUV.y));\nif (furTextureColor.a<=0.0 || furTextureColor.g<furOffset) {\ndiscard;\n}\nfloat occlusion=mix(0.0,furTextureColor.b*1.2,furOffset);\nbaseColor=vec4(baseColor.xyz*max(occlusion,furOcclusion),1.1-furOffset);\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase.rgb*baseColor.rgb,0.0,1.0);\n\n#ifdef HIGHLEVEL\nvec4 color=vec4(finalDiffuse,alpha);\n#else\nfloat r=vfur_length/furLength*0.5;\nvec4 color=vec4(finalDiffuse*(0.5+r),alpha);\n#endif\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var furPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'furVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\nuniform float furLength;\nuniform float furAngle;\n#ifdef HIGHLEVEL\nuniform float furOffset;\nuniform vec3 furGravity;\nuniform float furTime;\nuniform float furSpacing;\nuniform float furDensity;\n#endif\n#ifdef HEIGHTMAP\nuniform sampler2D heightTexture;\n#endif\n#ifdef HIGHLEVEL\nvarying vec2 vFurUV;\n#endif\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\nvarying float vfur_length;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nfloat Rand(vec3 rv) {\nfloat x=dot(rv,vec3(12.9898,78.233,24.65487));\nreturn fract(sin(x)*43758.5453);\n}\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\n\nfloat r=Rand(position);\n#ifdef HEIGHTMAP\n#if __VERSION__>100\nvfur_length=furLength*texture(heightTexture,uv).x;\n#else\nvfur_length=furLength*texture2D(heightTexture,uv).r;\n#endif\n#else\nvfur_length=(furLength*r);\n#endif\nvec3 tangent1=vec3(normal.y,-normal.x,0);\nvec3 tangent2=vec3(-normal.z,0,normal.x);\nr=Rand(tangent1*r);\nfloat J=(2.0+4.0*r);\nr=Rand(tangent2*r);\nfloat K=(2.0+2.0*r);\ntangent1=tangent1*J+tangent2*K;\ntangent1=normalize(tangent1);\nvec3 newPosition=position+normal*vfur_length*cos(furAngle)+tangent1*vfur_length*sin(furAngle);\n#ifdef HIGHLEVEL\n\nvec3 forceDirection=vec3(0.0,0.0,0.0);\nforceDirection.x=sin(furTime+position.x*0.05)*0.2;\nforceDirection.y=cos(furTime*0.7+position.y*0.04)*0.2;\nforceDirection.z=sin(furTime*0.7+position.z*0.04)*0.2;\nvec3 displacement=vec3(0.0,0.0,0.0);\ndisplacement=furGravity+forceDirection;\nfloat displacementFactor=pow(furOffset,3.0);\nvec3 aNormal=normal;\naNormal.xyz+=displacement*displacementFactor;\nnewPosition=vec3(newPosition.x,newPosition.y,newPosition.z)+(normalize(aNormal)*furOffset*furSpacing);\n#endif\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\ngl_Position=viewProjection*finalWorld*vec4(newPosition,1.0);\nvec4 worldPos=finalWorld*vec4(newPosition,1.0);\nvPositionW=vec3(worldPos);\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#ifdef HIGHLEVEL\nvFurUV=vDiffuseUV*furDensity;\n#endif\n#else\n#ifdef HIGHLEVEL\nvFurUV=uv*furDensity;\n#endif\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var furVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nimport \"./fur.fragment\";\r\nimport \"./fur.vertex\";\r\n\r\nclass FurMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public HEIGHTMAP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public HIGHLEVEL = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FurMaterial extends PushMaterial {\r\n\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"heightTexture\")\r\n    private _heightTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public heightTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public furLength: number = 1;\r\n\r\n    @serialize()\r\n    public furAngle: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public furColor = new Color3(0.44, 0.21, 0.02);\r\n\r\n    @serialize()\r\n    public furOffset: number = 0.0;\r\n\r\n    @serialize()\r\n    public furSpacing: number = 12;\r\n\r\n    @serializeAsVector3()\r\n    public furGravity = new Vector3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public furSpeed: number = 100;\r\n\r\n    @serialize()\r\n    public furDensity: number = 20;\r\n\r\n    @serialize()\r\n    public furOcclusion: number = 0.0;\r\n\r\n    public furTexture: DynamicTexture;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize()\r\n    public highLevelFur: boolean = true;\r\n\r\n    public _meshes: AbstractMesh[];\r\n\r\n    private _renderId: number;\r\n\r\n    private _furTime: number = 0;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    @serialize()\r\n    public get furTime() {\r\n        return this._furTime;\r\n    }\r\n\r\n    public set furTime(furTime: number) {\r\n        this._furTime = furTime;\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public updateFur(): void {\r\n        for (var i = 1; i < this._meshes.length; i++) {\r\n            var offsetFur = <FurMaterial>this._meshes[i].material;\r\n\r\n            offsetFur.furLength = this.furLength;\r\n            offsetFur.furAngle = this.furAngle;\r\n            offsetFur.furGravity = this.furGravity;\r\n            offsetFur.furSpacing = this.furSpacing;\r\n            offsetFur.furSpeed = this.furSpeed;\r\n            offsetFur.furColor = this.furColor;\r\n            offsetFur.diffuseTexture = this.diffuseTexture;\r\n            offsetFur.furTexture = this.furTexture;\r\n            offsetFur.highLevelFur = this.highLevelFur;\r\n            offsetFur.furTime = this.furTime;\r\n            offsetFur.furDensity = this.furDensity;\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new FurMaterialDefines();\r\n        }\r\n\r\n        var defines = <FurMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this.diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n                if (this.heightTexture && engine.getCaps().maxVertexTextureImageUnits) {\r\n                    if (!this.heightTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.HEIGHTMAP = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        if (this.highLevelFur !== defines.HIGHLEVEL) {\r\n            defines.HIGHLEVEL = true;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"fur\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\",\r\n                \"furLength\", \"furAngle\", \"furColor\", \"furOffset\", \"furGravity\", \"furTime\", \"furSpacing\", \"furDensity\", \"furOcclusion\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\",\r\n                \"heightTexture\", \"furTexture\"\r\n            ];\r\n\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <FurMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (scene.getCachedMaterial() !== this) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this._heightTexture) {\r\n                this._activeEffect.setTexture(\"heightTexture\", this._heightTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"furLength\", this.furLength);\r\n        this._activeEffect.setFloat(\"furAngle\", this.furAngle);\r\n        this._activeEffect.setColor4(\"furColor\", this.furColor, 1.0);\r\n\r\n        if (this.highLevelFur) {\r\n            this._activeEffect.setVector3(\"furGravity\", this.furGravity);\r\n            this._activeEffect.setFloat(\"furOffset\", this.furOffset);\r\n            this._activeEffect.setFloat(\"furSpacing\", this.furSpacing);\r\n            this._activeEffect.setFloat(\"furDensity\", this.furDensity);\r\n            this._activeEffect.setFloat(\"furOcclusion\", this.furOcclusion);\r\n\r\n            this._furTime += this.getScene().getEngine().getDeltaTime() / this.furSpeed;\r\n            this._activeEffect.setFloat(\"furTime\", this._furTime);\r\n\r\n            this._activeEffect.setTexture(\"furTexture\", this.furTexture);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.heightTexture && this.heightTexture.animations && this.heightTexture.animations.length > 0) {\r\n            results.push(this.heightTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._heightTexture) {\r\n            activeTextures.push(this._heightTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._heightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        if (this._meshes) {\r\n            for (var i = 1; i < this._meshes.length; i++) {\r\n                let mat = this._meshes[i].material;\r\n\r\n                if (mat) {\r\n                    mat.dispose(forceDisposeEffect);\r\n                }\r\n                this._meshes[i].dispose();\r\n            }\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FurMaterial {\r\n        return SerializationHelper.Clone(() => new FurMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.FurMaterial\";\r\n\r\n        if (this._meshes) {\r\n            serializationObject.sourceMeshName = this._meshes[0].name;\r\n            serializationObject.quality = this._meshes.length;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FurMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FurMaterial {\r\n        var material = SerializationHelper.Parse(() => new FurMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.sourceMeshName && material.highLevelFur) {\r\n            scene.executeWhenReady(() => {\r\n                var sourceMesh = <Mesh>scene.getMeshByName(source.sourceMeshName);\r\n                if (sourceMesh) {\r\n                    var furTexture = FurMaterial.GenerateTexture(\"Fur Texture\", scene);\r\n                    material.furTexture = furTexture;\r\n                    FurMaterial.FurifyMesh(sourceMesh, source.quality);\r\n                }\r\n            });\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    public static GenerateTexture(name: string, scene: Scene): DynamicTexture {\r\n        // Generate fur textures\r\n        var texture = new DynamicTexture(\"FurTexture \" + name, 256, scene, true);\r\n        var context = texture.getContext();\r\n\r\n        for (var i = 0; i < 20000; ++i) {\r\n            context.fillStyle = \"rgba(255, \" + Math.floor(Math.random() * 255) + \", \" + Math.floor(Math.random() * 255) + \", 1)\";\r\n            context.fillRect((Math.random() * texture.getSize().width), (Math.random() * texture.getSize().height), 2, 2);\r\n        }\r\n\r\n        texture.update(false);\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n\r\n        return texture;\r\n    }\r\n\r\n    // Creates and returns an array of meshes used as shells for the Fur Material\r\n    // that can be disposed later in your code\r\n    // The quality is in interval [0, 100]\r\n    public static FurifyMesh(sourceMesh: Mesh, quality: number): Mesh[] {\r\n        var meshes = [sourceMesh];\r\n        var mat: FurMaterial = <FurMaterial>sourceMesh.material;\r\n        var i;\r\n\r\n        if (!(mat instanceof FurMaterial)) {\r\n            throw \"The material of the source mesh must be a Fur Material\";\r\n        }\r\n\r\n        for (i = 1; i < quality; i++) {\r\n            var offsetFur = new FurMaterial(mat.name + i, sourceMesh.getScene());\r\n            sourceMesh.getScene().materials.pop();\r\n            Tags.EnableFor(offsetFur);\r\n            Tags.AddTagsTo(offsetFur, \"furShellMaterial\");\r\n\r\n            offsetFur.furLength = mat.furLength;\r\n            offsetFur.furAngle = mat.furAngle;\r\n            offsetFur.furGravity = mat.furGravity;\r\n            offsetFur.furSpacing = mat.furSpacing;\r\n            offsetFur.furSpeed = mat.furSpeed;\r\n            offsetFur.furColor = mat.furColor;\r\n            offsetFur.diffuseTexture = mat.diffuseTexture;\r\n            offsetFur.furOffset = i / quality;\r\n            offsetFur.furTexture = mat.furTexture;\r\n            offsetFur.highLevelFur = mat.highLevelFur;\r\n            offsetFur.furTime = mat.furTime;\r\n            offsetFur.furDensity = mat.furDensity;\r\n\r\n            var offsetMesh = sourceMesh.clone(sourceMesh.name + i) as Mesh;\r\n\r\n            offsetMesh.material = offsetFur;\r\n            offsetMesh.skeleton = sourceMesh.skeleton;\r\n            offsetMesh.position = Vector3.Zero();\r\n            meshes.push(offsetMesh);\r\n        }\r\n\r\n        for (i = 1; i < meshes.length; i++) {\r\n            meshes[i].parent = sourceMesh;\r\n        }\r\n\r\n        (<FurMaterial>sourceMesh.material)._meshes = meshes;\r\n\r\n        return meshes;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.FurMaterial\"] = FurMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'gradientPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\n\nuniform vec4 topColor;\nuniform vec4 bottomColor;\nuniform float offset;\nuniform float scale;\nuniform float smoothness;\n\nvarying vec3 vPositionW;\nvarying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\nfloat h=vPosition.y*scale+offset;\nfloat mysmoothness=clamp(smoothness,0.01,max(smoothness,10.));\nvec4 baseColor=mix(bottomColor,topColor,max(pow(max(h,0.0),mysmoothness),0.0));\n\nvec3 diffuseColor=baseColor.rgb;\n\nfloat alpha=baseColor.a;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\n#ifdef EMISSIVE\nvec3 diffuseBase=baseColor.rgb;\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);\n#endif\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n\nvec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var gradientPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'gradientVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\nvarying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\nvPosition=position;\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var gradientVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./gradient.fragment\";\r\nimport \"./gradient.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass GradientMaterialDefines extends MaterialDefines {\r\n    public EMISSIVE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class GradientMaterial extends PushMaterial {\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    // The gradient top color, red by default\r\n    @serializeAsColor3()\r\n    public topColor = new Color3(1, 0, 0);\r\n\r\n    @serialize()\r\n    public topColorAlpha = 1.0;\r\n\r\n    // The gradient top color, blue by default\r\n    @serializeAsColor3()\r\n    public bottomColor = new Color3(0, 0, 1);\r\n\r\n    @serialize()\r\n    public bottomColorAlpha = 1.0;\r\n\r\n    // Gradient offset\r\n    @serialize()\r\n    public offset = 0;\r\n\r\n    @serialize()\r\n    public scale = 1.0;\r\n\r\n    @serialize()\r\n    public smoothness = 1.0;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0 || this.topColorAlpha < 1.0 || this.bottomColorAlpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new GradientMaterialDefines();\r\n        }\r\n\r\n        var defines = <GradientMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        defines.EMISSIVE = this._disableLighting;\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"gradient\";\r\n            var join = defines.toString();\r\n\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\",\r\n                \"topColor\", \"bottomColor\", \"offset\", \"smoothness\", \"scale\"\r\n            ];\r\n            var samplers: string[] = [];\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: 4 }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <GradientMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(effect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setColor4(\"topColor\", this.topColor, this.topColorAlpha);\r\n        this._activeEffect.setColor4(\"bottomColor\", this.bottomColor, this.bottomColorAlpha);\r\n        this._activeEffect.setFloat(\"offset\", this.offset);\r\n        this._activeEffect.setFloat(\"scale\", this.scale);\r\n        this._activeEffect.setFloat(\"smoothness\", this.smoothness);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GradientMaterial {\r\n        return SerializationHelper.Clone(() => new GradientMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GradientMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GradientMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GradientMaterial {\r\n        return SerializationHelper.Parse(() => new GradientMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.GradientMaterial\"] = GradientMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'gridPixelShader';\nlet shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\nuniform vec3 mainColor;\nuniform vec3 lineColor;\nuniform vec4 gridControl;\nuniform vec3 gridOffset;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n#include<fogFragmentDeclaration>\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\nfloat getVisibility(float position) {\n\nfloat majorGridFrequency=gridControl.y;\nif (floor(position+0.5) == floor(position/majorGridFrequency+0.5)*majorGridFrequency)\n{\nreturn 1.0;\n}\nreturn gridControl.z;\n}\nfloat getAnisotropicAttenuation(float differentialLength) {\nconst float maxNumberOfLines=10.0;\nreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\n}\nfloat isPointOnLine(float position,float differentialLength) {\nfloat fractionPartOfPosition=position-floor(position+0.5);\nfractionPartOfPosition/=differentialLength;\nfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\nfloat result=0.5+0.5*cos(fractionPartOfPosition*PI);\nreturn result;\n}\nfloat contributionOnAxis(float position) {\nfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\ndifferentialLength*=SQRT2;\n\nfloat result=isPointOnLine(position,differentialLength);\n\nfloat visibility=getVisibility(position);\nresult*=visibility;\n\nfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\nresult*=anisotropicAttenuation;\nreturn result;\n}\nfloat normalImpactOnAxis(float x) {\nfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\nreturn normalImpact;\n}\nvoid main(void) {\n\nfloat gridRatio=gridControl.x;\nvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\n\nfloat x=contributionOnAxis(gridPos.x);\nfloat y=contributionOnAxis(gridPos.y);\nfloat z=contributionOnAxis(gridPos.z);\n\nvec3 normal=normalize(vNormal);\nx*=normalImpactOnAxis(normal.x);\ny*=normalImpactOnAxis(normal.y);\nz*=normalImpactOnAxis(normal.z);\n\nfloat grid=clamp(x+y+z,0.,1.);\n\nvec3 color=mix(mainColor,lineColor,grid);\n#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\n#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\n#endif\n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\n#endif\n\ngl_FragColor=vec4(color.rgb,opacity);\n#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\n#endif\n#else\n#endif\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var gridPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\n\nlet name = 'gridVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#include<instancesDeclaration>\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\nvoid main(void) {\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;\ngl_Position=projection*cameraSpacePosition;\n#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\nvPosition=position;\nvNormal=normal;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var gridVertexShader = { name, shader };\n","import { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix, Vector4, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public OPACITY = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    private _renderId: number;\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Returns wehter or not the grid requires alpha blending.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || this._opacityTexture && this._opacityTexture.isReady();\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return this.needAlphaBlending();\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        var defines = <GridMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== (this.opacity < 1.0)) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Defines\r\n            var join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(\"grid\",\r\n                attribs,\r\n                [\"projection\", \"mainColor\", \"lineColor\", \"gridControl\", \"gridOffset\", \"vFogInfos\", \"vFogColor\", \"world\", \"view\",\r\n                    \"opacityMatrix\", \"vOpacityInfos\"],\r\n                [\"opacitySampler\"],\r\n                join,\r\n                undefined,\r\n                this.onCompiled,\r\n                this.onError), defines);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <GridMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n        }\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.GridMaterial\"] = GridMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'lavaPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n\nvarying vec3 vPositionW;\n\nuniform float time;\nuniform float speed;\nuniform float movingSpeed;\nuniform vec3 fogColor;\nuniform sampler2D noiseTexture;\nuniform float fogDensity;\n\nvarying float noise;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nfloat random( vec3 scale,float seed ){\nreturn fract( sin( dot( gl_FragCoord.xyz+seed,scale ) )*43758.5453+seed ) ;\n}\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\n\nvec4 noiseTex=texture2D( noiseTexture,vDiffuseUV );\nvec2 T1=vDiffuseUV+vec2( 1.5,-1.5 )*time*0.02;\nvec2 T2=vDiffuseUV+vec2( -0.5,2.0 )*time*0.01*speed;\nT1.x+=noiseTex.x*2.0;\nT1.y+=noiseTex.y*2.0;\nT2.x-=noiseTex.y*0.2+time*0.001*movingSpeed;\nT2.y+=noiseTex.z*0.2+time*0.002*movingSpeed;\nfloat p=texture2D( noiseTexture,T1*3.0 ).a;\nvec4 lavaColor=texture2D( diffuseSampler,T2*4.0);\nvec4 temp=lavaColor*( vec4( p,p,p,p )*2. )+( lavaColor*lavaColor-0.1 );\nbaseColor=temp;\nfloat depth=gl_FragCoord.z*4.0;\nconst float LOG2=1.442695;\nfloat fogFactor=exp2(-fogDensity*fogDensity*depth*depth*LOG2 );\nfogFactor=1.0-clamp( fogFactor,0.0,1.0 );\nbaseColor=mix( baseColor,vec4( fogColor,baseColor.w ),fogFactor );\ndiffuseColor=baseColor.rgb;\n\n\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n\nvec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var lavaPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'lavaVertexShader';\nlet shader = `precision highp float;\n\nuniform float time;\nuniform float lowFrequencySpeed;\n\nvarying float noise;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n\n\nvec3 mod289(vec3 x)\n{\nreturn x-floor(x*(1.0/289.0))*289.0;\n}\nvec4 mod289(vec4 x)\n{\nreturn x-floor(x*(1.0/289.0))*289.0;\n}\nvec4 permute(vec4 x)\n{\nreturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159-0.85373472095314*r;\n}\nvec3 fade(vec3 t) {\nreturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise(vec3 P,vec3 rep)\n{\nvec3 Pi0=mod(floor(P),rep);\nvec3 Pi1=mod(Pi0+vec3(1.0),rep);\nPi0=mod289(Pi0);\nPi1=mod289(Pi1);\nvec3 Pf0=fract(P);\nvec3 Pf1=Pf0-vec3(1.0);\nvec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);\nvec4 iy=vec4(Pi0.yy,Pi1.yy);\nvec4 iz0=Pi0.zzzz;\nvec4 iz1=Pi1.zzzz;\nvec4 ixy=permute(permute(ix)+iy);\nvec4 ixy0=permute(ixy+iz0);\nvec4 ixy1=permute(ixy+iz1);\nvec4 gx0=ixy0*(1.0/7.0);\nvec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;\ngx0=fract(gx0);\nvec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);\nvec4 sz0=step(gz0,vec4(0.0));\ngx0-=sz0*(step(0.0,gx0)-0.5);\ngy0-=sz0*(step(0.0,gy0)-0.5);\nvec4 gx1=ixy1*(1.0/7.0);\nvec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;\ngx1=fract(gx1);\nvec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);\nvec4 sz1=step(gz1,vec4(0.0));\ngx1-=sz1*(step(0.0,gx1)-0.5);\ngy1-=sz1*(step(0.0,gy1)-0.5);\nvec3 g000=vec3(gx0.x,gy0.x,gz0.x);\nvec3 g100=vec3(gx0.y,gy0.y,gz0.y);\nvec3 g010=vec3(gx0.z,gy0.z,gz0.z);\nvec3 g110=vec3(gx0.w,gy0.w,gz0.w);\nvec3 g001=vec3(gx1.x,gy1.x,gz1.x);\nvec3 g101=vec3(gx1.y,gy1.y,gz1.y);\nvec3 g011=vec3(gx1.z,gy1.z,gz1.z);\nvec3 g111=vec3(gx1.w,gy1.w,gz1.w);\nvec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\ng000*=norm0.x;\ng010*=norm0.y;\ng100*=norm0.z;\ng110*=norm0.w;\nvec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\ng001*=norm1.x;\ng011*=norm1.y;\ng101*=norm1.z;\ng111*=norm1.w;\nfloat n000=dot(g000,Pf0);\nfloat n100=dot(g100,vec3(Pf1.x,Pf0.yz));\nfloat n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));\nfloat n110=dot(g110,vec3(Pf1.xy,Pf0.z));\nfloat n001=dot(g001,vec3(Pf0.xy,Pf1.z));\nfloat n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));\nfloat n011=dot(g011,vec3(Pf0.x,Pf1.yz));\nfloat n111=dot(g111,Pf1);\nvec3 fade_xyz=fade(Pf0);\nvec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\nvec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);\nfloat n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);\nreturn 2.2*n_xyz;\n}\n\nfloat turbulence( vec3 p ) {\nfloat w=100.0;\nfloat t=-.5;\nfor (float f=1.0 ; f<=10.0 ; f++ ){\nfloat power=pow( 2.0,f );\nt+=abs( pnoise( vec3( power*p ),vec3( 10.0,10.0,10.0 ) )/power );\n}\nreturn t;\n}\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef NORMAL\n\nnoise=10.0*-.10*turbulence( .5*normal+time*1.15 );\n\nfloat b=lowFrequencySpeed*5.0*pnoise( 0.05*position +vec3(time*1.025),vec3( 100.0 ) );\n\nfloat displacement =-1.5*noise+b;\n\nvec3 newPosition=position+normal*displacement;\ngl_Position=viewProjection*finalWorld*vec4( newPosition,1.0 );\nvec4 worldPos=finalWorld*vec4(newPosition,1.0);\nvPositionW=vec3(worldPos);\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var lavaVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\n\nimport \"./lava.fragment\";\nimport \"./lava.vertex\";\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\n\nclass LavaMaterialDefines extends MaterialDefines {\n    public DIFFUSE = false;\n    public CLIPPLANE = false;\n    public CLIPPLANE2 = false;\n    public CLIPPLANE3 = false;\n    public CLIPPLANE4 = false;\n    public CLIPPLANE5 = false;\n    public CLIPPLANE6 = false;\n    public ALPHATEST = false;\n    public DEPTHPREPASS = false;\n    public POINTSIZE = false;\n    public FOG = false;\n    public LIGHT0 = false;\n    public LIGHT1 = false;\n    public LIGHT2 = false;\n    public LIGHT3 = false;\n    public SPOTLIGHT0 = false;\n    public SPOTLIGHT1 = false;\n    public SPOTLIGHT2 = false;\n    public SPOTLIGHT3 = false;\n    public HEMILIGHT0 = false;\n    public HEMILIGHT1 = false;\n    public HEMILIGHT2 = false;\n    public HEMILIGHT3 = false;\n    public DIRLIGHT0 = false;\n    public DIRLIGHT1 = false;\n    public DIRLIGHT2 = false;\n    public DIRLIGHT3 = false;\n    public POINTLIGHT0 = false;\n    public POINTLIGHT1 = false;\n    public POINTLIGHT2 = false;\n    public POINTLIGHT3 = false;\n    public SHADOW0 = false;\n    public SHADOW1 = false;\n    public SHADOW2 = false;\n    public SHADOW3 = false;\n    public SHADOWS = false;\n    public SHADOWESM0 = false;\n    public SHADOWESM1 = false;\n    public SHADOWESM2 = false;\n    public SHADOWESM3 = false;\n    public SHADOWPOISSON0 = false;\n    public SHADOWPOISSON1 = false;\n    public SHADOWPOISSON2 = false;\n    public SHADOWPOISSON3 = false;\n    public SHADOWPCF0 = false;\n    public SHADOWPCF1 = false;\n    public SHADOWPCF2 = false;\n    public SHADOWPCF3 = false;\n    public SHADOWPCSS0 = false;\n    public SHADOWPCSS1 = false;\n    public SHADOWPCSS2 = false;\n    public SHADOWPCSS3 = false;\n    public NORMAL = false;\n    public UV1 = false;\n    public UV2 = false;\n    public VERTEXCOLOR = false;\n    public VERTEXALPHA = false;\n    public NUM_BONE_INFLUENCERS = 0;\n    public BonesPerMesh = 0;\n    public INSTANCES = false;\n    public UNLIT = false;\n\n    constructor() {\n        super();\n        this.rebuild();\n    }\n}\n\nexport class LavaMaterial extends PushMaterial {\n    @serializeAsTexture(\"diffuseTexture\")\n    private _diffuseTexture: BaseTexture;\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    public diffuseTexture: BaseTexture;\n\n    @serializeAsTexture()\n    public noiseTexture: BaseTexture;\n\n    @serializeAsColor3()\n    public fogColor: Color3;\n\n    @serialize()\n    public speed: number = 1;\n\n    @serialize()\n    public movingSpeed: number = 1;\n\n    @serialize()\n    public lowFrequencySpeed: number = 1;\n\n    @serialize()\n    public fogDensity: number = 0.15;\n\n    private _lastTime: number = 0;\n\n    @serializeAsColor3()\n    public diffuseColor = new Color3(1, 1, 1);\n\n    @serialize(\"disableLighting\")\n    private _disableLighting = false;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public disableLighting: boolean;\n\n    @serialize(\"unlit\")\n    private _unlit = false;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public unlit: boolean;\n\n    @serialize(\"maxSimultaneousLights\")\n    private _maxSimultaneousLights = 4;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public maxSimultaneousLights: number;\n\n    private _scaledDiffuse = new Color3();\n    private _renderId: number;\n\n    constructor(name: string, scene: Scene) {\n        super(name, scene);\n    }\n\n    public needAlphaBlending(): boolean {\n        return (this.alpha < 1.0);\n    }\n\n    public needAlphaTesting(): boolean {\n        return false;\n    }\n\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\n        return null;\n    }\n\n    // Methods\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\n                return true;\n            }\n        }\n\n        if (!subMesh._materialDefines) {\n            subMesh._materialDefines = new LavaMaterialDefines();\n        }\n\n        var defines = <LavaMaterialDefines>subMesh._materialDefines;\n        var scene = this.getScene();\n\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\n            if (this._renderId === scene.getRenderId()) {\n                return true;\n            }\n        }\n\n        var engine = scene.getEngine();\n\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                    if (!this._diffuseTexture.isReady()) {\n                        return false;\n                    } else {\n                        defines._needUVs = true;\n                        defines.DIFFUSE = true;\n                    }\n                }\n            }\n        }\n\n        // Misc.\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n\n        // Lights\n        defines._needNormals = true;\n\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\n\n        // Values that need to be evaluated on every frame\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\n\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\n\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n\n            // Fallbacks\n            var fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\n\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n\n            //Attributes\n            var attribs = [VertexBuffer.PositionKind];\n\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n\n            if (defines.VERTEXCOLOR) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n\n            // Legacy browser patch\n            var shaderName = \"lava\";\n            var join = defines.toString();\n\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\",\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\n                \"vDiffuseInfos\",\n                \"mBones\",\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\",\n                \"time\", \"speed\", \"movingSpeed\",\n                \"fogColor\", \"fogDensity\", \"lowFrequencySpeed\"\n            ];\n\n            var samplers = [\"diffuseSampler\",\n                \"noiseTexture\"\n            ];\n            var uniformBuffers = new Array<string>();\n\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: this.maxSimultaneousLights\n            });\n\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\n                <IEffectCreationOptions>{\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: this.onCompiled,\n                    onError: this.onError,\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }\n                }, engine), defines);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n\n        this._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n\n        return true;\n    }\n\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\n        var scene = this.getScene();\n\n        var defines = <LavaMaterialDefines>subMesh._materialDefines;\n        if (!defines) {\n            return;\n        }\n\n        var effect = subMesh.effect;\n\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n\n        defines.UNLIT = this._unlit;\n\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n\n        if (this._mustRebind(scene, effect)) {\n            // Textures\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\n\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\n            }\n\n            if (this.noiseTexture) {\n                this._activeEffect.setTexture(\"noiseTexture\", this.noiseTexture);\n            }\n\n            // Clip plane\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\n\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n\n            MaterialHelper.BindEyePosition(effect, scene);\n        }\n\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\n\n        if (scene.lightsEnabled && !this.disableLighting) {\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines);\n        }\n\n        // View\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n\n        this._lastTime += scene.getEngine().getDeltaTime();\n        this._activeEffect.setFloat(\"time\", this._lastTime * this.speed / 1000);\n\n        if (!this.fogColor) {\n            this.fogColor = Color3.Black();\n        }\n        this._activeEffect.setColor3(\"fogColor\", this.fogColor);\n        this._activeEffect.setFloat(\"fogDensity\", this.fogDensity);\n\n        this._activeEffect.setFloat(\"lowFrequencySpeed\", this.lowFrequencySpeed);\n        this._activeEffect.setFloat(\"movingSpeed\", this.movingSpeed);\n\n        this._afterBind(mesh, this._activeEffect);\n    }\n\n    public getAnimatables(): IAnimatable[] {\n        var results = [];\n\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\n            results.push(this.diffuseTexture);\n        }\n\n        if (this.noiseTexture && this.noiseTexture.animations && this.noiseTexture.animations.length > 0) {\n            results.push(this.noiseTexture);\n        }\n\n        return results;\n    }\n\n    public getActiveTextures(): BaseTexture[] {\n        var activeTextures = super.getActiveTextures();\n\n        if (this._diffuseTexture) {\n            activeTextures.push(this._diffuseTexture);\n        }\n\n        return activeTextures;\n    }\n\n    public hasTexture(texture: BaseTexture): boolean {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n\n        if (this.diffuseTexture === texture) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public dispose(forceDisposeEffect?: boolean): void {\n        if (this.diffuseTexture) {\n            this.diffuseTexture.dispose();\n        }\n        if (this.noiseTexture) {\n            this.noiseTexture.dispose();\n        }\n\n        super.dispose(forceDisposeEffect);\n    }\n\n    public clone(name: string): LavaMaterial {\n        return SerializationHelper.Clone(() => new LavaMaterial(name, this.getScene()), this);\n    }\n\n    public serialize(): any {\n        var serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.customType = \"BABYLON.LavaMaterial\";\n        return serializationObject;\n    }\n\n    public getClassName(): string {\n        return \"LavaMaterial\";\n    }\n\n    // Statics\n    public static Parse(source: any, scene: Scene, rootUrl: string): LavaMaterial {\n        return SerializationHelper.Parse(() => new LavaMaterial(source.name, scene), source, scene, rootUrl);\n    }\n}\n\n_TypeStore.RegisteredTypes[\"BABYLON.LavaMaterial\"] = LavaMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'mixPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\nuniform sampler2D mixMap1Sampler;\nuniform vec2 vTextureInfos;\n#ifdef MIXMAP2\nuniform sampler2D mixMap2Sampler;\n#endif\nuniform sampler2D diffuse1Sampler;\nuniform sampler2D diffuse2Sampler;\nuniform sampler2D diffuse3Sampler;\nuniform sampler2D diffuse4Sampler;\nuniform vec2 diffuse1Infos;\nuniform vec2 diffuse2Infos;\nuniform vec2 diffuse3Infos;\nuniform vec2 diffuse4Infos;\n#ifdef MIXMAP2\nuniform sampler2D diffuse5Sampler;\nuniform sampler2D diffuse6Sampler;\nuniform sampler2D diffuse7Sampler;\nuniform sampler2D diffuse8Sampler;\nuniform vec2 diffuse5Infos;\nuniform vec2 diffuse6Infos;\nuniform vec2 diffuse7Infos;\nuniform vec2 diffuse8Infos;\n#endif\n#endif\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 finalMixColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef MIXMAP2\nvec4 mixColor2=vec4(1.,1.,1.,1.);\n#endif\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nvec4 mixColor=texture2D(mixMap1Sampler,vTextureUV);\n#include<depthPrePass>\nmixColor.rgb*=vTextureInfos.y;\nvec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);\nvec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);\nvec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);\nvec4 diffuse4Color=texture2D(diffuse4Sampler,vTextureUV*diffuse4Infos);\ndiffuse1Color.rgb*=mixColor.r;\ndiffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,mixColor.g);\ndiffuse3Color.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,mixColor.b);\nfinalMixColor.rgb=mix(diffuse3Color.rgb,diffuse4Color.rgb,1.0-mixColor.a);\n#ifdef MIXMAP2\nmixColor=texture2D(mixMap2Sampler,vTextureUV);\nmixColor.rgb*=vTextureInfos.y;\nvec4 diffuse5Color=texture2D(diffuse5Sampler,vTextureUV*diffuse5Infos);\nvec4 diffuse6Color=texture2D(diffuse6Sampler,vTextureUV*diffuse6Infos);\nvec4 diffuse7Color=texture2D(diffuse7Sampler,vTextureUV*diffuse7Infos);\nvec4 diffuse8Color=texture2D(diffuse8Sampler,vTextureUV*diffuse8Infos);\ndiffuse5Color.rgb=mix(finalMixColor.rgb,diffuse5Color.rgb,mixColor.r);\ndiffuse6Color.rgb=mix(diffuse5Color.rgb,diffuse6Color.rgb,mixColor.g);\ndiffuse7Color.rgb=mix(diffuse6Color.rgb,diffuse7Color.rgb,mixColor.b);\nfinalMixColor.rgb=mix(diffuse7Color.rgb,diffuse8Color.rgb,1.0-mixColor.a);\n#endif\n#endif\n#ifdef VERTEXCOLOR\nfinalMixColor.rgb*=vColor.rgb;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*finalMixColor.rgb,0.0,1.0);\n\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var mixPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'mixVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\nuniform mat4 textureMatrix;\nuniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x == 0.)\n{\nvTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var mixVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./mix.fragment\";\r\nimport \"./mix.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass MixMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public MIXMAP2 = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class MixMaterial extends PushMaterial {\r\n    /**\r\n     * Mix textures\r\n     */\r\n\r\n    @serializeAsTexture(\"mixTexture1\")\r\n    private _mixTexture1: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture1: BaseTexture;\r\n\r\n    @serializeAsTexture(\"mixTexture2\")\r\n    private _mixTexture2: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture2: BaseTexture;\r\n\r\n    /**\r\n     * Diffuse textures\r\n     */\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture4: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture4: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture5: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture5: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture6: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture6: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture7: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture7: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture8: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture8: Texture;\r\n\r\n    /**\r\n     * Uniforms\r\n     */\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new MixMaterialDefines();\r\n        }\r\n\r\n        var defines = <MixMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this._mixTexture1 || !this._mixTexture1.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture1 || !this._diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n\r\n                if (!this._diffuseTexture2 || !this._diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture3 || !this._diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture4 || !this._diffuseTexture4.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                if (this._mixTexture2) {\r\n                    if (!this._mixTexture2.isReady()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.MIXMAP2 = true;\r\n\r\n                    if (!this._diffuseTexture5 || !this._diffuseTexture5.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture6 || !this._diffuseTexture6.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture7 || !this._diffuseTexture7.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture8 || !this._diffuseTexture8.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"mix\";\r\n            var join = defines.toString();\r\n            var uniforms = [\r\n                \"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\", \"vSpecularColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMatrix\",\r\n                \"diffuse1Infos\", \"diffuse2Infos\", \"diffuse3Infos\", \"diffuse4Infos\",\r\n                \"diffuse5Infos\", \"diffuse6Infos\", \"diffuse7Infos\", \"diffuse8Infos\"\r\n            ];\r\n            var samplers = [\r\n                \"mixMap1Sampler\", \"mixMap2Sampler\",\r\n                \"diffuse1Sampler\", \"diffuse2Sampler\", \"diffuse3Sampler\", \"diffuse4Sampler\",\r\n                \"diffuse5Sampler\", \"diffuse6Sampler\", \"diffuse7Sampler\", \"diffuse8Sampler\"\r\n            ];\r\n\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <MixMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._mixTexture1) {\r\n                this._activeEffect.setTexture(\"mixMap1Sampler\", this._mixTexture1);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture1.coordinatesIndex, this._mixTexture1.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture1.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                    if (this._diffuseTexture4) {\r\n                        this._activeEffect.setTexture(\"diffuse4Sampler\", this._diffuseTexture4);\r\n                        this._activeEffect.setFloat2(\"diffuse4Infos\", this._diffuseTexture4.uScale, this._diffuseTexture4.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._mixTexture2) {\r\n                this._activeEffect.setTexture(\"mixMap2Sampler\", this._mixTexture2);\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture5) {\r\n                        this._activeEffect.setTexture(\"diffuse5Sampler\", this._diffuseTexture5);\r\n                        this._activeEffect.setFloat2(\"diffuse5Infos\", this._diffuseTexture5.uScale, this._diffuseTexture5.vScale);\r\n                    }\r\n                    if (this._diffuseTexture6) {\r\n                        this._activeEffect.setTexture(\"diffuse6Sampler\", this._diffuseTexture6);\r\n                        this._activeEffect.setFloat2(\"diffuse6Infos\", this._diffuseTexture6.uScale, this._diffuseTexture6.vScale);\r\n                    }\r\n                    if (this._diffuseTexture7) {\r\n                        this._activeEffect.setTexture(\"diffuse7Sampler\", this._diffuseTexture7);\r\n                        this._activeEffect.setFloat2(\"diffuse7Infos\", this._diffuseTexture7.uScale, this._diffuseTexture7.vScale);\r\n                    }\r\n                    if (this._diffuseTexture8) {\r\n                        this._activeEffect.setTexture(\"diffuse8Sampler\", this._diffuseTexture8);\r\n                        this._activeEffect.setFloat2(\"diffuse8Infos\", this._diffuseTexture8.uScale, this._diffuseTexture8.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this._mixTexture1 && this._mixTexture1.animations && this._mixTexture1.animations.length > 0) {\r\n            results.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._mixTexture2 && this._mixTexture2.animations && this._mixTexture2.animations.length > 0) {\r\n            results.push(this._mixTexture2);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1) {\r\n            activeTextures.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._diffuseTexture4) {\r\n            activeTextures.push(this._diffuseTexture4);\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2) {\r\n            activeTextures.push(this._mixTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture5) {\r\n            activeTextures.push(this._diffuseTexture5);\r\n        }\r\n\r\n        if (this._diffuseTexture6) {\r\n            activeTextures.push(this._diffuseTexture6);\r\n        }\r\n\r\n        if (this._diffuseTexture7) {\r\n            activeTextures.push(this._diffuseTexture7);\r\n        }\r\n\r\n        if (this._diffuseTexture8) {\r\n            activeTextures.push(this._diffuseTexture8);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture4 === texture) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture5 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture6 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture7 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture8 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._mixTexture1) {\r\n            this._mixTexture1.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): MixMaterial {\r\n        return SerializationHelper.Clone(() => new MixMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.MixMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"MixMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): MixMaterial {\r\n        return SerializationHelper.Parse(() => new MixMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.MixMaterial\"] = MixMaterial;\r\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'normalPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef LIGHTING\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#endif\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef NORMAL\nbaseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\n#ifdef LIGHTING\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=baseColor.rgb;\n#endif\n\nvec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var normalPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'normalVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var normalVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./normal.fragment\";\r\nimport \"./normal.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass NormalMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public LIGHTING = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class NormalMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return this.needAlphaBlending() || (mesh.visibility < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new NormalMaterialDefines();\r\n        }\r\n\r\n        var defines = <NormalMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        defines.LIGHTING = !this._disableLighting;\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            var shaderName = \"normal\";\r\n            var join = defines.toString();\r\n\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\"];\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: 4 }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <NormalMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): NormalMaterial {\r\n        return SerializationHelper.Clone(() => new NormalMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.NormalMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"NormalMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): NormalMaterial {\r\n        return SerializationHelper.Parse(() => new NormalMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.NormalMaterial\"] = NormalMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'shadowOnlyPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform float alpha;\nuniform vec3 shadowColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0..1]\n\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var shadowOnlyPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'shadowOnlyVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var shadowOnlyVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { IShadowLight } from \"@babylonjs/core/Lights/shadowLight\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./shadowOnly.fragment\";\r\nimport \"./shadowOnly.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class ShadowOnlyMaterial extends PushMaterial {\r\n    private _renderId: number;\r\n    private _activeLight: IShadowLight;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public shadowColor = Color3.Black();\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public get activeLight(): IShadowLight {\r\n        return this._activeLight;\r\n    }\r\n\r\n    public set activeLight(light: IShadowLight) {\r\n        this._activeLight = light;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new ShadowOnlyMaterialDefines();\r\n        }\r\n\r\n        var defines = <ShadowOnlyMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Ensure that active light is the first shadow light\r\n        if (this._activeLight) {\r\n            for (var light of mesh.lightSources) {\r\n                if (light.shadowEnabled) {\r\n                    if (this._activeLight === light) {\r\n                        break; // We are good\r\n                    }\r\n\r\n                    var lightPosition = mesh.lightSources.indexOf(this._activeLight);\r\n\r\n                    if (lightPosition !== -1) {\r\n                        mesh.lightSources.splice(lightPosition, 1);\r\n                        mesh.lightSources.splice(0, 0, this._activeLight);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, 1);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, 1);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            var shaderName = \"shadowOnly\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\", \"alpha\", \"shadowColor\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\"\r\n            ];\r\n            var samplers = new Array<string>();\r\n\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 1\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: 1 }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <ShadowOnlyMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\r\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, 1);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public clone(name: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Clone<ShadowOnlyMaterial>(() => new ShadowOnlyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"ShadowOnlyMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ShadowOnlyMaterial\"] = ShadowOnlyMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'simplePixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n\nvec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var simplePixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'simpleVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var simpleVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./simple.fragment\";\r\nimport \"./simple.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass SimpleMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class SimpleMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new SimpleMaterialDefines();\r\n        }\r\n\r\n        var defines = <SimpleMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            var shaderName = \"simple\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"diffuseMatrix\"\r\n            ];\r\n            var samplers = [\"diffuseSampler\"];\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights - 1 }\r\n                }, engine), defines);\r\n\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <SimpleMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): SimpleMaterial {\r\n        return SerializationHelper.Clone<SimpleMaterial>(() => new SimpleMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.SimpleMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"SimpleMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SimpleMaterial {\r\n        return SerializationHelper.Parse(() => new SimpleMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.SimpleMaterial\"] = SimpleMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'skyPixelShader';\nlet shader = `precision highp float;\n\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\nuniform vec3 cameraPosition;\nuniform vec3 cameraOffset;\nuniform float luminance;\nuniform float turbidity;\nuniform float rayleigh;\nuniform float mieCoefficient;\nuniform float mieDirectionalG;\nuniform vec3 sunPosition;\n\n#include<fogFragmentDeclaration>\n\nconst float e=2.71828182845904523536028747135266249775724709369995957;\nconst float pi=3.141592653589793238462643383279502884197169;\nconst float n=1.0003;\nconst float N=2.545E25;\nconst float pn=0.035;\nconst vec3 lambda=vec3(680E-9,550E-9,450E-9);\nconst vec3 K=vec3(0.686,0.678,0.666);\nconst float v=4.0;\nconst float rayleighZenithLength=8.4E3;\nconst float mieZenithLength=1.25E3;\nconst vec3 up=vec3(0.0,1.0,0.0);\nconst float EE=1000.0;\nconst float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;\nconst float cutoffAngle=pi/1.95;\nconst float steepness=1.5;\nvec3 totalRayleigh(vec3 lambda)\n{\nreturn (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));\n}\nvec3 simplifiedRayleigh()\n{\nreturn 0.0005/vec3(94,40,18);\n}\nfloat rayleighPhase(float cosTheta)\n{\nreturn (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));\n}\nvec3 totalMie(vec3 lambda,vec3 K,float T)\n{\nfloat c=(0.2*T )*10E-18;\nreturn 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;\n}\nfloat hgPhase(float cosTheta,float g)\n{\nreturn (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));\n}\nfloat sunIntensity(float zenithAngleCos)\n{\nreturn EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));\n}\nfloat A=0.15;\nfloat B=0.50;\nfloat C=0.10;\nfloat D=0.20;\nfloat EEE=0.02;\nfloat F=0.30;\nfloat W=1000.0;\nvec3 Uncharted2Tonemap(vec3 x)\n{\nreturn ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;\n}\nvoid main(void) {\n\n#include<clipPlaneFragment>\n\nfloat sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\nfloat rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));\nvec3 sunDirection=normalize(sunPosition);\nfloat sunE=sunIntensity(dot(sunDirection,up));\nvec3 betaR=simplifiedRayleigh()*rayleighCoefficient;\nvec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;\nfloat zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));\nfloat sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\nfloat sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\nvec3 Fex=exp(-(betaR*sR+betaM*sM));\nfloat cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);\nfloat rPhase=rayleighPhase(cosTheta*0.5+0.5);\nvec3 betaRTheta=betaR*rPhase;\nfloat mPhase=hgPhase(cosTheta,mieDirectionalG);\nvec3 betaMTheta=betaM*mPhase;\nvec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));\nLin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));\nvec3 direction=normalize(vPositionW-cameraPosition);\nfloat theta=acos(direction.y);\nfloat phi=atan(direction.z,direction.x);\nvec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);\nvec3 L0=vec3(0.1)*Fex;\nfloat sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\nL0+=(sunE*19000.0*Fex)*sundisk;\nvec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));\nvec3 texColor=(Lin+L0);\ntexColor*=0.04 ;\ntexColor+=vec3(0.0,0.001,0.0025)*0.3;\nfloat g_fMaxLuminance=1.0;\nfloat fLumScaled=0.1/luminance;\nfloat fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled);\nfloat ExposureBias=fLumCompressed;\nvec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\n\n\n\nvec3 retColor=curr*whiteScale;\n\n\nfloat alpha=1.0;\n#ifdef VERTEXCOLOR\nretColor.rgb*=vColor.rgb;\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n\nvec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);\n\n#include<fogFragment>\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var skyPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\n\nlet name = 'skyVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\nvoid main(void) {\ngl_Position=viewProjection*world*vec4(position,1.0);\nvec4 worldPos=world*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var skyVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsVector3, serialize, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./sky.fragment\";\r\nimport \"./sky.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\n/** @hidden */\r\nclass SkyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * This is the sky material which allows to create dynamic and texture free effects for skyboxes.\r\n * @see https://doc.babylonjs.com/extensions/sky\r\n */\r\nexport class SkyMaterial extends PushMaterial {\r\n    /**\r\n     * Defines the overall luminance of sky in interval ]0, 1[.\r\n     */\r\n    @serialize()\r\n    public luminance: number = 1.0;\r\n\r\n    /**\r\n    * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.\r\n    */\r\n    @serialize()\r\n    public turbidity: number = 10.0;\r\n\r\n    /**\r\n     * Defines the sky appearance (light intensity).\r\n     */\r\n    @serialize()\r\n    public rayleigh: number = 2.0;\r\n\r\n    /**\r\n     * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.\r\n     */\r\n    @serialize()\r\n    public mieCoefficient: number = 0.005;\r\n\r\n    /**\r\n     * Defines the amount of haze particles following the Mie scattering theory.\r\n     */\r\n    @serialize()\r\n    public mieDirectionalG: number = 0.8;\r\n\r\n    /**\r\n     * Defines the distance of the sun according to the active scene camera.\r\n     */\r\n    @serialize()\r\n    public distance: number = 500;\r\n\r\n    /**\r\n     * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said\r\n     * \"inclined\".\r\n     */\r\n    @serialize()\r\n    public inclination: number = 0.49;\r\n\r\n    /**\r\n     * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between\r\n     * an object direction and a reference direction.\r\n     */\r\n    @serialize()\r\n    public azimuth: number = 0.25;\r\n\r\n    /**\r\n     * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then\r\n     * the property is overriden by the inclination and the azimuth and can be read at any moment.\r\n     */\r\n    @serializeAsVector3()\r\n    public sunPosition: Vector3 = new Vector3(0, 100, 0);\r\n\r\n    /**\r\n     * Defines if the sun position should be computed (inclination and azimuth) according to the given\r\n     * .sunPosition property.\r\n     */\r\n    @serialize()\r\n    public useSunPosition: boolean = false;\r\n\r\n    /**\r\n     * Defines an offset vector used to get a horizon offset.\r\n     * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis\r\n     */\r\n    @serialize()\r\n    public cameraOffset: Vector3 = Vector3.Zero();\r\n\r\n    // Private members\r\n    private _cameraPosition: Vector3 = Vector3.Zero();\r\n\r\n    private _renderId: number;\r\n\r\n    /**\r\n     * Instantiates a new sky material.\r\n     * This material allows to create dynamic and texture free\r\n     * effects for skyboxes by taking care of the atmosphere state.\r\n     * @see https://doc.babylonjs.com/extensions/sky\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns false as the sky material doesn't need alpha testing.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns null as the sky material has no texture.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new SkyMaterialDefines();\r\n        }\r\n\r\n        var defines = <SkyMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, false);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            var shaderName = \"sky\";\r\n\r\n            var join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                attribs,\r\n                [\"world\", \"viewProjection\", \"view\",\r\n                    \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\",\r\n                    \"luminance\", \"turbidity\", \"rayleigh\", \"mieCoefficient\", \"mieDirectionalG\", \"sunPosition\",\r\n                    \"cameraPosition\", \"cameraOffset\"\r\n                ],\r\n                [],\r\n                join, fallbacks, this.onCompiled, this.onError), defines);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <SkyMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Sky\r\n        var camera = scene.activeCamera;\r\n        if (camera) {\r\n            var cameraWorldMatrix = camera.getWorldMatrix();\r\n            this._cameraPosition.x = cameraWorldMatrix.m[12];\r\n            this._cameraPosition.y = cameraWorldMatrix.m[13];\r\n            this._cameraPosition.z = cameraWorldMatrix.m[14];\r\n            this._activeEffect.setVector3(\"cameraPosition\", this._cameraPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"cameraOffset\", this.cameraOffset);\r\n\r\n        if (this.luminance > 0) {\r\n            this._activeEffect.setFloat(\"luminance\", this.luminance);\r\n        }\r\n\r\n        this._activeEffect.setFloat(\"turbidity\", this.turbidity);\r\n        this._activeEffect.setFloat(\"rayleigh\", this.rayleigh);\r\n        this._activeEffect.setFloat(\"mieCoefficient\", this.mieCoefficient);\r\n        this._activeEffect.setFloat(\"mieDirectionalG\", this.mieDirectionalG);\r\n\r\n        if (!this.useSunPosition) {\r\n            var theta = Math.PI * (this.inclination - 0.5);\r\n            var phi = 2 * Math.PI * (this.azimuth - 0.5);\r\n\r\n            this.sunPosition.x = this.distance * Math.cos(phi);\r\n            this.sunPosition.y = this.distance * Math.sin(phi) * Math.sin(theta);\r\n            this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"sunPosition\", this.sunPosition);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): SkyMaterial {\r\n        return SerializationHelper.Clone<SkyMaterial>(() => new SkyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.SkyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"SkyMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SkyMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Creates a sky material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new sky material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SkyMaterial {\r\n        return SerializationHelper.Parse(() => new SkyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.SkyMaterial\"] = SkyMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'terrainPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\nuniform sampler2D textureSampler;\nuniform vec2 vTextureInfos;\nuniform sampler2D diffuse1Sampler;\nuniform sampler2D diffuse2Sampler;\nuniform sampler2D diffuse3Sampler;\nuniform vec2 diffuse1Infos;\nuniform vec2 diffuse2Infos;\nuniform vec2 diffuse3Infos;\n#endif\n#ifdef BUMP\nuniform sampler2D bump1Sampler;\nuniform sampler2D bump2Sampler;\nuniform sampler2D bump3Sampler;\n#endif\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\n\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{\n\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\n\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\nreturn mat3(tangent*invmax,binormal*invmax,normal);\n}\nvec3 perturbNormal(vec3 viewDir,vec3 mixColor)\n{\nvec3 bump1Color=texture2D(bump1Sampler,vTextureUV*diffuse1Infos).xyz;\nvec3 bump2Color=texture2D(bump2Sampler,vTextureUV*diffuse2Infos).xyz;\nvec3 bump3Color=texture2D(bump3Sampler,vTextureUV*diffuse3Infos).xyz;\nbump1Color.rgb*=mixColor.r;\nbump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);\nvec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);\nmap=map*255./127.-128./127.;\nmat3 TBN=cotangent_frame(vNormalW*vTextureInfos.y,-viewDir,vTextureUV);\nreturn normalize(TBN*map);\n}\n#endif\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(textureSampler,vTextureUV);\n#if defined(BUMP) && defined(DIFFUSE)\nnormalW=perturbNormal(viewDirectionW,baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vTextureInfos.y;\nvec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);\nvec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);\nvec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);\ndiffuse1Color.rgb*=baseColor.r;\ndiffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);\nbaseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*baseColor.rgb,0.0,1.0);\n\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var terrainPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'terrainVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\nuniform mat4 textureMatrix;\nuniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x == 0.)\n{\nvTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var terrainVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./terrain.fragment\";\r\nimport \"./terrain.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass TerrainMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public BUMP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TerrainMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"mixTexture\")\r\n    private _mixTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture1\")\r\n    private _bumpTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture2\")\r\n    private _bumpTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture3\")\r\n    private _bumpTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture3: Texture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new TerrainMaterialDefines();\r\n        }\r\n\r\n        var defines = <TerrainMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this.mixTexture || !this.mixTexture.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this.diffuseTexture1 || !this.diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture2 || !this.diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture3 || !this.diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n            }\r\n\r\n            if (this.bumpTexture1 && this.bumpTexture2 && this.bumpTexture3 && MaterialFlags.BumpTextureEnabled) {\r\n                if (!this.bumpTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines._needNormals = true;\r\n                defines.BUMP = true;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"terrain\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\", \"vSpecularColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMatrix\",\r\n                \"diffuse1Infos\", \"diffuse2Infos\", \"diffuse3Infos\"\r\n            ];\r\n            var samplers = [\"textureSampler\", \"diffuse1Sampler\", \"diffuse2Sampler\", \"diffuse3Sampler\",\r\n                \"bump1Sampler\", \"bump2Sampler\", \"bump3Sampler\"\r\n            ];\r\n\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <TerrainMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.mixTexture) {\r\n                this._activeEffect.setTexture(\"textureSampler\", this._mixTexture);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture.coordinatesIndex, this._mixTexture.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.BumpTextureEnabled && scene.getEngine().getCaps().standardDerivatives) {\r\n                    if (this._bumpTexture1) {\r\n                        this._activeEffect.setTexture(\"bump1Sampler\", this._bumpTexture1);\r\n                    }\r\n                    if (this._bumpTexture2) {\r\n                        this._activeEffect.setTexture(\"bump2Sampler\", this._bumpTexture2);\r\n                    }\r\n                    if (this._bumpTexture3) {\r\n                        this._activeEffect.setTexture(\"bump3Sampler\", this._bumpTexture3);\r\n                    }\r\n                }\r\n            }\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._mixTexture) {\r\n            activeTextures.push(this._mixTexture);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._bumpTexture1) {\r\n            activeTextures.push(this._bumpTexture1);\r\n        }\r\n\r\n        if (this._bumpTexture2) {\r\n            activeTextures.push(this._bumpTexture2);\r\n        }\r\n\r\n        if (this._bumpTexture3) {\r\n            activeTextures.push(this._bumpTexture3);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._mixTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TerrainMaterial {\r\n        return SerializationHelper.Clone(() => new TerrainMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.TerrainMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TerrainMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TerrainMaterial {\r\n        return SerializationHelper.Parse(() => new TerrainMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.TerrainMaterial\"] = TerrainMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/depthPrePass\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'triplanarPixelShader';\nlet shader = `precision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\nuniform sampler2D diffuseSamplerX;\n#ifdef BUMPX\nuniform sampler2D normalSamplerX;\n#endif\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\nuniform sampler2D diffuseSamplerY;\n#ifdef BUMPY\nuniform sampler2D normalSamplerY;\n#endif\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\nuniform sampler2D diffuseSamplerZ;\n#ifdef BUMPZ\nuniform sampler2D normalSamplerZ;\n#endif\n#endif\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(0.,0.,0.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=tangentSpace[2];\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec4 baseNormal=vec4(0.0,0.0,0.0,1.0);\nnormalW*=normalW;\n#ifdef DIFFUSEX\nbaseColor+=texture2D(diffuseSamplerX,vTextureUVX)*normalW.x;\n#ifdef BUMPX\nbaseNormal+=texture2D(normalSamplerX,vTextureUVX)*normalW.x;\n#endif\n#endif\n#ifdef DIFFUSEY\nbaseColor+=texture2D(diffuseSamplerY,vTextureUVY)*normalW.y;\n#ifdef BUMPY\nbaseNormal+=texture2D(normalSamplerY,vTextureUVY)*normalW.y;\n#endif\n#endif\n#ifdef DIFFUSEZ\nbaseColor+=texture2D(diffuseSamplerZ,vTextureUVZ)*normalW.z;\n#ifdef BUMPZ\nbaseNormal+=texture2D(normalSamplerZ,vTextureUVZ)*normalW.z;\n#endif\n#endif\n#ifdef NORMAL\nnormalW=normalize((2.0*baseNormal.xyz-1.0)*tangentSpace);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularBase=vec3(0.,0.,0.);\nvec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var triplanarPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\n\nlet name = 'triplanarVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\n#endif\nuniform float tileSize;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nvoid main(void)\n{\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef DIFFUSEX\nvTextureUVX=worldPos.zy/tileSize;\n#endif\n#ifdef DIFFUSEY\nvTextureUVY=worldPos.xz/tileSize;\n#endif\n#ifdef DIFFUSEZ\nvTextureUVZ=worldPos.xy/tileSize;\n#endif\n#ifdef NORMAL\n\nvec3 xtan=vec3(0,0,1);\nvec3 xbin=vec3(0,1,0);\nvec3 ytan=vec3(1,0,0);\nvec3 ybin=vec3(0,0,1);\nvec3 ztan=vec3(1,0,0);\nvec3 zbin=vec3(0,1,0);\nvec3 normalizedNormal=normalize(normal);\nnormalizedNormal*=normalizedNormal;\nvec3 worldBinormal=normalize(xbin*normalizedNormal.x+ybin*normalizedNormal.y+zbin*normalizedNormal.z);\nvec3 worldTangent=normalize(xtan*normalizedNormal.x+ytan*normalizedNormal.y+ztan*normalizedNormal.z);\nworldTangent=(world*vec4(worldTangent,1.0)).xyz;\nworldBinormal=(world*vec4(worldBinormal,1.0)).xyz;\nvec3 worldNormal=normalize(cross(worldTangent,worldBinormal));\ntangentSpace[0]=worldTangent;\ntangentSpace[1]=worldBinormal;\ntangentSpace[2]=worldNormal;\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var triplanarVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\r\nimport { Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\n\r\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\r\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\r\n\r\nimport \"./triplanar.fragment\";\r\nimport \"./triplanar.vertex\";\r\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\r\n\r\nclass TriPlanarMaterialDefines extends MaterialDefines {\r\n    public DIFFUSEX = false;\r\n    public DIFFUSEY = false;\r\n    public DIFFUSEZ = false;\r\n\r\n    public BUMPX = false;\r\n    public BUMPY = false;\r\n    public BUMPZ = false;\r\n\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TriPlanarMaterial extends PushMaterial {\r\n    @serializeAsTexture()\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureX\")\r\n    private _diffuseTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexturY\")\r\n    private _diffuseTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureZ\")\r\n    private _diffuseTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureZ: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureX\")\r\n    private _normalTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureY\")\r\n    private _normalTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureZ\")\r\n    private _normalTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureZ: BaseTexture;\r\n\r\n    @serialize()\r\n    public tileSize: number = 1;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0.2, 0.2, 0.2);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _renderId: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new TriPlanarMaterialDefines();\r\n        }\r\n\r\n        var defines = <TriPlanarMaterialDefines>subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    var textures = [this.diffuseTextureX, this.diffuseTextureY, this.diffuseTextureZ];\r\n                    var textureDefines = [\"DIFFUSEX\", \"DIFFUSEY\", \"DIFFUSEZ\"];\r\n\r\n                    for (var i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (MaterialFlags.BumpTextureEnabled) {\r\n                    var textures = [this.normalTextureX, this.normalTextureY, this.normalTextureZ];\r\n                    var textureDefines = [\"BUMPX\", \"BUMPY\", \"BUMPZ\"];\r\n\r\n                    for (var i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            var fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            var attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            var shaderName = \"triplanar\";\r\n            var join = defines.toString();\r\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\", \"vSpecularColor\",\r\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\r\n                \"mBones\",\r\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\",\r\n                \"tileSize\"\r\n            ];\r\n            var samplers = [\"diffuseSamplerX\", \"diffuseSamplerY\", \"diffuseSamplerZ\",\r\n                \"normalSamplerX\", \"normalSamplerY\", \"normalSamplerZ\"\r\n            ];\r\n\r\n            var uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights\r\n            });\r\n\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }\r\n                }, engine), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        var scene = this.getScene();\r\n\r\n        var defines = <TriPlanarMaterialDefines>subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"tileSize\", this.tileSize);\r\n\r\n        if (scene.getCachedMaterial() !== this) {\r\n            // Textures\r\n            if (this.diffuseTextureX) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerX\", this.diffuseTextureX);\r\n            }\r\n            if (this.diffuseTextureY) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerY\", this.diffuseTextureY);\r\n            }\r\n            if (this.diffuseTextureZ) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerZ\", this.diffuseTextureZ);\r\n            }\r\n            if (this.normalTextureX) {\r\n                this._activeEffect.setTexture(\"normalSamplerX\", this.normalTextureX);\r\n            }\r\n            if (this.normalTextureY) {\r\n                this._activeEffect.setTexture(\"normalSamplerY\", this.normalTextureY);\r\n            }\r\n            if (this.normalTextureZ) {\r\n                this._activeEffect.setTexture(\"normalSamplerZ\", this.normalTextureZ);\r\n            }\r\n            // Clip plane\r\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            MaterialHelper.BindEyePosition(effect, scene);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        var results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTextureX) {\r\n            activeTextures.push(this._diffuseTextureX);\r\n        }\r\n\r\n        if (this._diffuseTextureY) {\r\n            activeTextures.push(this._diffuseTextureY);\r\n        }\r\n\r\n        if (this._diffuseTextureZ) {\r\n            activeTextures.push(this._diffuseTextureZ);\r\n        }\r\n\r\n        if (this._normalTextureX) {\r\n            activeTextures.push(this._normalTextureX);\r\n        }\r\n\r\n        if (this._normalTextureY) {\r\n            activeTextures.push(this._normalTextureY);\r\n        }\r\n\r\n        if (this._normalTextureZ) {\r\n            activeTextures.push(this._normalTextureZ);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureZ === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureZ === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TriPlanarMaterial {\r\n        return SerializationHelper.Clone(() => new TriPlanarMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.TriPlanarMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TriPlanarMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TriPlanarMaterial {\r\n        return SerializationHelper.Parse(() => new TriPlanarMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.TriPlanarMaterial\"] = TriPlanarMaterial;","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/helperFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogFragment\";\n\nlet name = 'waterPixelShader';\nlet shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\n\nuniform vec3 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef BUMP\nvarying vec2 vNormalUV;\nvarying vec2 vNormalUV2;\nuniform sampler2D normalSampler;\nuniform vec2 vNormalInfos;\n#endif\nuniform sampler2D refractionSampler;\nuniform sampler2D reflectionSampler;\n\nconst float LOG2=1.442695;\nuniform vec3 cameraPosition;\nuniform vec4 waterColor;\nuniform float colorBlendFactor;\nuniform vec4 waterColor2;\nuniform float colorBlendFactor2;\nuniform float bumpHeight;\nuniform float time;\n\nvarying vec3 vRefractionMapTexCoord;\nvarying vec3 vReflectionMapTexCoord;\nvarying vec3 vPosition;\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\n#else\nbaseColor=texture2D(normalSampler,vNormalUV);\n#endif\nvec3 bumpColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\nbaseColor.rgb*=vNormalInfos.y;\n#else\nvec3 bumpColor=vec3(1.0);\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\n#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));\nif (normalW.y<0.0) {\nnormalW.y=-normalW.y;\n}\n#else\nvec3 normalW=normalize(vNormalW);\n#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\nvec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\n#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\n\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);\nvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\nvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\nvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\n),0.0,1.0);\nvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\nfloat fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);\nfloat IfresnelTerm=1.0-fresnelTerm;\nrefractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;\nreflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;\nvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;\nbaseColor=combinedColor;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularBase=vec3(0.,0.,0.);\nvec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#else\n#ifdef REFLECTION\n\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);\nvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);\nvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\nfloat fresnelTerm=max(dot(viewDirectionW,upVector),0.0);\nvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);\nbaseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularBase=vec3(0.,0.,0.);\nvec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#endif\n\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\ngl_FragColor=color;\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var waterPixelShader = { name, shader };\n","import { Effect } from \"@babylonjs/core/Materials/effect\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/instancesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/bonesVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/fogVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"@babylonjs/core/Shaders/ShadersInclude/logDepthVertex\";\n\nlet name = 'waterVertexShader';\nlet shader = `precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef BUMP\nvarying vec2 vNormalUV;\n#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\n#endif\nuniform mat4 normalMatrix;\nuniform vec2 vNormalInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<logDepthDeclaration>\n\nuniform mat4 worldReflectionViewProjection;\nuniform vec2 windDirection;\nuniform float waveLength;\nuniform float time;\nuniform float windForce;\nuniform float waveHeight;\nuniform float waveSpeed;\n\nvarying vec3 vPosition;\nvarying vec3 vRefractionMapTexCoord;\nvarying vec3 vReflectionMapTexCoord;\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef BUMP\nif (vNormalInfos.x == 0.)\n{\nvNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));\n#endif\n}\nelse\n{\nvNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));\n#endif\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\nvec3 p=position;\nfloat newY=(sin(((p.x/0.05)+time*waveSpeed))*waveHeight*windDirection.x*5.0)\n+(cos(((p.z/0.05)+time*waveSpeed))*waveHeight*windDirection.y*5.0);\np.y+=abs(newY);\ngl_Position=viewProjection*finalWorld*vec4(p,1.0);\n#ifdef REFLECTION\nworldPos=viewProjection*finalWorld*vec4(p,1.0);\n\nvPosition=position;\nvRefractionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\nvRefractionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\nvRefractionMapTexCoord.z=worldPos.w;\nworldPos=worldReflectionViewProjection*vec4(position,1.0);\nvReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\nvReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\nvReflectionMapTexCoord.z=worldPos.w;\n#endif\n#include<logDepthVertex>\n}\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var waterVertexShader = { name, shader };\n","import { Nullable } from \"@babylonjs/core/types\";\nimport { serializeAsVector2, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"@babylonjs/core/Misc/decorators\";\nimport { Matrix, Vector2, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\nimport { Plane } from '@babylonjs/core/Maths/math.plane';\nimport { IAnimatable } from '@babylonjs/core/Animations/animatable.interface';\nimport { Constants } from \"@babylonjs/core/Engines/constants\";\nimport { SmartArray } from \"@babylonjs/core/Misc/smartArray\";\nimport { Observer } from '@babylonjs/core/Misc/observable';\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture\";\nimport { IEffectCreationOptions } from \"@babylonjs/core/Materials/effect\";\nimport { MaterialDefines } from \"@babylonjs/core/Materials/materialDefines\";\nimport { IImageProcessingConfigurationDefines, ImageProcessingConfiguration } from \"@babylonjs/core/Materials/imageProcessingConfiguration\";\nimport { MaterialHelper } from \"@babylonjs/core/Materials/materialHelper\";\nimport { PushMaterial } from \"@babylonjs/core/Materials/pushMaterial\";\nimport { MaterialFlags } from \"@babylonjs/core/Materials/materialFlags\";\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { _TypeStore } from '@babylonjs/core/Misc/typeStore';\n\nimport \"./water.fragment\";\nimport \"./water.vertex\";\nimport { EffectFallbacks } from '@babylonjs/core/Materials/effectFallbacks';\n\nclass WaterMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\n    public BUMP = false;\n    public REFLECTION = false;\n    public CLIPPLANE = false;\n    public CLIPPLANE2 = false;\n    public CLIPPLANE3 = false;\n    public CLIPPLANE4 = false;\n    public CLIPPLANE5 = false;\n    public CLIPPLANE6 = false;\n    public ALPHATEST = false;\n    public DEPTHPREPASS = false;\n    public POINTSIZE = false;\n    public FOG = false;\n    public NORMAL = false;\n    public UV1 = false;\n    public UV2 = false;\n    public VERTEXCOLOR = false;\n    public VERTEXALPHA = false;\n    public NUM_BONE_INFLUENCERS = 0;\n    public BonesPerMesh = 0;\n    public INSTANCES = false;\n    public SPECULARTERM = false;\n    public LOGARITHMICDEPTH = false;\n    public FRESNELSEPARATE = false;\n    public BUMPSUPERIMPOSE = false;\n    public BUMPAFFECTSREFLECTION = false;\n\n    public IMAGEPROCESSING = false;\n    public VIGNETTE = false;\n    public VIGNETTEBLENDMODEMULTIPLY = false;\n    public VIGNETTEBLENDMODEOPAQUE = false;\n    public TONEMAPPING = false;\n    public TONEMAPPING_ACES = false;\n    public CONTRAST = false;\n    public EXPOSURE = false;\n    public COLORCURVES = false;\n    public COLORGRADING = false;\n    public COLORGRADING3D = false;\n    public SAMPLER3DGREENDEPTH = false;\n    public SAMPLER3DBGRMAP = false;\n    public IMAGEPROCESSINGPOSTPROCESS = false;\n\n    constructor() {\n        super();\n        this.rebuild();\n    }\n}\n\nexport class WaterMaterial extends PushMaterial {\n    /*\n    * Public members\n    */\n    @serializeAsTexture(\"bumpTexture\")\n    private _bumpTexture: BaseTexture;\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    public bumpTexture: BaseTexture;\n\n    @serializeAsColor3()\n    public diffuseColor = new Color3(1, 1, 1);\n\n    @serializeAsColor3()\n    public specularColor = new Color3(0, 0, 0);\n\n    @serialize()\n    public specularPower = 64;\n\n    @serialize(\"disableLighting\")\n    private _disableLighting = false;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public disableLighting: boolean;\n\n    @serialize(\"maxSimultaneousLights\")\n    private _maxSimultaneousLights = 4;\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    public maxSimultaneousLights: number;\n\n    /**\n    * @param {number}: Represents the wind force\n    */\n    @serialize()\n    public windForce: number = 6;\n    /**\n    * @param {Vector2}: The direction of the wind in the plane (X, Z)\n    */\n    @serializeAsVector2()\n    public windDirection: Vector2 = new Vector2(0, 1);\n    /**\n    * @param {number}: Wave height, represents the height of the waves\n    */\n    @serialize()\n    public waveHeight: number = 0.4;\n    /**\n    * @param {number}: Bump height, represents the bump height related to the bump map\n    */\n    @serialize()\n    public bumpHeight: number = 0.4;\n    /**\n     * @param {boolean}: Add a smaller moving bump to less steady waves.\n     */\n    @serialize(\"bumpSuperimpose\")\n    private _bumpSuperimpose = false;\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n    public bumpSuperimpose: boolean;\n\n    /**\n     * @param {boolean}: Color refraction and reflection differently with .waterColor2 and .colorBlendFactor2. Non-linear (physically correct) fresnel.\n     */\n    @serialize(\"fresnelSeparate\")\n    private _fresnelSeparate = false;\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n    public fresnelSeparate: boolean;\n\n    /**\n     * @param {boolean}: bump Waves modify the reflection.\n     */\n    @serialize(\"bumpAffectsReflection\")\n    private _bumpAffectsReflection = false;\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\n    public bumpAffectsReflection: boolean;\n\n    /**\n    * @param {number}: The water color blended with the refraction (near)\n    */\n    @serializeAsColor3()\n    public waterColor: Color3 = new Color3(0.1, 0.1, 0.6);\n    /**\n    * @param {number}: The blend factor related to the water color\n    */\n    @serialize()\n    public colorBlendFactor: number = 0.2;\n    /**\n     * @param {number}: The water color blended with the reflection (far)\n     */\n    @serializeAsColor3()\n    public waterColor2: Color3 = new Color3(0.1, 0.1, 0.6);\n    /**\n     * @param {number}: The blend factor related to the water color (reflection, far)\n     */\n    @serialize()\n    public colorBlendFactor2: number = 0.2;\n    /**\n    * @param {number}: Represents the maximum length of a wave\n    */\n    @serialize()\n    public waveLength: number = 0.1;\n\n    /**\n    * @param {number}: Defines the waves speed\n    */\n    @serialize()\n    public waveSpeed: number = 1.0;\n    /**\n     * Sets or gets whether or not automatic clipping should be enabled or not. Setting to true will save performances and\n     * will avoid calculating useless pixels in the pixel shader of the water material.\n     */\n    @serialize()\n    public disableClipPlane: boolean = false;\n\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\n\n    /*\n    * Private members\n    */\n    private _mesh: Nullable<AbstractMesh> = null;\n\n    private _refractionRTT: Nullable<RenderTargetTexture>;\n    private _reflectionRTT: Nullable<RenderTargetTexture>;\n\n    private _reflectionTransform: Matrix = Matrix.Zero();\n    private _lastTime: number = 0;\n    private _lastDeltaTime: number = 0;\n\n    private _renderId: number;\n\n    private _useLogarithmicDepth: boolean;\n\n    private _waitingRenderList: Nullable<string[]>;\n\n    private _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\n\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    public get hasRenderTargetTextures(): boolean {\n        return true;\n    }\n\n    /**\n    * Constructor\n    */\n    constructor(name: string, scene: Scene, public renderTargetSize: Vector2 = new Vector2(512, 512)) {\n        super(name, scene);\n\n        this._createRenderTargets(scene, renderTargetSize);\n\n        // Create render targets\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\n            this._renderTargets.reset();\n            this._renderTargets.push(<RenderTargetTexture>this._reflectionRTT);\n            this._renderTargets.push(<RenderTargetTexture>this._refractionRTT);\n\n            return this._renderTargets;\n        };\n\n        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        }\n    }\n\n    @serialize()\n    public get useLogarithmicDepth(): boolean {\n        return this._useLogarithmicDepth;\n    }\n\n    public set useLogarithmicDepth(value: boolean) {\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n        this._markAllSubMeshesAsMiscDirty();\n    }\n\n    // Get / Set\n    public get refractionTexture(): Nullable<RenderTargetTexture> {\n        return this._refractionRTT;\n    }\n\n    public get reflectionTexture(): Nullable<RenderTargetTexture> {\n        return this._reflectionRTT;\n    }\n\n    // Methods\n    public addToRenderList(node: any): void {\n        if (this._refractionRTT && this._refractionRTT.renderList) {\n            this._refractionRTT.renderList.push(node);\n        }\n\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\n            this._reflectionRTT.renderList.push(node);\n        }\n    }\n\n    public enableRenderTargets(enable: boolean): void {\n        var refreshRate = enable ? 1 : 0;\n\n        if (this._refractionRTT) {\n            this._refractionRTT.refreshRate = refreshRate;\n        }\n\n        if (this._reflectionRTT) {\n            this._reflectionRTT.refreshRate = refreshRate;\n        }\n    }\n\n    public getRenderList(): Nullable<AbstractMesh[]> {\n        return this._refractionRTT ? this._refractionRTT.renderList : [];\n    }\n\n    public get renderTargetsEnabled(): boolean {\n        return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);\n    }\n\n    public needAlphaBlending(): boolean {\n        return (this.alpha < 1.0);\n    }\n\n    public needAlphaTesting(): boolean {\n        return false;\n    }\n\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\n        return null;\n    }\n\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\n        if (this.isFrozen) {\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\n                return true;\n            }\n        }\n\n        if (!subMesh._materialDefines) {\n            subMesh._materialDefines = new WaterMaterialDefines();\n        }\n\n        var defines = <WaterMaterialDefines>subMesh._materialDefines;\n        var scene = this.getScene();\n\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\n            if (this._renderId === scene.getRenderId()) {\n                return true;\n            }\n        }\n\n        var engine = scene.getEngine();\n\n        // Textures\n        if (defines._areTexturesDirty) {\n            defines._needUVs = false;\n            if (scene.texturesEnabled) {\n                if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                    if (!this.bumpTexture.isReady()) {\n                        return false;\n                    } else {\n                        defines._needUVs = true;\n                        defines.BUMP = true;\n                    }\n                }\n\n                if (MaterialFlags.ReflectionTextureEnabled) {\n                    defines.REFLECTION = true;\n                }\n            }\n        }\n\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);\n\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\n\n        if (defines._areMiscDirty) {\n            if (this._fresnelSeparate) {\n                defines.FRESNELSEPARATE = true;\n            }\n\n            if (this._bumpSuperimpose) {\n                defines.BUMPSUPERIMPOSE = true;\n            }\n\n            if (this._bumpAffectsReflection) {\n                defines.BUMPAFFECTSREFLECTION = true;\n            }\n        }\n\n        // Lights\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n\n        // Image processing\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n            if (!this._imageProcessingConfiguration.isReady()) {\n                return false;\n            }\n\n            this._imageProcessingConfiguration.prepareDefines(defines);\n\n            defines.IS_REFLECTION_LINEAR = (this.reflectionTexture != null && !this.reflectionTexture.gammaSpace);\n            defines.IS_REFRACTION_LINEAR = (this.refractionTexture != null && !this.refractionTexture.gammaSpace);\n        }\n\n        // Attribs\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\n\n        // Configure this\n        this._mesh = mesh;\n\n        if (this._waitingRenderList) {\n            for (var i = 0; i < this._waitingRenderList.length; i++) {\n                this.addToRenderList(scene.getNodeByID(this._waitingRenderList[i]));\n            }\n\n            this._waitingRenderList = null;\n        }\n\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n\n            // Fallbacks\n            var fallbacks = new EffectFallbacks();\n            if (defines.FOG) {\n                fallbacks.addFallback(1, \"FOG\");\n            }\n\n            if (defines.LOGARITHMICDEPTH) {\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n            }\n\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\n\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n\n            //Attributes\n            var attribs = [VertexBuffer.PositionKind];\n\n            if (defines.NORMAL) {\n                attribs.push(VertexBuffer.NormalKind);\n            }\n\n            if (defines.UV1) {\n                attribs.push(VertexBuffer.UVKind);\n            }\n\n            if (defines.UV2) {\n                attribs.push(VertexBuffer.UV2Kind);\n            }\n\n            if (defines.VERTEXCOLOR) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n\n            // Legacy browser patch\n            var shaderName = \"water\";\n            var join = defines.toString();\n            var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vDiffuseColor\", \"vSpecularColor\",\n                \"vFogInfos\", \"vFogColor\", \"pointSize\",\n                \"vNormalInfos\",\n                \"mBones\",\n                \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"normalMatrix\",\n                \"logarithmicDepthConstant\",\n\n                // Water\n                \"worldReflectionViewProjection\", \"windDirection\", \"waveLength\", \"time\", \"windForce\",\n                \"cameraPosition\", \"bumpHeight\", \"waveHeight\", \"waterColor\", \"waterColor2\", \"colorBlendFactor\", \"colorBlendFactor2\", \"waveSpeed\"\n            ];\n            var samplers = [\"normalSampler\",\n                // Water\n                \"refractionSampler\", \"reflectionSampler\"\n            ];\n            var uniformBuffers = new Array<string>();\n\n            if (ImageProcessingConfiguration) {\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n            }\n\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n                maxSimultaneousLights: this.maxSimultaneousLights\n            });\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName,\n                <IEffectCreationOptions>{\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: this.onCompiled,\n                    onError: this.onError,\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights }\n                }, engine), defines);\n\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n\n        this._renderId = scene.getRenderId();\n        subMesh.effect._wasPreviouslyReady = true;\n\n        return true;\n    }\n\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\n        var scene = this.getScene();\n\n        var defines = <WaterMaterialDefines>subMesh._materialDefines;\n        if (!defines) {\n            return;\n        }\n\n        var effect = subMesh.effect;\n        if (!effect || !this._mesh) {\n            return;\n        }\n        this._activeEffect = effect;\n\n        // Matrices\n        this.bindOnlyWorldMatrix(world);\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        // Bones\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n\n        if (this._mustRebind(scene, effect)) {\n            // Textures\n            if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                this._activeEffect.setTexture(\"normalSampler\", this.bumpTexture);\n\n                this._activeEffect.setFloat2(\"vNormalInfos\", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);\n                this._activeEffect.setMatrix(\"normalMatrix\", this.bumpTexture.getTextureMatrix());\n            }\n            // Clip plane\n            MaterialHelper.BindClipPlane(this._activeEffect, scene);\n\n            // Point size\n            if (this.pointsCloud) {\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\n            }\n\n            MaterialHelper.BindEyePosition(effect, scene);\n        }\n\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\n\n        if (defines.SPECULARTERM) {\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\n        }\n\n        if (scene.lightsEnabled && !this.disableLighting) {\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\n        }\n\n        // View\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n\n        // Fog\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n\n        // Log. depth\n        MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\n\n        // Water\n        if (MaterialFlags.ReflectionTextureEnabled) {\n            this._activeEffect.setTexture(\"refractionSampler\", this._refractionRTT);\n            this._activeEffect.setTexture(\"reflectionSampler\", this._reflectionRTT);\n        }\n\n        var wrvp = this._mesh.getWorldMatrix().multiply(this._reflectionTransform).multiply(scene.getProjectionMatrix());\n\n        // Add delta time. Prevent adding delta time if it hasn't changed.\n        let deltaTime = scene.getEngine().getDeltaTime();\n        if (deltaTime !== this._lastDeltaTime) {\n            this._lastDeltaTime = deltaTime;\n            this._lastTime += this._lastDeltaTime;\n        }\n\n        this._activeEffect.setMatrix(\"worldReflectionViewProjection\", wrvp);\n        this._activeEffect.setVector2(\"windDirection\", this.windDirection);\n        this._activeEffect.setFloat(\"waveLength\", this.waveLength);\n        this._activeEffect.setFloat(\"time\", this._lastTime / 100000);\n        this._activeEffect.setFloat(\"windForce\", this.windForce);\n        this._activeEffect.setFloat(\"waveHeight\", this.waveHeight);\n        this._activeEffect.setFloat(\"bumpHeight\", this.bumpHeight);\n        this._activeEffect.setColor4(\"waterColor\", this.waterColor, 1.0);\n        this._activeEffect.setFloat(\"colorBlendFactor\", this.colorBlendFactor);\n        this._activeEffect.setColor4(\"waterColor2\", this.waterColor2, 1.0);\n        this._activeEffect.setFloat(\"colorBlendFactor2\", this.colorBlendFactor2);\n        this._activeEffect.setFloat(\"waveSpeed\", this.waveSpeed);\n\n        // image processing\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n            this._imageProcessingConfiguration.bind(this._activeEffect);\n        }\n\n        this._afterBind(mesh, this._activeEffect);\n    }\n\n    private _createRenderTargets(scene: Scene, renderTargetSize: Vector2): void {\n        // Render targets\n        this._refractionRTT = new RenderTargetTexture(name + \"_refraction\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\n        this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._refractionRTT.ignoreCameraViewport = true;\n\n        this._reflectionRTT = new RenderTargetTexture(name + \"_reflection\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\n        this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\n        this._reflectionRTT.ignoreCameraViewport = true;\n\n        var isVisible: boolean;\n        var clipPlane: Nullable<Plane> = null;\n        var savedViewMatrix: Matrix;\n        var mirrorMatrix = Matrix.Zero();\n\n        this._refractionRTT.onBeforeRender = () => {\n            if (this._mesh) {\n                isVisible = this._mesh.isVisible;\n                this._mesh.isVisible = false;\n            }\n\n            // Clip plane\n            if (!this.disableClipPlane) {\n                clipPlane = scene.clipPlane;\n\n                var positiony = this._mesh ? this._mesh.position.y : 0.0;\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));\n            }\n        };\n\n        this._refractionRTT.onAfterRender = () => {\n            if (this._mesh) {\n                this._mesh.isVisible = isVisible;\n            }\n\n            // Clip plane\n            if (!this.disableClipPlane) {\n                scene.clipPlane = clipPlane;\n            }\n        };\n\n        this._reflectionRTT.onBeforeRender = () => {\n            if (this._mesh) {\n                isVisible = this._mesh.isVisible;\n                this._mesh.isVisible = false;\n            }\n\n            // Clip plane\n            if (!this.disableClipPlane) {\n                clipPlane = scene.clipPlane;\n\n                var positiony = this._mesh ? this._mesh.position.y : 0.0;\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));\n\n                Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);\n            }\n\n            // Transform\n            savedViewMatrix = scene.getViewMatrix();\n\n            mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);\n            scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());\n            scene.getEngine().cullBackFaces = false;\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene.activeCamera).position, mirrorMatrix);\n        };\n\n        this._reflectionRTT.onAfterRender = () => {\n            if (this._mesh) {\n                this._mesh.isVisible = isVisible;\n            }\n\n            // Clip plane\n            scene.clipPlane = clipPlane;\n\n            // Transform\n            scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());\n            scene.getEngine().cullBackFaces = true;\n            scene._mirroredCameraPosition = null;\n        };\n    }\n\n    public getAnimatables(): IAnimatable[] {\n        var results = [];\n\n        if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {\n            results.push(this.bumpTexture);\n        }\n        if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {\n            results.push(this._reflectionRTT);\n        }\n        if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {\n            results.push(this._refractionRTT);\n        }\n\n        return results;\n    }\n\n    public getActiveTextures(): BaseTexture[] {\n        var activeTextures = super.getActiveTextures();\n\n        if (this._bumpTexture) {\n            activeTextures.push(this._bumpTexture);\n        }\n\n        return activeTextures;\n    }\n\n    public hasTexture(texture: BaseTexture): boolean {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n\n        if (this._bumpTexture === texture) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public dispose(forceDisposeEffect?: boolean): void {\n        if (this.bumpTexture) {\n            this.bumpTexture.dispose();\n        }\n\n        var index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._refractionRTT);\n        if (index != -1) {\n            this.getScene().customRenderTargets.splice(index, 1);\n        }\n        index = -1;\n        index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._reflectionRTT);\n        if (index != -1) {\n            this.getScene().customRenderTargets.splice(index, 1);\n        }\n\n        if (this._reflectionRTT) {\n            this._reflectionRTT.dispose();\n        }\n        if (this._refractionRTT) {\n            this._refractionRTT.dispose();\n        }\n\n        // Remove image-processing observer\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n\n        super.dispose(forceDisposeEffect);\n    }\n\n    public clone(name: string): WaterMaterial {\n        return SerializationHelper.Clone(() => new WaterMaterial(name, this.getScene()), this);\n    }\n\n    public serialize(): any {\n        var serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.customType = \"BABYLON.WaterMaterial\";\n\n        serializationObject.renderList = [];\n        if (this._refractionRTT && this._refractionRTT.renderList) {\n            for (var i = 0; i < this._refractionRTT.renderList.length; i++) {\n                serializationObject.renderList.push(this._refractionRTT.renderList[i].id);\n            }\n        }\n\n        return serializationObject;\n    }\n\n    public getClassName(): string {\n        return \"WaterMaterial\";\n    }\n\n    // Statics\n    public static Parse(source: any, scene: Scene, rootUrl: string): WaterMaterial {\n        var mat = SerializationHelper.Parse(() => new WaterMaterial(source.name, scene), source, scene, rootUrl);\n        mat._waitingRenderList = source.renderList;\n\n        return mat;\n    }\n\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\n        var mesh = Mesh.CreateGround(name, 512, 512, 32, scene, false);\n        return mesh;\n    }\n}\n\n_TypeStore.RegisteredTypes[\"BABYLON.WaterMaterial\"] = WaterMaterial;","import { Engine } from \"@babylonjs/core/Engines/engine\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\n// import * as BABYLON from '@babylonjs/core';\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\nimport { CreateSceneClass } from \"../createScene\";\nimport { Mesh, SceneLoader } from \"@babylonjs/core\";\nimport { SkyMaterial } from \"@babylonjs/materials\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\n\n// required imports\nimport \"@babylonjs/core/Loading/loadingScreen\";\nimport \"@babylonjs/loaders/glTF\";\nimport \"@babylonjs/core/Materials/standardMaterial\";\nimport \"@babylonjs/core/Materials/Textures/Loaders/envTextureLoader\";\n\n// If you don't need the standard material you will still need to import it since the scene requires it.\n\nimport groundTextureUrl from \"../../assets/john-o-nolan-o_gJAkcKJmM-unsplash.jpg\";\nimport controllerModel from \"../../assets/glb/haunted_house.glb\";\n\nexport class DefaultSceneWithTexture implements CreateSceneClass {\n    createScene = async (\n        engine: Engine,\n        canvas: HTMLCanvasElement\n    ): Promise<Scene> => {\n        // This creates a basic Babylon Scene object (non-mesh)\n        const scene = new Scene(engine);\n\n        // This creates and positions a free camera (non-mesh)\n        const camera = new ArcRotateCamera(\n            \"my first camera\",\n            // 0,\n            Math.PI / 1.9,\n            Math.PI / 2.5,\n            90,\n            new Vector3(0, 0, 0),\n            scene\n        );\n        const temp = new SkyMaterial(\"skyMaterial\", scene);\n        temp.backFaceCulling = false;\n\n        const skybox = Mesh.CreateBox(\"skyBox\", 1000.0, scene);\n        skybox.material = temp;\n\n        // This targets the camera to scene origin\n        camera.setTarget(Vector3.Zero());\n\n        // This attaches the camera to the canvas\n        camera.attachControl(canvas, true);\n        camera.useFramingBehavior = true;\n\n        camera.upperBetaLimit = (Math.PI / 2) * 0.99;\n\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n        const light = new HemisphericLight(\n            \"light\",\n            new Vector3(1, 1, 0),\n            scene\n        );\n\n        // Default intensity is 1. Let's dim the light a small amount\n        light.intensity = 0.8;\n\n        const importResult = await SceneLoader.ImportMeshAsync(\n            \"\",\n            \"\",\n            controllerModel,\n            scene,\n            undefined,\n            \".glb\"\n        );\n\n        importResult.meshes[0].scaling.scaleInPlace(100);\n\n        // Our built-in 'ground' shape.\n        const groundMaterial = new StandardMaterial(\"ground\", scene);\n        groundMaterial.diffuseTexture = new Texture(groundTextureUrl, scene);\n\n        // Use CreateGroundFromHeightMap to create a height map of 200 units by 200\n        // units, with 250 subdivisions in each of the `x` and `z` directions, for a\n        // total of 62,500 divisions.\n        const ground = Mesh.CreateGroundFromHeightMap(\n            \"ground\",\n            groundTextureUrl,\n            400,\n            400,\n            250,\n            0,\n            5,\n            scene,\n            false\n        );\n\n        // When our new mesh is read, apply our material.\n        ground.material = groundMaterial;\n\n        return scene;\n    };\n}\n\nexport default new DefaultSceneWithTexture();\n"],"sourceRoot":""}