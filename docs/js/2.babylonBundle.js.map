{"version":3,"sources":["webpack:///../../../../sourceES6/core/Meshes/Builders/linesBuilder.ts","webpack:///../../../sourceES6/core/Physics/physicsImpostor.ts","webpack:///../../../sourceES6/core/Physics/physicsJoint.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/groundBuilder.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/ribbonBuilder.ts","webpack:///../../../sourceES6/core/Physics/physicsEngine.ts","webpack:///../../../sourceES6/core/Meshes/linesMesh.ts","webpack:///(webpack)/buildin/global.js","webpack:///../../../../sourceES6/core/Physics/Plugins/ammoJSPlugin.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/shapeBuilder.ts","webpack:///../../../sourceES6/core/Meshes/groundMesh.ts","webpack:///../../../sourceES6/core/Meshes/instancedMesh.ts","webpack:///../../../sourceES6/core/Physics/physicsRaycastResult.ts","webpack:///../../../sourceES6/core/Physics/physicsEngineComponent.ts","webpack:///../../../sourceES6/core/Shaders/color.fragment.ts","webpack:///../../../sourceES6/core/Shaders/color.vertex.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/sphereBuilder.ts"],"names":["CreateLineSystem","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","x","y","z","color","r","g","b","a","vertexData","CreateDashedLines","shft","dashshft","dashSize","gapSize","dashNb","Array","curvect","Zero","lg","nb","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLines","name","scene","updatable","instance","LinesBuilder","vertexColor","lineColors","getVerticesData","PositionKind","ColorKind","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","applyToMesh","updateMeshPositions","nbSeg","_creationDataStorage","dashedLines","_PhysicsImpostorParser","physicObject","jsonObject","PhysicsImpostor","physicsImpostor","mass","physicsMass","friction","physicsFriction","restitution","physicsRestitution","object","type","_options","_scene","_pluginData","_bodyUpdateRequired","_onBeforePhysicsStepCallbacks","_onAfterPhysicsStepCallbacks","_onPhysicsCollideCallbacks","_deltaPosition","_isDisposed","soft","segments","_tmpQuat","_tmpQuat2","beforeStep","_physicsEngine","translate","_deltaRotationConjugated","rotationQuaternion","multiplyToRef","computeWorldMatrix","parent","getParentsRotation","copyFrom","disableBidirectionalTransformation","getPhysicsPlugin","setPhysicsBodyTransformation","getAbsolutePosition","forEach","func","afterStep","setTransformationFromPhysicsBody","conjugateInPlace","setAbsolutePosition","position","_deltaRotation","onCollideEvent","onCollide","e","otherImpostor","getImpostorWithPhysicsBody","body","filter","obj","otherImpostors","indexOf","callback","this","Warn","getScene","getPhysicsEngine","rotation","RotationYawPitchRoll","pressure","stiffness","velocityIterations","positionIterations","fixedPoints","margin","damping","path","shape","_joints","ignoreParent","_init","Error","getBodyMass","value","setMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","plugin","setBodyPressure","getBodyPressure","getBodyStiffness","setBodyStiffness","getBodyVelocityIterations","setBodyVelocityIterations","getBodyPositionIterations","setBodyPositionIterations","removeImpostor","physicsBody","_parent","_getPhysicsParent","addImpostor","isBodyInitRequired","_physicsBody","setScalingUpdated","forceUpdate","removePhysicsBody","resetUpdateFlags","getObjectExtendSize","getBoundingInfo","q","IDENTITY_QUATERNION","size","boundingBox","extendSizeWorld","scale","DEFAULT_OBJECT_SIZE","getObjectCenter","centerWorld","getParam","paramName","setParam","setBodyMass","getLinearVelocity","setLinearVelocity","velocity","getAngularVelocity","setAngularVelocity","executeNativeFunction","world","registerBeforePhysicsStep","unregisterBeforePhysicsStep","splice","registerAfterPhysicsStep","unregisterAfterPhysicsStep","registerOnPhysicsCollide","collideAgainst","collidedAgainstList","unregisterOnPhysicsCollide","some","cbDef","sameList","every","impostor","copyFromFloats","RotationYawPitchRollToRef","applyForce","force","contactPoint","applyImpulse","createJoint","jointType","jointData","joint","addJoint","addAnchor","width","height","influence","noCollisionBetweenLinkedBodies","appendAnchor","addHook","appendHook","sleep","sleepBody","wakeUp","wakeUpBody","clone","newObject","dispose","removeJoint","setDeltaPosition","setDeltaRotation","conjugate","getBoxSizeToRef","result","getRadius","syncBoneWithImpostor","bone","boneMesh","jointPivot","distToJoint","adjustRotation","tempVec","_tmpVecs","mesh","tempQuat","setRotationQuaternion","WORLD","getDirectionToRef","getParent","addInPlace","syncImpostorWithBone","boneAxis","getRotationQuaternionToRef","pos","boneDir","getAbsolutePositionToRef","Identity","BuildArray","NoImpostor","SphereImpostor","BoxImpostor","PlaneImpostor","MeshImpostor","CapsuleImpostor","CylinderImpostor","ParticleImpostor","HeightmapImpostor","ConvexHullImpostor","CustomImpostor","RopeImpostor","ClothImpostor","SoftbodyImpostor","nativeParams","_physicsJoint","newJoint","physicsPlugin","_physicsPlugin","DistanceJoint","HingeJoint","BallAndSocketJoint","WheelJoint","SliderJoint","PrismaticJoint","UniversalJoint","Hinge2Joint","PhysicsJoint","PointToPointJoint","SpringJoint","LockJoint","updateDistance","maxDistance","minDistance","updateDistanceJoint","setMotor","maxForce","setLimit","upperLimit","lowerLimit","MotorEnabledJoint","targetSpeed","motorIndex","CreateGround","row","col","normals","uvs","subdivisionsX","subdivisions","subdivisionsY","normal","CreateTiledGround","tileRow","tileCol","xmin","zmin","xmax","zmax","w","h","precision","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","rowLength","square","CreateGroundFromHeightMap","colorFilter","alphaFilter","invert","minHeight","maxHeight","temp","bufferWidth","bufferHeight","buffer","gradient","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","ComputeNormals","GroundBuilder","url","onReady","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","tiledGround","LastCreatedScene","LoadImage","img","context","CreateCanvas","getContext","isDisposed","drawImage","getImageData","data","offlineProvider","CreateRibbon","pathArray","closeArray","closePath","invertUV","defaultOffset","offset","minlg","sideOrientation","DEFAULTSIDE","customUV","customColors","us","vs","uTotalDistance","vTotalDistance","ar1","ar2","dist","path1","path2","idc","closePathCorr","subtract","u","v","vertex1","vertex2","pi","l1","l2","min","path1nb","indexFirst","indexLast","_ComputeSides","frontUVs","backUVs","Float32Array","positions32","normals32","uvs32","set","_idx","RibbonBuilder","_GetDefaultSideOrientation","Vector3","setAll","Number","MAX_VALUE","ns","_originalBuilderSideOrientation","DOUBLESIDE","si","pathPoint","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","positionFunction","_boundingInfo","reConstruct","_worldMatrix","colorIndex","UVKind","areNormalsFrozen","isFacetDataEnabled","getIndices","NormalKind","params","getFacetDataParameters","ribbon","gravity","PhysicsEngine","DefaultPluginFactory","_impostors","_subTimeStep","isSupported","setGravity","setTimeStep","WarnImport","newTimeStep","getTimeStep","setSubTimeStep","subTimeStep","getSubTimeStep","getPhysicsPluginName","uniqueId","generatePhysicsBody","mainImpostor","connectedImpostor","impostorJoint","generateJoint","matchingJoints","_step","delta","executeStep","getImpostors","getImpostorForPhysicsObject","raycast","from","to","Epsilon","source","doNotCloneChildren","alpha","intersectionThreshold","attributes","uniforms","needAlphaBlending","defines","color4","_colorShader","_addClipPlaneDefine","label","define","_removeClipPlaneDefine","isReady","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","getClassName","_bind","subMesh","effect","fillMode","_geometry","colorEffect","getEffect","indexToBind","isUnIndexed","getIndexBuffer","setColor4","BindClipPlane","_draw","instancesCount","getVertexBuffers","_unIndexed","engine","getEngine","drawArraysType","LineListDrawMode","verticesStart","verticesCount","drawElementsType","indexStart","indexCount","doNotRecurse","newParent","LinesMesh","createInstance","InstancedLinesMesh","Function","window","module","exports","_useDeltaForWorldStep","ammoInjection","overlappingPairCache","bjsAMMO","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpVector","_tmpMatrix","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","setValue","getWorldInfo","set_m_gravity","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","_isImpostorInContact","contactTest","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","impostors","_afterSoftStep","isActive","_ropeStep","_softbodyOrClothStep","nodePositions","bodyVertices","get_m_nodes","nbVertices","n","at","get_m_x","_isFromLine","ExtrudeShape","normalDirection","vertexPositions","vertexNormals","node","nx","ny","nz","nodeNormals","get_m_n","vertex_data","activate","worldPoint","impulse","getWorldMatrix","invertToRef","TransformCoordinatesToRef","toDispose","colShape","_createShape","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","AmmoJSPlugin","DISABLE_DEACTIVATION_FLAG","addSoftBody","localInertia","startTransform","calculateLocalInertia","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","KINEMATIC_FLAG","getChildShape","DISABLE_COLLISION_FLAG","addRigidBody","concat","removeSoftBody","removeRigidBody","d","destroy","mainBody","connectedBody","mainPivot","connectedPivot","distance","btPoint2PointConstraint","mainAxis","connectedAxis","btHingeConstraint","addConstraint","collision","physicsJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","faceCount","triPoints","point","vec","ScalingToRef","scaling","TransformCoordinates","addTriangle","m","_softVertexData","newPoints","newNorms","TransformNormal","ExtractFromMesh","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","sqrt","segs","CreatePatch","_createRope","map","reduce","accumulator","currentValue","pathVectors","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","extendSize","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","s","decompose","getOrigin","addChildShape","WithinEpsilon","btSphereShape","btMultiSphereShape","setLocalScaling","btCapsuleShape","btCylinderShape","btBoxShape","tetraMesh","triangeCount","btBvhTriangleMeshShape","convexMesh","getMotionState","getWorldTransform","getRotation","toEulerAnglesToRef","newPosition","newRotation","trans","setWorldTransform","motionState","linearVelocity","angularVelocity","setTotalMass","setMassProps","set_kDF","setFriction","setRestitution","set_kPR","get_m_materials","set_m_kLST","set_viterations","set_piterations","round","speed","enableAngularMotor","syncMeshWithImpostor","exntend","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance","cap","NO_CAP","ShapeBuilder","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","_ExtrudeShapeGeneric","curve","rotateFunction","rbCA","rbCP","custom","updtbl","side","path3D","extrusionPathArray","shapePaths","tangents","getTangents","getNormals","binormals","getBinormals","distances","getDistances","angle","rotate","scl","CAP_END","rotationMatrix","Matrix","shapePath","angleStep","scaleRatio","RotationAxisToRef","planed","add","rotated","scaleInPlace","capPath","pointCap","barycenter","CAP_START","CAP_ALL","storage","update","extrudedGeneric","_GroundMeshParser","parsedMesh","GroundMesh","Parse","generateOctree","optimize","chunksCount","octreeBlocksSize","subdivide","createOrUpdateSubmeshesOctree","getHeightAtCoordinates","invMat","tmpVect","TransformCoordinatesFromFloatsToRef","_heightQuads","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","getNormalAtCoordinates","getNormalAtCoordinatesToRef","ref","tmpMat","TransformNormalFromFloatsToRef","updateCoordinateHeights","quad","slope","facet1","facet2","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","k","cd","d1","d2","CrossToRef","serialize","serializationObject","minX","maxX","minZ","maxZ","_instancedMeshFactory","InstancedMesh","instancedBuffers","key","_indexInSourceMeshInstanceArray","addInstance","_sourceMesh","animations","getAnimationRanges","range","createAnimationRange","infiniteDistance","setPivotMatrix","getPivotMatrix","refreshBoundingInfo","_syncSubMeshes","_lightSources","_resyncLightSources","_resyncLightSource","light","_removeLightSource","receiveShadows","material","visibility","skeleton","renderingGroupId","getTotalVertices","getTotalIndices","completeCheck","kind","copyWhenShared","setVerticesData","stride","sourceMesh","updateExtends","makeItUnique","setIndices","totalVertices","isVerticesDataPresent","_positions","applySkeleton","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","_preActivate","_currentLOD","_activate","renderId","intermediateRendering","subMeshes","_getWorldMatrixDeterminant","_internalAbstractMeshDataInfo","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","_postActivate","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","billboardMode","BILLBOARDMODE_NONE","_masterMesh","tempMaster","getLOD","camera","boundingInfo","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","_generatePointsArray","DeepCopy","meshes","disposeMaterialAndTextures","removeInstance","prototype","registerInstancedBuffer","removeVerticesData","instances","_userInstancedBuffersStorage","vertexBuffers","strides","sizes","setVerticesBuffer","_processInstancedBuffers","visibleInstances","renderSelf","instanceCount","expectedSize","toArray","copyToArray","instanceIndex","updateDirectly","_disposeInstanceSpecificData","_instanceDataStorage","instancesBuffer","_hasHit","_hitDistance","_hitNormalWorld","_hitPointWorld","_rayFromWorld","_rayToWorld","hitNormalWorld","hitPointWorld","setHitDistance","Distance","enablePhysics","component","_getComponent","NAME_PHYSICSENGINE","PhysicsEngineSceneComponent","_addComponent","_physicsTimeAccumulator","message","disablePhysicsEngine","isPhysicsEnabled","deleteCompoundImpostor","compound","parts","_advancePhysicsEngineStep","step","subTime","onBeforePhysicsObservable","notifyObservers","onAfterPhysicsObservable","Object","defineProperty","get","_physicsImpostor","_disposePhysicsObserver","onDisposeObservable","remove","enumerable","configurable","setPhysicsLinkWith","otherMesh","pivot1","pivot2","getDeterministicFrameTime","register","rebuild","clear","shader","ShadersStore","CreateSphere","diameterX","diameter","diameterY","diameterZ","arc","slice","radius","totalZRotationSteps","totalYRotationSteps","zRotationStep","normalizedZ","angleZ","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","Up","complete","vertex","multiply","divide","firstIndex","SphereBuilder","sphere"],"mappings":"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","file":"js/2.babylonBundle.js","sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\n\r\nVertexData.CreateLineSystem = function(options: { lines: Vector3[][], colors?: Nullable<Color4[][]> }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var lines = options.lines;\r\n    var colors = options.colors;\r\n    var vertexColors = [];\r\n    var idx = 0;\r\n\r\n    for (var l = 0; l < lines.length; l++) {\r\n        var points = lines[l];\r\n        for (var index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                var color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateDashedLines = function(options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number }): VertexData {\r\n    var dashSize = options.dashSize || 3;\r\n    var gapSize = options.gapSize || 1;\r\n    var dashNb = options.dashNb || 200;\r\n    var points = options.points;\r\n\r\n    var positions = new Array<number>();\r\n    var indices = new Array<number>();\r\n\r\n    var curvect = Vector3.Zero();\r\n    var lg = 0;\r\n    var nb = 0;\r\n    var shft = 0;\r\n    var dashshft = 0;\r\n    var curshft = 0;\r\n    var idx = 0;\r\n    var i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = dashSize * shft / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (var j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (name: string, points: Vector3[], dashSize: number, gapSize: number, dashNb: number, scene: Nullable<Scene> = null, updatable?: boolean, instance?: LinesMesh): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        dashSize: dashSize,\r\n        gapSize: gapSize,\r\n        dashNb: dashNb,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateDashedLines(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class LinesBuilder {\r\n    /**\r\n     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line system mesh\r\n     */\r\n    public static CreateLineSystem(name: string, options: { lines: Vector3[][], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Nullable<Color4[][]>, useVertexAlpha?: boolean }, scene: Nullable<Scene>): LinesMesh {\r\n        var instance = options.instance;\r\n        var lines = options.lines;\r\n        var colors = options.colors;\r\n\r\n        if (instance) { // lines update\r\n            var positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n            var vertexColor;\r\n            var lineColors;\r\n            if (colors) {\r\n                vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n            }\r\n            var i = 0;\r\n            var c = 0;\r\n            for (var l = 0; l < lines.length; l++) {\r\n                var points = lines[l];\r\n                for (var p = 0; p < points.length; p++) {\r\n                    positions[i] = points[p].x;\r\n                    positions[i + 1] = points[p].y;\r\n                    positions[i + 2] = points[p].z;\r\n                    if (colors && vertexColor) {\r\n                        lineColors = colors[l];\r\n                        vertexColor[c] = lineColors[p].r;\r\n                        vertexColor[c + 1] = lineColors[p].g;\r\n                        vertexColor[c + 2] = lineColors[p].b;\r\n                        vertexColor[c + 3] = lineColors[p].a;\r\n                        c += 4;\r\n                    }\r\n                    i += 3;\r\n                }\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n            if (colors && vertexColor) {\r\n                instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n            }\r\n            return instance;\r\n        }\r\n\r\n        // line system creation\r\n        var useVertexColor = (colors) ? true : false;\r\n        var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateLineSystem(options);\r\n        vertexData.applyToMesh(lineSystem, options.updatable);\r\n        return lineSystem;\r\n    }\r\n\r\n    /**\r\n     * Creates a line mesh\r\n     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line mesh\r\n     */\r\n    public static CreateLines(name: string, options: { points: Vector3[], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Color4[], useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var colors = (options.colors) ? [options.colors] : null;\r\n        var lines = LinesBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha }, scene);\r\n        return lines;\r\n    }\r\n\r\n    /**\r\n     * Creates a dashed line mesh\r\n     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the dashed line mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n     */\r\n    public static CreateDashedLines(name: string, options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number, updatable?: boolean, instance?: LinesMesh, useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var points = options.points;\r\n        var instance = options.instance;\r\n        var gapSize = options.gapSize || 1;\r\n        var dashSize = options.dashSize || 3;\r\n\r\n        if (instance) {  //  dashed lines update\r\n            var positionFunction = (positions: FloatArray): void => {\r\n                var curvect = Vector3.Zero();\r\n                var nbSeg = positions.length / 6;\r\n                var lg = 0;\r\n                var nb = 0;\r\n                var shft = 0;\r\n                var dashshft = 0;\r\n                var curshft = 0;\r\n                var p = 0;\r\n                var i = 0;\r\n                var j = 0;\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    lg += curvect.length();\r\n                }\r\n                shft = lg / nbSeg;\r\n                let dashSize = instance!._creationDataStorage!.dashSize;\r\n                let gapSize = instance!._creationDataStorage!.gapSize;\r\n                dashshft = dashSize * shft / (dashSize + gapSize);\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    nb = Math.floor(curvect.length() / shft);\r\n                    curvect.normalize();\r\n                    j = 0;\r\n                    while (j < nb && p < positions.length) {\r\n                        curshft = shft * j;\r\n                        positions[p] = points[i].x + curshft * curvect.x;\r\n                        positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                        positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                        positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                        positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                        positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                        p += 6;\r\n                        j++;\r\n                    }\r\n                }\r\n                while (p < positions.length) {\r\n                    positions[p] = points[i].x;\r\n                    positions[p + 1] = points[i].y;\r\n                    positions[p + 2] = points[i].z;\r\n                    p += 3;\r\n                }\r\n            };\r\n            instance.updateMeshPositions(positionFunction, false);\r\n            return instance;\r\n        }\r\n        // dashed lines creation\r\n        var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateDashedLines(options);\r\n        vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n        dashedLines._creationDataStorage = new _CreationDataStorage();\r\n        dashedLines._creationDataStorage.dashSize = dashSize;\r\n        dashedLines._creationDataStorage.gapSize = gapSize;\r\n        return dashedLines;\r\n    }\r\n}","import { Nullable, IndicesArray } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Scene } from \"../scene\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport { PhysicsJoint, PhysicsJointData } from \"./physicsJoint\";\r\nimport { Space } from '../Maths/math.axis';\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function(scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {\r\n        mass: jsonObject.physicsMass,\r\n        friction: jsonObject.physicsFriction,\r\n        restitution: jsonObject.physicsRestitution\r\n    }, scene);\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsImpostor {\r\n\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @hidden */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @hidden */\r\n    public _onPhysicsCollideCallbacks: Array<{ callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor) => void, otherImpostors: Array<PhysicsImpostor> }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @hidden */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _tmpVecs: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private static _tmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint,\r\n        otherImpostor: PhysicsImpostor\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number, private _options: PhysicsImpostorParameters = { mass: 0 }, private _scene?: Scene) {\r\n\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n\r\n            }\r\n            //default options params\r\n            this._options.mass = (_options.mass === void 0) ? 0 : _options.mass;\r\n            this._options.friction = (_options.friction === void 0) ? 0.2 : _options.friction;\r\n            this._options.restitution = (_options.restitution === void 0) ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = (_options.pressure === void 0) ? 200 : _options.pressure;\r\n                this._options.stiffness = (_options.stiffness === void 0) ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = (_options.velocityIterations === void 0) ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = (_options.positionIterations === void 0) ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = (_options.fixedPoints === void 0) ? 0 : _options.fixedPoints;\r\n                this._options.margin = (_options.margin === void 0) ? 0 : _options.margin;\r\n                this._options.damping = (_options.damping === void 0) ? 0 : _options.damping;\r\n                this._options.path = (_options.path === void 0) ? null : _options.path;\r\n                this._options.shape = (_options.shape === void 0) ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completly initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @hidden\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            var parentMesh: AbstractMesh = <AbstractMesh>this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && !this._parent);\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     * @param updated Specifies if the scaling is updated\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use under cautious - This will remove all joints already implemented.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return (this._parent && !this._options.ignoreParent) ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extend size\r\n     * @returns the object extend size\r\n     */\r\n    public getObjectExtendSize(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            let q = this.object.rotationQuaternion;\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            let boundingInfo = this.object.getBoundingInfo();\r\n            let size = boundingInfo.boundingBox.extendSizeWorld.scale(2);\r\n\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            let boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass option. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        var index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        var index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor) => void): void {\r\n        var collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter on contact\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>) => void): void {\r\n        var collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        var index = -1;\r\n        let found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                let sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        this._deltaRotationConjugated && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            this.object.rotationQuaternion && this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n        }\r\n\r\n        this._onBeforePhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterPhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        this._deltaRotation && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n        this.object.translate(this._deltaPosition, 1);\r\n    }\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     * event and body object due to cannon's event-based architecture.\r\n     */\r\n    public onCollide = (e: { body: any }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n\r\n        }\r\n        var otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            this._onPhysicsCollideCallbacks.filter((obj) => {\r\n                return obj.otherImpostors.indexOf((<PhysicsImpostor>otherImpostor)) !== -1;\r\n            }).forEach((obj) => {\r\n                obj.callback(this, <PhysicsImpostor>otherImpostor);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        var joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor!(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little strech\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) { return null; }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._joints.forEach((j) => {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        });\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        } else {\r\n            /*this._object.getChildMeshes().forEach(function(mesh) {\r\n                if (mesh.physicsImpostor) {\r\n                    if (disposeChildren) {\r\n                        mesh.physicsImpostor.dispose();\r\n                        mesh.physicsImpostor = null;\r\n                    }\r\n                }\r\n            })*/\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n\r\n        var tempVec = PhysicsImpostor._tmpVecs[0];\r\n        var mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                var tempQuat = PhysicsImpostor._tmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n\r\n        var mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                var tempQuat = PhysicsImpostor._tmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        var pos = PhysicsImpostor._tmpVecs[0];\r\n        var boneDir = PhysicsImpostor._tmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._tmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\nimport { IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\n/**\r\n * Interface for Physics-Joint data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface PhysicsJointData {\r\n    //Important for some engines, optional!\r\n    /**\r\n     * The main pivot of the joint\r\n     */\r\n    mainPivot?: Vector3;\r\n    /**\r\n     * The connected pivot of the joint\r\n     */\r\n    connectedPivot?: Vector3;\r\n    /**\r\n     * The main axis of the joint\r\n     */\r\n    mainAxis?: Vector3;\r\n    /**\r\n     * The connected axis of the joint\r\n     */\r\n    connectedAxis?: Vector3;\r\n    /**\r\n     * The collision of the joint\r\n     */\r\n    collision?: boolean;\r\n    /**\r\n     * Native Oimo/Cannon/Energy data\r\n     */\r\n    nativeParams?: any;\r\n}\r\n\r\n/**\r\n * This is a holder class for the physics joint created by the physics plugin\r\n * It holds a set of functions to control the underlying joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsJoint {\r\n\r\n    private _physicsJoint: any;\r\n    protected _physicsPlugin: IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Initializes the physics joint\r\n     * @param type The type of the physics joint\r\n     * @param jointData The data for the physics joint\r\n     */\r\n    constructor(\r\n        /**\r\n         * The type of the physics joint\r\n         */\r\n        public type: number,\r\n        /**\r\n         * The data for the physics joint\r\n         */\r\n        public jointData: PhysicsJointData) {\r\n        jointData.nativeParams = jointData.nativeParams || {};\r\n    }\r\n\r\n    /**\r\n     * Gets the physics joint\r\n     */\r\n    public get physicsJoint(): any {\r\n        return this._physicsJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics joint\r\n     */\r\n    public set physicsJoint(newJoint: any) {\r\n\r\n        if (this._physicsJoint) {\r\n            //remove from the wolrd\r\n        }\r\n\r\n        this._physicsJoint = newJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics plugin\r\n     */\r\n    public set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin) {\r\n        this._physicsPlugin = physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Execute a function that is physics-plugin specific.\r\n     * @param {Function} func the function that will be executed.\r\n     *                        It accepts two parameters: the physics world and the physics joint\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsJoint: any) => void) {\r\n        func(this._physicsPlugin.world, this._physicsJoint);\r\n    }\r\n\r\n    //TODO check if the native joints are the same\r\n\r\n    //Joint Types\r\n    /**\r\n     * Distance-Joint type\r\n     */\r\n    public static DistanceJoint = 0;\r\n    /**\r\n     * Hinge-Joint type\r\n     */\r\n    public static HingeJoint = 1;\r\n    /**\r\n     * Ball-and-Socket joint type\r\n     */\r\n    public static BallAndSocketJoint = 2;\r\n    /**\r\n     * Wheel-Joint type\r\n     */\r\n    public static WheelJoint = 3;\r\n    /**\r\n     * Slider-Joint type\r\n     */\r\n    public static SliderJoint = 4;\r\n    //OIMO\r\n    /**\r\n     * Prismatic-Joint type\r\n     */\r\n    public static PrismaticJoint = 5;\r\n    //\r\n    /**\r\n     * Universal-Joint type\r\n     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\r\n     */\r\n    public static UniversalJoint = 6;\r\n    /**\r\n     * Hinge-Joint 2 type\r\n     */\r\n    public static Hinge2Joint = PhysicsJoint.WheelJoint;\r\n    //Cannon\r\n    /**\r\n     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters\r\n     */\r\n    public static PointToPointJoint = 8;\r\n    //Cannon only at the moment\r\n    /**\r\n     * Spring-Joint type\r\n     */\r\n    public static SpringJoint = 9;\r\n    /**\r\n     * Lock-Joint type\r\n     */\r\n    public static LockJoint = 10;\r\n}\r\n\r\n/**\r\n * A class representing a physics distance joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class DistanceJoint extends PhysicsJoint {\r\n    /**\r\n     *\r\n     * @param jointData The data for the Distance-Joint\r\n     */\r\n    constructor(jointData: DistanceJointData) {\r\n        super(PhysicsJoint.DistanceJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Update the predefined distance.\r\n     * @param maxDistance The maximum preferred distance\r\n     * @param minDistance The minimum preferred distance\r\n     */\r\n    public updateDistance(maxDistance: number, minDistance?: number) {\r\n        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Motor-Enabled Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {\r\n\r\n    /**\r\n     * Initializes the Motor-Enabled Joint\r\n     * @param type The type of the joint\r\n     * @param jointData The physica joint data for the joint\r\n     */\r\n    constructor(type: number, jointData: PhysicsJointData) {\r\n        super(type, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param force the force to apply\r\n     * @param maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a single physics Hinge-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class HingeJoint extends MotorEnabledJoint {\r\n\r\n    /**\r\n     * Initializes the Hinge-Joint\r\n     * @param jointData The joint data for the Hinge-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.HingeJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} force the force to apply\r\n     * @param {number} maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a dual hinge physics joint (same as wheel joint)\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class Hinge2Joint extends MotorEnabledJoint {\r\n\r\n    /**\r\n     * Initializes the Hinge2-Joint\r\n     * @param jointData The joint data for the Hinge2-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.Hinge2Joint, jointData);\r\n    }\r\n\r\n    /**\r\n    * Set the motor values.\r\n    * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n    * @param {number} targetSpeed the speed the motor is to reach\r\n    * @param {number} maxForce max force for this motor.\r\n    * @param {motorIndex} the motor's index, 0 or 1.\r\n    */\r\n    public setMotor(targetSpeed?: number, maxForce?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the motor limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} upperLimit the upper limit\r\n     * @param {number} lowerLimit lower limit\r\n     * @param {motorIndex} the motor's index, 0 or 1.\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a motor enabled joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IMotorEnabledJoint {\r\n    /**\r\n     * Physics joint\r\n     */\r\n    physicsJoint: any;\r\n    /**\r\n     * Sets the motor of the motor-enabled joint\r\n     * @param force The force of the motor\r\n     * @param maxForce The maximum force of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setMotor(force?: number, maxForce?: number, motorIndex?: number): void;\r\n    /**\r\n     * Sets the limit of the motor\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n}\r\n\r\n/**\r\n * Joint data for a Distance-Joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface DistanceJointData extends PhysicsJointData {\r\n    /**\r\n     * Max distance the 2 joint objects can be apart\r\n     */\r\n    maxDistance: number;\r\n    //Oimo - minDistance\r\n    //Cannon - maxForce\r\n}\r\n\r\n/**\r\n * Joint data from a spring joint\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface SpringJointData extends PhysicsJointData {\r\n    /**\r\n     * Length of the spring\r\n     */\r\n    length: number;\r\n    /**\r\n     * Stiffness of the spring\r\n     */\r\n    stiffness: number;\r\n    /**\r\n     * Damping of the spring\r\n     */\r\n    damping: number;\r\n    /** this callback will be called when applying the force to the impostors. */\r\n    forceApplicationCallback: () => void;\r\n}\r\n","import { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from '../../types';\r\nimport { EngineStore } from '../../Engines/engineStore';\r\nimport { Epsilon } from '../../Maths/math.constants';\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\nVertexData.CreateGround = function(options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row: number, col: number;\r\n\r\n    var width: number = options.width || 1;\r\n    var height: number = options.height || 1;\r\n    var subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    var subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            var position = new Vector3((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));\r\n            var normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateTiledGround = function(options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; } }): VertexData {\r\n    var xmin = (options.xmin !== undefined && options.xmin !== null) ? options.xmin : -1.0;\r\n    var zmin = (options.zmin !== undefined && options.zmin !== null) ? options.zmin : -1.0;\r\n    var xmax = (options.xmax !== undefined && options.xmax !== null) ? options.xmax : 1.0;\r\n    var zmax = (options.zmax !== undefined && options.zmax !== null) ? options.zmax : 1.0;\r\n    var subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    var precision = options.precision || { w: 1, h: 1 };\r\n\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n    var row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;\r\n    subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;\r\n    precision.w = (precision.w < 1) ? 1 : precision.w;\r\n    precision.h = (precision.h < 1) ? 1 : precision.h;\r\n\r\n    var tileSize = {\r\n        'w': (xmax - xmin) / subdivisions.w,\r\n        'h': (zmax - zmin) / subdivisions.h\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        var base = positions.length / 3;\r\n        var rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                var square = [\r\n                    base + col + row * rowLength,\r\n                    base + (col + 1) + row * rowLength,\r\n                    base + (col + 1) + (row + 1) * rowLength,\r\n                    base + col + (row + 1) * rowLength\r\n                ];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        var position = Vector3.Zero();\r\n        var normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(\r\n                xmin + tileCol * tileSize.w,\r\n                zmin + tileRow * tileSize.h,\r\n                xmin + (tileCol + 1) * tileSize.w,\r\n                zmin + (tileRow + 1) * tileSize.h\r\n            );\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateGroundFromHeightMap = function(options: { width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, colorFilter: Color3, buffer: Uint8Array, bufferWidth: number, bufferHeight: number, alphaFilter: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row, col;\r\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    var alphaFilter = options.alphaFilter || 0.0;\r\n    var invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        let temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            var position = new Vector3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));\r\n\r\n            // Compute height\r\n            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            var r = options.buffer[pos] / 255.0;\r\n            var g = options.buffer[pos + 1] / 255.0;\r\n            var b = options.buffer[pos + 2] / 255.0;\r\n            var a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            var gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            }\r\n            else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            var idx1 = (col + 1 + (row + 1) * (options.subdivisions + 1));\r\n            var idx2 = (col + 1 + row * (options.subdivisions + 1));\r\n            var idx3 = (col + row * (options.subdivisions + 1));\r\n            var idx4 = (col + (row + 1) * (options.subdivisions + 1));\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (name: string, xmin: number, zmin: number, xmax: number, zmax: number, subdivisions: { w: number; h: number; }, precision: { w: number; h: number; }, scene: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        xmin: xmin,\r\n        zmin: zmin,\r\n        xmax: xmax,\r\n        zmax: zmax,\r\n        subdivisions: subdivisions,\r\n        precision: precision,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean, onReady?: (mesh: GroundMesh) => void, alphaFilter?: number): GroundMesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        minHeight: minHeight,\r\n        maxHeight: maxHeight,\r\n        updatable: updatable,\r\n        onReady: onReady,\r\n        alphaFilter: alphaFilter\r\n    };\r\n\r\n    return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class GroundBuilder {\r\n    /**\r\n     * Creates a ground mesh\r\n     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n     */\r\n    public static CreateGround(name: string, options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number, updatable?: boolean }, scene: any): Mesh {\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._setReady(false);\r\n        ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n        ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n        ground._width = options.width || 1;\r\n        ground._height = options.height || 1;\r\n        ground._maxX = ground._width / 2;\r\n        ground._maxZ = ground._height / 2;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        var vertexData = VertexData.CreateGround(options);\r\n\r\n        vertexData.applyToMesh(ground, options.updatable);\r\n\r\n        ground._setReady(true);\r\n\r\n        return ground;\r\n    }\r\n\r\n    /**\r\n     * Creates a tiled ground mesh\r\n     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tiled ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n     */\r\n    public static CreateTiledGround(name: string, options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; }, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var tiledGround = new Mesh(name, scene);\r\n\r\n        var vertexData = VertexData.CreateTiledGround(options);\r\n\r\n        vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n        return tiledGround;\r\n    }\r\n\r\n    /**\r\n     * Creates a ground mesh from a height map\r\n     * * The parameter `url` sets the URL of the height map image resource.\r\n     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to the height map\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n     */\r\n    public static CreateGroundFromHeightMap(name: string, url: string, options: { width?: number, height?: number, subdivisions?: number, minHeight?: number, maxHeight?: number, colorFilter?: Color3, alphaFilter?: number, updatable?: boolean, onReady?: (mesh: GroundMesh) => void }, scene: Nullable<Scene> = null): GroundMesh {\r\n        var width = options.width || 10.0;\r\n        var height = options.height || 10.0;\r\n        var subdivisions = options.subdivisions || 1 | 0;\r\n        var minHeight = options.minHeight || 0.0;\r\n        var maxHeight = options.maxHeight || 1.0;\r\n        var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n        var alphaFilter = options.alphaFilter || 0.0;\r\n        var updatable = options.updatable;\r\n        var onReady = options.onReady;\r\n\r\n        scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._subdivisionsX = subdivisions;\r\n        ground._subdivisionsY = subdivisions;\r\n        ground._width = width;\r\n        ground._height = height;\r\n        ground._maxX = ground._width / 2.0;\r\n        ground._maxZ = ground._height / 2.0;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        ground._setReady(false);\r\n\r\n        var onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            var bufferWidth = img.width;\r\n            var bufferHeight = img.height;\r\n\r\n            // Getting height map data\r\n            var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);\r\n            var context = canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\r\n            }\r\n\r\n            if (scene!.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            context.drawImage(img, 0, 0);\r\n\r\n            // Create VertexData from map data\r\n            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            var buffer = <Uint8Array>(<any>context.getImageData(0, 0, bufferWidth, bufferHeight).data);\r\n            var vertexData = VertexData.CreateGroundFromHeightMap({\r\n                width: width, height: height,\r\n                subdivisions: subdivisions,\r\n                minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,\r\n                buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight,\r\n                alphaFilter: alphaFilter\r\n            });\r\n\r\n            vertexData.applyToMesh(ground, updatable);\r\n\r\n            //execute ready callback, if set\r\n            if (onReady) {\r\n                onReady(ground);\r\n            }\r\n\r\n            ground._setReady(true);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, () => { }, scene.offlineProvider);\r\n\r\n        return ground;\r\n    }\r\n}","import { Nullable, FloatArray } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\r\n\r\nVertexData.CreateRibbon = function(options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }): VertexData {\r\n    var pathArray: Vector3[][] = options.pathArray;\r\n    var closeArray: boolean = options.closeArray || false;\r\n    var closePath: boolean = options.closePath || false;\r\n    var invertUV: boolean = options.invertUV || false;\r\n    var defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    var offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    var sideOrientation: number = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var customUV = options.uvs;\r\n    var customColors = options.colors;\r\n\r\n    var positions: number[] = [];\r\n    var indices: number[] = [];\r\n    var normals: number[] = [];\r\n    var uvs: number[] = [];\r\n\r\n    var us: number[][] = [];        \t\t// us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    var vs: number[][] = [];        \t\t// vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray\r\n    var uTotalDistance: number[] = []; \t\t// uTotalDistance[p] : total distance of path p\r\n    var vTotalDistance: number[] = []; \t\t//  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    var minlg: number;          \t        // minimal length among all paths from pathArray\r\n    var lg: number[] = [];        \t\t    // array of path lengths : nb of vertex per path\r\n    var idx: number[] = [];       \t\t    // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    var p: number;\t\t\t\t\t\t\t// path iterator\r\n    var i: number;\t\t\t\t\t\t\t// point iterator\r\n    var j: number;\t\t\t\t\t\t\t// point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        var ar1: Vector3[] = [];\r\n        var ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    var idc: number = 0;\r\n    var closePathCorr: number = (closePath) ? 1 : 0;    // the final index will be +1 if closePath\r\n    var path: Vector3[];\r\n    var l: number;\r\n    minlg = pathArray[0].length;\r\n    var vectlg: number;\r\n    var dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = (minlg < l) ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {        // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += (l + closePathCorr);\r\n    }\r\n\r\n    // vertical distances (v)\r\n    var path1: Vector3[];\r\n    var path2: Vector3[];\r\n    var vertex1: Nullable<Vector3> = null;\r\n    var vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {   // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            }\r\n            else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {   // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    var u: number;\r\n    var v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, customUV[p].y);\r\n        }\r\n    }\r\n    else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = (uTotalDistance[p] != 0.0) ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = (vTotalDistance[i] != 0.0) ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0;                    \t\t\t\t\t// path index\r\n    var pi: number = 0;                    \t\t// positions array index\r\n    var l1: number = lg[p] - 1;           \t\t// path1 length\r\n    var l2: number = lg[p + 1] - 1;         \t// path2 length\r\n    var min: number = (l1 < l2) ? l1 : l2;   \t// current path stop index\r\n    var shft: number = idx[1] - idx[0];         // shift\r\n    var path1nb: number = closeArray ? lg.length : lg.length - 1;     // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {       \t//  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {                   \t\t\t// if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {                 // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            }\r\n            else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = (l1 < l2) ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {        // update both the first and last vertex normals to their average value\r\n        var indexFirst: number = 0;\r\n        var indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            }\r\n            else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (var c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    var positions32 = new Float32Array(positions);\r\n    var normals32 = new Float32Array(normals);\r\n    var uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateRibbon = (name: string, pathArray: Vector3[][], closeArray: boolean = false, closePath: boolean, offset: number, scene?: Scene, updatable: boolean = false, sideOrientation?: number, instance?: Mesh) => {\r\n    return RibbonBuilder.CreateRibbon(name, {\r\n        pathArray: pathArray,\r\n        closeArray: closeArray,\r\n        closePath: closePath,\r\n        offset: offset,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    }, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class RibbonBuilder {\r\n    /**\r\n     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ribbon mesh\r\n     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     */\r\n    public static CreateRibbon(name: string, options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }, scene: Nullable<Scene> = null): Mesh {\r\n        var pathArray = options.pathArray;\r\n        var closeArray = options.closeArray;\r\n        var closePath = options.closePath;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var updatable = options.updatable;\r\n\r\n        if (instance) {   // existing ribbon instance update\r\n            // positionFunction : ribbon case\r\n            // only pathArray and sideOrientation parameters are taken into account for positions update\r\n            const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n            const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n            var positionFunction = (positions: FloatArray) => {\r\n                var minlg = pathArray[0].length;\r\n                var mesh = (<Mesh>instance);\r\n                var i = 0;\r\n                var ns = (mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE) ? 2 : 1;\r\n                for (var si = 1; si <= ns; ++si) {\r\n                    for (var p = 0; p < pathArray.length; ++p) {\r\n                        var path = pathArray[p];\r\n                        var l = path.length;\r\n                        minlg = (minlg < l) ? minlg : l;\r\n                        for (let j = 0; j < minlg; ++j) {\r\n                            const pathPoint = path[j];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            i += 3;\r\n                        }\r\n                        if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                            const pathPoint = path[0];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            i += 3;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            var positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n            positionFunction(positions);\r\n            if (instance._boundingInfo) {\r\n                instance._boundingInfo.reConstruct(minimum, maximum, instance._worldMatrix);\r\n            }\r\n            else {\r\n                instance._boundingInfo = new BoundingInfo(minimum, maximum, instance._worldMatrix);\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n            if (options.colors) {\r\n                var colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n                for (var c = 0, colorIndex = 0; c < options.colors.length; c++ , colorIndex += 4) {\r\n                    const color = options.colors[c];\r\n                    colors[colorIndex] = color.r;\r\n                    colors[colorIndex + 1] = color.g;\r\n                    colors[colorIndex + 2] = color.b;\r\n                    colors[colorIndex + 3] = color.a;\r\n                }\r\n                instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n            }\r\n            if (options.uvs) {\r\n                var uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n                for (var i = 0; i < options.uvs.length; i++) {\r\n                    uvs[i * 2] = options.uvs[i].x;\r\n                    uvs[i * 2 + 1] = options.uvs[i].y;\r\n                }\r\n                instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n            }\r\n            if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n                var indices = instance.getIndices();\r\n                var normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n                var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n                VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n                if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                    var indexFirst: number = 0;\r\n                    var indexLast: number = 0;\r\n                    for (var p = 0; p < pathArray.length; p++) {\r\n                        indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                        if (p + 1 < pathArray.length) {\r\n                            indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                        }\r\n                        else {\r\n                            indexLast = normals.length - 3;\r\n                        }\r\n                        normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                        normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                        normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                        normals[indexLast] = normals[indexFirst];\r\n                        normals[indexLast + 1] = normals[indexFirst + 1];\r\n                        normals[indexLast + 2] = normals[indexFirst + 2];\r\n                    }\r\n                }\r\n                if (!(instance.areNormalsFrozen)) {\r\n                    instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n                }\r\n            }\r\n\r\n            return instance;\r\n        }\r\n        else {  // new ribbon creation\r\n\r\n            var ribbon = new Mesh(name, scene);\r\n            ribbon._originalBuilderSideOrientation = sideOrientation;\r\n            ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n            var vertexData = VertexData.CreateRibbon(options);\r\n            if (closePath) {\r\n                ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n            }\r\n            ribbon._creationDataStorage.closePath = closePath;\r\n            ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n            vertexData.applyToMesh(ribbon, updatable);\r\n\r\n            return ribbon;\r\n        }\r\n    }\r\n}","import { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { IPhysicsEngine, PhysicsImpostorJoint, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { PhysicsRaycastResult } from \"./physicsRaycastResult\";\r\nimport { _DevTools } from '../Misc/devTools';\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see http://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /**\r\n     * Global value used to control the smallest number supported by the simulation\r\n     */\r\n    public static Epsilon = 0.001;\r\n\r\n    private _impostors: Array<PhysicsImpostor> = [];\r\n    private _joints: Array<PhysicsImpostorJoint> = [];\r\n    private _subTimeStep: number = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePlugin {\r\n        throw _DevTools.WarnImport(\"CannonJSPlugin\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePlugin = PhysicsEngine.DefaultPluginFactory()) {\r\n        if (!this._physicsPlugin.isSupported()) {\r\n            throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \"\r\n                + \"Please make sure it is included.\");\r\n        }\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._impostors.forEach(function(impostor) {\r\n            impostor.dispose();\r\n        });\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    public addImpostor(impostor: PhysicsImpostor) {\r\n        impostor.uniqueId = this._impostors.push(impostor);\r\n        //if no parent, generate the body\r\n        if (!impostor.parent) {\r\n            this._physicsPlugin.generatePhysicsBody(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    public removeImpostor(impostor: PhysicsImpostor) {\r\n        var index = this._impostors.indexOf(impostor);\r\n        if (index > -1) {\r\n            var removed = this._impostors.splice(index, 1);\r\n            //Is it needed?\r\n            if (removed.length) {\r\n                this.getPhysicsPlugin().removePhysicsBody(impostor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    public addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        var impostorJoint = {\r\n            mainImpostor: mainImpostor,\r\n            connectedImpostor: connectedImpostor,\r\n            joint: joint\r\n        };\r\n        joint.physicsPlugin = this._physicsPlugin;\r\n        this._joints.push(impostorJoint);\r\n        this._physicsPlugin.generateJoint(impostorJoint);\r\n    }\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    public removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        var matchingJoints = this._joints.filter(function(impostorJoint) {\r\n            return (impostorJoint.connectedImpostor === connectedImpostor\r\n                && impostorJoint.joint === joint\r\n                && impostorJoint.mainImpostor === mainImpostor);\r\n        });\r\n        if (matchingJoints.length) {\r\n            this._physicsPlugin.removeJoint(matchingJoints[0]);\r\n            //TODO remove it from the list as well\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespam between frames\r\n     */\r\n    public _step(delta: number) {\r\n        //check if any mesh has no body / requires an update\r\n        this._impostors.forEach((impostor) => {\r\n\r\n            if (impostor.isBodyInitRequired()) {\r\n                this._physicsPlugin.generatePhysicsBody(impostor);\r\n            }\r\n        });\r\n\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._impostors);\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePlugin {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    public getImpostors(): Array<PhysicsImpostor> {\r\n        return this._impostors;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        for (var i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].object === object) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor> {\r\n        for (var i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].physicsBody === body) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        return this._physicsPlugin.raycast(from, to);\r\n    }\r\n}\r\n","import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { MaterialHelper } from '../Materials/materialHelper';\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _colorShader: ShaderMaterial;\r\n\r\n    private color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        var defines: string[] = [];\r\n        var options = {\r\n            attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this.color4 = new Color4();\r\n        }\r\n        else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options);\r\n    }\r\n\r\n    private _addClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.push(define);\r\n    }\r\n\r\n    private _removeClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.splice(index, 1);\r\n    }\r\n\r\n    public isReady() {\r\n        const scene = this.getScene();\r\n\r\n        // Clip planes\r\n        scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\r\n        scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\r\n        scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\r\n        scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\r\n        scene.clipPlane5 ? this._addClipPlaneDefine(\"CLIPPLANE5\") : this._removeClipPlaneDefine(\"CLIPPLANE5\");\r\n        scene.clipPlane6 ? this._addClipPlaneDefine(\"CLIPPLANE6\") : this._removeClipPlaneDefine(\"CLIPPLANE6\");\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get material(): Material {\r\n        return this._colorShader;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public set material(value: Material) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._colorShader.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        this._geometry._bind(colorEffect, indexToBind);\r\n\r\n        // Color\r\n        if (!this.useVertexColor) {\r\n            const { r, g, b } = this.color;\r\n            this.color4.set(r, g, b, this.alpha);\r\n            this._colorShader.setColor4(\"color\", this.color4);\r\n        }\r\n\r\n        // Clip planes\r\n        MaterialHelper.BindClipPlane(colorEffect!, this.getScene());\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        var engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        }\r\n        else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._colorShader.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see http://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        return new InstancedLinesMesh(name, this);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initilized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { PhysicsImpostor, IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsJoint, IMotorEnabledJoint, DistanceJointData } from \"../../Physics/physicsJoint\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Nullable } from \"../../types\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { ShapeBuilder } from \"../../Meshes/Builders/shapeBuilder\";\r\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { LinesMesh } from '../../Meshes/linesMesh';\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\ndeclare var Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n\r\n    private static readonly DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly KINEMATIC_FLAG = 2;\r\n    private static readonly DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            ammoInjection(this.bjsAMMO);\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = () => { this._tmpContactCallbackResult = true; };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (var impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (var mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            }\r\n            else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (var collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (var otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({ body: otherImpostor.physicsBody });\r\n                                    otherImpostor.onCollide({ body: mainImpostor.physicsBody });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        }\r\n        else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        var bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        var nbVertices = bodyVertices.size();\r\n        var node: any;\r\n        var nodePositions: any;\r\n        var x, y, z: number;\r\n        var path: Array<Vector3> = new Array();\r\n        for (var n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        var object = impostor.object;\r\n        var shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = LinesBuilder.CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        }\r\n        else {\r\n            impostor.object = ShapeBuilder.ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        var normalDirection = (impostor.type === PhysicsImpostor.ClothImpostor) ? 1 : -1;\r\n        var object = impostor.object;\r\n        var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        var nbVertices = vertexPositions.length / 3;\r\n        var bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        var node: any;\r\n        var nodePositions: any;\r\n        var nodeNormals: any;\r\n        var x, y, z: number;\r\n        var nx, ny, nz: number;\r\n        for (var n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            var nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        var vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            var worldPoint = this._tmpAmmoVectorA;\r\n            var impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint into world space\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                impostor.object.getWorldMatrix().invertToRef(this._tmpMatrix);\r\n                Vector3.TransformCoordinatesToRef(contactPoint, this._tmpMatrix, this._tmpVector);\r\n                contactPoint = this._tmpVector;\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        }\r\n        else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            var worldPoint = this._tmpAmmoVectorA;\r\n            var impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint into world space\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                impostor.object.getWorldMatrix().invertToRef(this._tmpMatrix);\r\n                Vector3.TransformCoordinatesToRef(contactPoint, this._tmpMatrix, this._tmpVector);\r\n                contactPoint = this._tmpVector;\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        }\r\n        else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            var colShape = this._createShape(impostor);\r\n            var mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            }\r\n            else {\r\n                var localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                var startTransform = new this.bjsAMMO.btTransform();\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion!.x, impostor.object.rotationQuaternion!.y, impostor.object.rotationQuaternion!.z, impostor.object.rotationQuaternion!.w);\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                var myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                var rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                var body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                this.world.addRigidBody(body);\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        var mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        var connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        var jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        var joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint:\r\n                var distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                var mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                var connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\r\n                break;\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        var triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var faceCount = indices.length / 3;\r\n            for (var i = 0; i < faceCount; i++) {\r\n                var triPoints = [];\r\n                for (var point = 0; point < 3; point++) {\r\n                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    var vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var newPoints = [];\r\n            var newNorms = [];\r\n            for (var i = 0; i < vertexPositions.length; i += 3) {\r\n                var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            var vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            var vertex_data = this._softVertexData(impostor);\r\n            var vertexPositions = vertex_data.positions;\r\n            var vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            else {\r\n                var triPoints = [];\r\n                var triNorms = [];\r\n                for (var i = 0; i < vertexPositions.length; i += 3) {\r\n                    var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                var softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(\r\n                    this.world.getWorldInfo(),\r\n                    triPoints,\r\n                    object.getIndices(),\r\n                    indices.length / 3,\r\n                    true\r\n                );\r\n\r\n                var nbVertices = vertexPositions.length / 3;\r\n                var bodyVertices = softBody.get_m_nodes();\r\n                var node: any;\r\n                var nodeNormals: any;\r\n                for (var i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    var nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            var vertex_data = this._softVertexData(impostor);\r\n            var vertexPositions = vertex_data.positions;\r\n            var vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            else {\r\n                var len = vertexPositions.length;\r\n                var segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                var segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                var clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        var len: number;\r\n        var segments: number;\r\n        var vertex_data = this._softVertexData(impostor);\r\n        var vertexPositions = vertex_data.positions;\r\n        var vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        var vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        var reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        var reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) { // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        }\r\n        else { //extruded mesh\r\n            impostor._isFromLine = false;\r\n            var pathVectors = impostor.getParam(\"path\");\r\n            var shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            if ((vertexPositions!.length % (3 * pathVectors.length)) !== 0) {\r\n                Logger.Warn(\"Path does not match extrusion\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        var fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = (fixedPoints > 3) ? 3 : fixedPoints;\r\n\r\n        var ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(\r\n            this.world.getWorldInfo(),\r\n            this._tmpAmmoVectorA,\r\n            this._tmpAmmoVectorB,\r\n            segments - 1,\r\n            fixedPoints\r\n        );\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        var triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var faceCount = indices.length / 3;\r\n            for (var i = 0; i < faceCount; i++) {\r\n                var triPoints = [];\r\n                for (var point = 0; point < 3; point++) {\r\n                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    var vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        var object = impostor.object;\r\n\r\n        var returnValue: any;\r\n        var extendSize = impostor.getObjectExtendSize();\r\n\r\n        if (!ignoreChildren) {\r\n            var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            var childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                var childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    var shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    var parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    var s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion!.x, childMesh.rotationQuaternion!.y, childMesh.rotationQuaternion!.z, childMesh.rotationQuaternion!.w);\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    var shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsylon or with a Math function\r\n                if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 0.0001) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    var positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    var radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                returnValue = new this.bjsAMMO.btCapsuleShape(extendSize.x / 2, extendSize.y / 2);\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor:\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    var tetraMesh = new this.bjsAMMO.btTriangleMesh();\r\n                    impostor._pluginData.toDispose.push(tetraMesh);\r\n                    var triangeCount = this._addMeshVerts(tetraMesh, object, object);\r\n                    if (triangeCount == 0) {\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);\r\n                    }\r\n                    break;\r\n                }\r\n            // Otherwise create convexHullImpostor\r\n            case PhysicsImpostor.ConvexHullImpostor:\r\n                var convexMesh = new this.bjsAMMO.btConvexHullShape();\r\n                var triangeCount = this._addHullVerts(convexMesh, object, object);\r\n                if (triangeCount == 0) {\r\n                    // Cleanup Unused Convex Hull Shape\r\n                    impostor._pluginData.toDispose.push(convexMesh);\r\n                    returnValue = new this.bjsAMMO.btCompoundShape();\r\n                } else {\r\n                    returnValue = convexMesh;\r\n                }\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics body position/rotation from the babylon mesh's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        var trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate riged body\r\n        if (\r\n            trans.getOrigin().x() != newPosition.x ||\r\n            trans.getOrigin().y() != newPosition.y ||\r\n            trans.getOrigin().z() != newPosition.z ||\r\n            trans.getRotation().x() != newRotation.x ||\r\n            trans.getRotation().y() != newRotation.y ||\r\n            trans.getRotation().z() != newRotation.z ||\r\n            trans.getRotation().w() != newRotation.w\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                var motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        if (impostor.soft) {\r\n            var v = impostor.physicsBody.linearVelocity();\r\n        }\r\n        else {\r\n            var v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        var result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        if (impostor.soft) {\r\n            var v = impostor.physicsBody.angularVelocity();\r\n        }\r\n        else {\r\n            var v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        var result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets resitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            }\r\n            else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        }\r\n        else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Append an anchor to a cloth object\r\n    * @param impostor is the cloth impostor to add anchor to\r\n    * @param otherImpostor is the rigid impostor to anchor to\r\n    * @param width ratio across width from 0 to 1\r\n    * @param height ratio up height from 0 to 1\r\n    * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech\r\n    * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n    */\r\n    public appendAnchor(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, width: number, height: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        var segs = impostor.segments;\r\n        var nbAcross = Math.round((segs - 1) * width);\r\n        var nbUp = Math.round((segs - 1) * height);\r\n        var nbDown = segs - 1 - nbUp;\r\n        var node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        var node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        Logger.Warn(\"sleepBody is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     * @param joint joint to update\r\n     * @param maxDistance maximum distance of the joint\r\n     * @param minDistance minimum distance of the joint\r\n     */\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     * @param motorIndex index of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     * @param joint joint to set limit on\r\n     * @param upperLimit upper limit\r\n     * @param lowerLimit lower limit\r\n     */\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number) {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        var body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        var exntend = impostor.getObjectExtendSize();\r\n        return exntend.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        var exntend = impostor.getObjectExtendSize();\r\n        result.x = exntend.x;\r\n        result.y = exntend.y;\r\n        result.z = exntend.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of tmp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            this._raycastResult.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n        return this._raycastResult;\r\n    }\r\n}\r\n","import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from '../../Maths/math.path';\r\n\r\nMesh.ExtrudeShape = (name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (name: string, shape: Vector3[], path: Vector3[], scaleFunction: Function, rotationFunction: Function, ribbonCloseArray: boolean, ribbonClosePath: boolean, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class ShapeBuilder {\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShape(name: string, options: { shape: Vector3[], path: Vector3[], scale?: number, rotation?: number, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scale = options.scale || 1;\r\n        var rotation = options.rotation || 0;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance || null;\r\n        var invertUV = options.invertUV || false;\r\n\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShapeCustom(name: string, options: { shape: Vector3[], path: Vector3[], scaleFunction?: any, rotationFunction?: any, ribbonCloseArray?: boolean, ribbonClosePath?: boolean, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scaleFunction = options.scaleFunction || (() => { return 1; });\r\n        var rotationFunction = options.rotationFunction || (() => { return 0; });\r\n        var ribbonCloseArray = options.ribbonCloseArray || false;\r\n        var ribbonClosePath = options.ribbonClosePath || false;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    private static _ExtrudeShapeGeneric(name: string, shape: Vector3[], curve: Vector3[], scale: Nullable<number>, rotation: Nullable<number>, scaleFunction: Nullable<{ (i: number, distance: number): number; }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number; }>, rbCA: boolean, rbCP: boolean, cap: number, custom: boolean,\r\n        scene: Nullable<Scene>, updtbl: boolean, side: number, instance: Nullable<Mesh>, invertUV: boolean, frontUVs: Nullable<Vector4>, backUVs: Nullable<Vector4>): Mesh {\r\n        // extrusion geometry\r\n        var extrusionPathArray = (shape: Vector3[], curve: Vector3[], path3D: Path3D, shapePaths: Vector3[][], scale: Nullable<number>, rotation: Nullable<number>,\r\n            scaleFunction: Nullable<{ (i: number, distance: number): number; }>, rotateFunction: Nullable<{ (i: number, distance: number): number; }>, cap: number, custom: boolean) => {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var binormals = path3D.getBinormals();\r\n            var distances = path3D.getDistances();\r\n\r\n            var angle = 0;\r\n            var returnScale: { (i: number, distance: number): number; } = () => { return scale !== null ? scale : 1; };\r\n            var returnRotation: { (i: number, distance: number): number; } = () => { return rotation !== null ? rotation : 0; };\r\n            var rotate: { (i: number, distance: number): number; } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n            var scl: { (i: number, distance: number): number; } = custom && scaleFunction ? scaleFunction : returnScale;\r\n            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;\r\n            var rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n            for (var i = 0; i < curve.length; i++) {\r\n                var shapePath = new Array<Vector3>();\r\n                var angleStep = rotate(i, distances[i]);\r\n                var scaleRatio = scl(i, distances[i]);\r\n                for (var p = 0; p < shape.length; p++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                    var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));\r\n                    var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                    shapePath[p] = rotated;\r\n                }\r\n                shapePaths[index] = shapePath;\r\n                angle += angleStep;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = (shapePath: Vector3[]) => {\r\n                var pointCap = Array<Vector3>();\r\n                var barycenter = Vector3.Zero();\r\n                var i: number;\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    barycenter.addInPlace(shapePath[i]);\r\n                }\r\n                barycenter.scaleInPlace(1.0 / shapePath.length);\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    pointCap.push(barycenter);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return shapePaths;\r\n        };\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // instance update\r\n            let storage = instance._creationDataStorage!;\r\n            path3D = storage.path3D.update(curve);\r\n            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n            instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\r\n\r\n            return instance;\r\n        }\r\n        // extruded shape creation\r\n        path3D = <any>new Path3D(curve);\r\n        var newShapePaths = new Array<Array<Vector3>>();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n        var extrudedGeneric = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);\r\n        extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n        extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n        extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n        return extrudedGeneric;\r\n    }\r\n}","import { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the gorund\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @hidden */\r\n    public _subdivisionsX: number;\r\n    /** @hidden */\r\n    public _subdivisionsY: number;\r\n    /** @hidden */\r\n    public _width: number;\r\n    /** @hidden */\r\n    public _height: number;\r\n    /** @hidden */\r\n    public _minX: number;\r\n    /** @hidden */\r\n    public _maxX: number;\r\n    /** @hidden */\r\n    public _minZ: number;\r\n    /** @hidden */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the Worl system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        var normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        var world = this.getWorldMatrix();\r\n        var tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n    * if the ground has been updated.\r\n    * This can be used in the render loop.\r\n    * @returns the GroundMesh.\r\n    */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\r\n        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\r\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        var facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        var v1 = TmpVectors.Vector3[3];\r\n        var v2 = TmpVectors.Vector3[2];\r\n        var v3 = TmpVectors.Vector3[1];\r\n        var v4 = TmpVectors.Vector3[0];\r\n        var v1v2 = TmpVectors.Vector3[4];\r\n        var v1v3 = TmpVectors.Vector3[5];\r\n        var v1v4 = TmpVectors.Vector3[6];\r\n        var norm1 = TmpVectors.Vector3[7];\r\n        var norm2 = TmpVectors.Vector3[8];\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var cd = 0;     // 2D slope coefficient : z = cd * x + h\r\n        var h = 0;\r\n        var d1 = 0;     // facet plane equation : ax + by + cz + d = 0\r\n        var d2 = 0;\r\n\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x;             // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1);  // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                var quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        var result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh, _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from './transformNode';\r\nimport { Light } from '../Lights/light';\r\nimport { VertexBuffer } from './buffer';\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    let instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (var key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n\r\n    /** @hidden */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations;\r\n        for (var range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo();\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(light: Light): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false): InstancedMesh {\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            let differentSign = (this._currentLOD._getWorldMatrixDeterminant() > 0) !== (this._getWorldMatrixDeterminant() > 0);\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            let tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return TmpVectors.Matrix[0];\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n\r\n        if (this._currentLOD === this.sourceMesh) {\r\n            return this.sourceMesh;\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node>= null, doNotCloneChildren?: boolean): InstancedMesh {\r\n        var result = this._sourceMesh.createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\"], []);\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\r\n                var mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /** @hidden */\r\n        _userInstancedBuffersStorage: {\r\n            data: {[key: string]: Float32Array},\r\n            sizes: {[key: string]: number},\r\n            vertexBuffers: {[key: string]: Nullable<VertexBuffer>},\r\n            strides: {[key: string]: number}\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         */\r\n        instancedBuffers: {[key: string]: any};\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function(kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this.removeVerticesData(kind);\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (var instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {}\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n    this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]!);\r\n\r\n    for (var instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function(visibleInstances: InstancedMesh[], renderSelf: boolean) {\r\n    let instanceCount = visibleInstances.length;\r\n\r\n    for (var kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        let stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        let expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        let data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            offset += stride;\r\n            let value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n        }\r\n\r\n        for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            let instance = visibleInstances[instanceIndex]!;\r\n\r\n            let value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n            this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]!);\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function() {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (var kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Holds the data for the raycast result\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport class PhysicsRaycastResult {\r\n\r\n    private _hasHit: boolean = false;\r\n\r\n    private _hitDistance: number = 0;\r\n    private _hitNormalWorld: Vector3 = Vector3.Zero();\r\n    private _hitPointWorld: Vector3 = Vector3.Zero();\r\n    private _rayFromWorld: Vector3 = Vector3.Zero();\r\n    private _rayToWorld: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets if there was a hit\r\n     */\r\n    get hasHit(): boolean {\r\n        return this._hasHit;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance from the hit\r\n     */\r\n    get hitDistance(): number {\r\n        return this._hitDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit normal/direction in the world\r\n     */\r\n    get hitNormalWorld(): Vector3 {\r\n        return this._hitNormalWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit point in the world\r\n     */\r\n    get hitPointWorld(): Vector3 {\r\n        return this._hitPointWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"start point\" of the ray in the world\r\n     */\r\n    get rayFromWorld(): Vector3 {\r\n        return this._rayFromWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"end point\" of the ray in the world\r\n     */\r\n    get rayToWorld(): Vector3 {\r\n        return this._rayToWorld;\r\n    }\r\n\r\n    /**\r\n     * Sets the hit data (normal & point in world space)\r\n     * @param hitNormalWorld defines the normal in world space\r\n     * @param hitPointWorld defines the point in world space\r\n     */\r\n    public setHitData(hitNormalWorld: IXYZ, hitPointWorld: IXYZ) {\r\n        this._hasHit = true;\r\n        this._hitNormalWorld = new Vector3(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);\r\n        this._hitPointWorld = new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);\r\n    }\r\n\r\n    /**\r\n     * Sets the distance from the start point to the hit point\r\n     * @param distance\r\n     */\r\n    public setHitDistance(distance: number) {\r\n        this._hitDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance manually\r\n     */\r\n    public calculateHitDistance() {\r\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     * @param from The from point on world space\r\n     * @param to The to point on world space\r\n     */\r\n    public reset(from: Vector3 = Vector3.Zero(), to: Vector3 = Vector3.Zero()) {\r\n        this._rayFromWorld = from;\r\n        this._rayToWorld = to;\r\n\r\n        this._hasHit = false;\r\n        this._hitDistance = 0;\r\n\r\n        this._hitNormalWorld = Vector3.Zero();\r\n        this._hitPointWorld = Vector3.Zero();\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Interface for the size containing width and height\r\n */\r\ninterface IXYZ {\r\n    /**\r\n     * X\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * Y\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Z\r\n     */\r\n    z: number;\r\n}\r\n","import { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport { Node } from \"../node\";\r\n\r\nimport { IPhysicsEngine, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport { PhysicsEngine } from \"./physicsEngine\";\r\nimport { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @hidden */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine\r\n         * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n         * @return a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n        * An event triggered when physic simulation is about to be run\r\n        */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function(): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n * @return a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function(gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePlugin): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        this._physicsEngine = new PhysicsEngine(gravity, plugin);\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function(): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function(): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function(compound: any): void {\r\n    var mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/** @hidden */\r\nScene.prototype._advancePhysicsEngineStep = function(step: number) {\r\n    if (this._physicsEngine) {\r\n        let subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see http://doc.babylonjs.com/features/physics_engine\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see http://doc.babylonjs.com/features/physics_engine\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see http://doc.babylonjs.com/how_to/using_the_physics_engine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @hidden */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function(this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function(this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see http://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function(): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see http://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function(force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n","import { Effect } from \"../Materials/effect\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nlet name = 'colorPixelShader';\nlet shader = `#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\n#ifdef VERTEXCOLOR\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var colorPixelShader = { name, shader };\n","import { Effect } from \"../Materials/effect\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nlet name = 'colorVertexShader';\nlet shader = `\nattribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<clipPlaneVertexDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\nvoid main(void) {\n#include<instancesVertex>\n#include<bonesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var colorVertexShader = { name, shader };\n","import { Vector4, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from '../../types';\r\n\r\nVertexData.CreateSphere = function(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var segments: number = options.segments || 32;\r\n    var diameterX: number = options.diameterX || options.diameter || 1;\r\n    var diameterY: number = options.diameterY || options.diameter || 1;\r\n    var diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice: number = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            var rotationZ = Matrix.RotationZ(-angleZ);\r\n            var rotationY = Matrix.RotationY(angleY);\r\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                indices.push((firstIndex));\r\n                indices.push((firstIndex + 1));\r\n                indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                indices.push((firstIndex + totalYRotationSteps + 1));\r\n                indices.push((firstIndex + 1));\r\n                indices.push((firstIndex + totalYRotationSteps + 2));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class SphereBuilder {\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    public static CreateSphere(name: string, options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var sphere = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateSphere(options);\r\n\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n        return sphere;\r\n    }\r\n}\r\n"],"sourceRoot":""}